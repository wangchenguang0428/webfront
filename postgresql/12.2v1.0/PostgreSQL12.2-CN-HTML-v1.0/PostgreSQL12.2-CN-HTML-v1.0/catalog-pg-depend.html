<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>51.18. pg_depend</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="catalog-pg-default-acl.html" title="51.17. pg_default_acl" /><link rel="next" href="catalog-pg-description.html" title="51.19. pg_description" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">51.18. <code xmlns="http://www.w3.org/1999/xhtml" class="structname">pg_depend</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="catalog-pg-default-acl.html" title="51.17. pg_default_acl">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="catalogs.html" title="第 51 章 系统目录">上一级</a></td><th width="60%" align="center">第 51 章 系统目录</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="catalog-pg-description.html" title="51.19. pg_description">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="CATALOG-PG-DEPEND"><div class="titlepage"><div><div><h2 class="title" style="clear: both">51.18. <code class="structname">pg_depend</code></h2></div></div></div><a id="id-1.10.4.20.2" class="indexterm"></a><p>
   目录<code class="structname">pg_depend</code>记录数据库对象之间的依赖关系。这些信息允许<code class="command">DROP</code>命令查找必须被<code class="command">DROP CASCADE</code>删除的其他对象，或者在<code class="command">DROP RESTRICT</code>情况下阻止删除。
  </p><p>
   另请参阅<a class="link" href="catalog-pg-shdepend.html" title="51.47. pg_shdepend"><code class="structname">pg_shdepend</code></a>，它对在一个数据库集簇中共享的对象之间的依赖提供了相似的功能。
  </p><div class="table" id="id-1.10.4.20.5"><p class="title"><strong>表 51.18. <code class="structname">pg_depend</code>的列</strong></p><div class="table-contents"><table class="table" summary="pg_depend的列" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>类型</th><th>引用</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">classid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-class.html" title="51.11. pg_class"><code class="structname">pg_class</code></a>.oid</code></td><td>依赖对象所在的系统目录OID</td></tr><tr><td><code class="structfield">objid</code></td><td><code class="type">oid</code></td><td>任意OID列</td><td>指定依赖对象的OID</td></tr><tr><td><code class="structfield">objsubid</code></td><td><code class="type">int4</code></td><td> </td><td>
       对于一个表列，这里是列号（<code class="structfield">objid</code>和<code class="structfield">classid</code>指表本身）。对于所有其他对象类型，此列为0。
      </td></tr><tr><td><code class="structfield">refclassid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-class.html" title="51.11. pg_class"><code class="structname">pg_class</code></a>.oid</code></td><td>被引用对象所在的系统目录的OID</td></tr><tr><td><code class="structfield">refobjid</code></td><td><code class="type">oid</code></td><td>任意OID列</td><td>指定被引用对象的OID</td></tr><tr><td><code class="structfield">refobjsubid</code></td><td><code class="type">int4</code></td><td> </td><td>
       对于一个表列，这里是列号（<code class="structfield">refobjid</code>和<code class="structfield">refclassid</code>指表本身）。对于所有其他对象类型，此列为0。
      </td></tr><tr><td><code class="structfield">deptype</code></td><td><code class="type">char</code></td><td> </td><td>
       定义此依赖关系语义的一个代码，见文本
      </td></tr></tbody></table></div></div><br class="table-break" /><p>
   在所有情况下，一个<code class="structname">pg_depend</code>项表明被引用对象不能在没有删除其依赖对象的情况下被删除。但是，其中也有多种依赖类型，由<code class="structfield">deptype</code>标识：

   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="symbol">DEPENDENCY_NORMAL</code> (<code class="literal">n</code>)</span></dt><dd><p>
       在独立创建的对象之间的一个普通关系。依赖对象可以在不影响被依赖对象的情况下被删除。被引用对象只能通过指定<code class="literal">CASCADE</code>被删除，在这种情况下依赖对象也会被删除。 例子：一个表列对于其数据类型有一个普通依赖。
      </p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_AUTO</code> (<code class="literal">a</code>)</span></dt><dd><p>
       依赖对象可以被独立于被依赖对象删除，且应该在被引用对象被删除时自动被删除（不管在<code class="literal">RESTRICT</code>或<code class="literal">CASCADE</code>模式）。例子：一个表上的一个命名约束应该被设置为自动依赖于表，这样在表被删除后它也会消失。
      </p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_INTERNAL</code> (<code class="literal">i</code>)</span></dt><dd><p>
       依赖对象作为被引用对象创建过程的一部分被创建，并且只是其内部实现的一部分。不允许直接<code class="command">DROP</code>所依赖的对象（而是告诉用户对引用对象发出<code class="command">DROP</code>操作）。无论是否指定了<code class="literal">CASCADE</code>，<code class="command">DROP</code>被引用的对象都将导致自动删除从属对象。如果由于删除了对某些其他对象的依赖关系而不得不删除依赖对象，则其删除将转换为对所引用对象的删除，因此依赖对象的<code class="literal">NORMAL</code>和<code class="literal">AUTO</code>依赖关系的行为就像它们是所引用对象的依赖关系。示例：视图的<code class="literal">ON SELECT</code>规则使其在内部依赖于视图，以防止在视图保留时将其删除。规则的依赖关系（例如它引用的表）就好像他们是视图的依赖关系。
      </p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_PARTITION_PRI</code> (<code class="literal">P</code>)<br /></span><span class="term"><code class="symbol">DEPENDENCY_PARTITION_SEC</code> (<code class="literal">S</code>)</span></dt><dd><p>
       依赖对象被作为被引用对象创建过程的一部分创建，并且确实是其内部实现的一部分。但是，不像<code class="literal">INTERNAL</code>，有多个这样的引用对象。除非删除了这些引用对象中的至少一个对象，否则不得删除依赖对象；如果其中任何一个被删除，则不管是否指定了<code class="literal">CASCADE</code>，都应删除依赖对象。也不像<code class="literal">INTERNAL</code>，依赖对象所依赖的某些其他对象的删除不会导致任何分区引用的对象的自动删除。因此，如果删除没有通过其他路径级联到这些对象中的至少一个，它会被拒绝。（大多数情况下，依赖对象与至少一个分区引用对象共享所有非分区的依赖关系，因此此限制不会导致阻止任何级联的删除。）主分区和辅助分区的依赖关系表现相同，除了主分区依赖关系倾向用于错误消息；因此，分区相关的对象应该有一个主分区依赖关系和一个或多个辅助分区依赖关系。注意到分区依赖关系是任何对象所正常拥有的依赖关系的补充，而不是替代。这简化了<code class="command">ATTACH/DETACH PARTITION</code>操作：只要添加或删除分区的依赖关系。例如：子分区索引与其所基于的分区表和父分区索引是分区相关的，因此只要其中一个删除，则子分区索引就消失，否则，就不消失。父索引上的依赖关系是主要的，故如果用户试图删除子分区索引，错误消息反而会建议删除父索引（不是表）。
      </p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_EXTENSION</code> (<code class="literal">e</code>)</span></dt><dd><p>
       依赖对象是作为<em class="firstterm">扩展</em>的被引用对象的一个成员（参见<a class="link" href="catalog-pg-extension.html" title="51.22. pg_extension"><code class="structname">pg_extension</code></a>）。依赖对象可以通过被引用对象上的<code class="command">DROP EXTENSION</code>来删除。在功能上，这种依赖类型和一个<code class="literal">INTERNAL</code>依赖的作用相同，其存在只是为了清晰和简化<span class="application">pg_dump</span>。
      </p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_AUTO_EXTENSION</code> (<code class="literal">x</code>)</span></dt><dd><p>
       依赖对象不是作为被引用对象的扩展的成员（因此不应该被<span class="application">pg_dump</span>忽略），但是没有该扩展它又无法工作，因此如果删除了扩展，则该依赖对象应自动删除。该依赖对象也可以独立删除。功能上，该依赖关系类型与<code class="literal">AUTO</code>依赖相同，但是为了清晰起见和简化<span class="application">pg_dump</span>，将其分开。
      </p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_PIN</code> (<code class="literal">p</code>)</span></dt><dd><p>
       没有依赖对象，这种类型的项是一个信号，用于说明系统本身依赖于被引用对象，并且该对象永远不能被删除。这种类型的项只能被<code class="command">initdb</code>创建。而此种项的依赖对象的列都为0。
      </p></dd></dl></div><p>

   在未来可能会需要其他依赖类型。
  </p><p>
   要注意的是，两个对象很有可能由不止一个<code class="structname">pg_depend</code>条目来链接。例如子分区索引有一个依赖于其关联的分区表的分区类型的依赖关系和依赖于该表索引的每一列的自动依赖关系。此类情形表示多重依赖关系语义的并集，依赖对象的删除可以没有<code class="literal">CASCADE</code>，如果其任一依赖关系满足自动删除的条件。相反地，关于哪些对象必须一起删除的所有依赖关系的限制必须满足。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="catalog-pg-default-acl.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="catalogs.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="catalog-pg-description.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">51.17. <code class="structname">pg_default_acl</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 51.19. <code class="structname">pg_description</code></td></tr></table></div></body></html>