<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>15.2. 何时会用到并行查询？</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="how-parallel-query-works.html" title="15.1. 并行查询如何工作" /><link rel="next" href="parallel-plans.html" title="15.3. 并行计划" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">15.2. 何时会用到并行查询？</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="how-parallel-query-works.html" title="15.1. 并行查询如何工作">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="parallel-query.html" title="第 15 章 并行查询">上一级</a></td><th width="60%" align="center">第 15 章 并行查询</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="parallel-plans.html" title="15.3. 并行计划">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="WHEN-CAN-PARALLEL-QUERY-BE-USED"><div class="titlepage"><div><div><h2 class="title" style="clear: both">15.2. 何时会用到并行查询？</h2></div></div></div><p>
    有几种设置会导致查询规划器在任何情况下都不生成并行查询计划。为了让并行查询计划能够被生成，必须配置好下列设置。
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">max_parallel_workers_per_gather</a>必须被设置为大于零的值。这是一种特殊情况，更加普遍的原则是所用的工作者数量不能超过<code class="varname">max_parallel_workers_per_gather</code>所配置的数量。
      </p></li></ul></div><p>
    此外，系统一定不能运行在单用户模式下。因为在单用户模式下，整个数据库系统运行在单个进程中，没有后台工作者进程可用。
  </p><p>
    如果下面的任一条件为真，即便对一个给定查询通常可以产生并行查询计划，规划器都不会为它产生并行查询计划：
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> 
        查询要写任何数据或者锁定任何数据库行。如果一个查询在顶层或者 CTE 中包含了数据修改操作，那么不会为该查询产生并行计划。一种例外是，<code class="literal">CREATE TABLE ... AS</code>、<code class="literal">SELECT INTO</code>以及<code class="literal">CREATE MATERIALIZED VIEW</code>这些创建新表并填充它的命令可以使用并行计划。
      </p></li><li class="listitem"><p>
        查询可能在执行过程中被暂停。只要在系统认为可能发生部分或者增量式执行，就不会产生并行计划。例如：用<a class="link" href="sql-declare.html" title="DECLARE">DECLARE CURSOR</a>创建的游标将永远不会使用并行计划。类似地，一个<code class="literal">FOR x IN query LOOP .. END LOOP</code>形式的 PL/pgSQL 循环也永远不会使用并行计划，因为当并行查询进行时，并行查询系统无法验证循环中的代码执行起来是安全的。
      </p></li><li class="listitem"><p>
        使用了任何被标记为<code class="literal">PARALLEL UNSAFE</code>的函数的查询。大多数系统定义的函数都被标记为<code class="literal">PARALLEL SAFE</code>，但是用户定义的函数默认被标记为<code class="literal">PARALLEL UNSAFE</code>。参见<a class="xref" href="parallel-safety.html" title="15.4. 并行安全性">第 15.4 节</a>中的讨论。
      </p></li><li class="listitem"><p>
        该查询运行在另一个已经存在的并行查询内部。例如，如果一个被并行查询调用的函数自己发出一个 SQL 查询，那么该查询将不会使用并行计划。这是当前实现的一个限制，但是或许不值得移除这个限制，因为它会导致单个查询使用大量的进程。
      </p></li></ul></div><p>
    即使对于一个特定的查询已经产生了并行查询计划，在一些情况下执行时也不会并行执行该计划。如果发生这种情况，那么领导者将会自己执行该计划在<code class="literal">Gather</code>节点之下的部分，就好像<code class="literal">Gather</code>节点不存在一样。上述情况将在满足下面的任一条件时发生：
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> 
        因为后台工作者进程的总数不能超过<a class="xref" href="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES">max_worker_processes</a>，导致不能得到后台工作者进程。
      </p></li><li class="listitem"><p>
        由于为并行查询目的启动的后台工作者数量不能超过<a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS">max_parallel_workers</a>这一限制而不能得到后台工作者。
      </p></li><li class="listitem"><p> 
        客户端发送了一个执行消息，并且消息中要求取元组的数量不为零。执行消息可见<a class="link" href="protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY" title="52.2.3. 扩展查询">扩展查询协议</a>中的讨论。因为<a class="link" href="libpq.html" title="第 33 章 libpq - C 库">libpq</a>当前没有提供方法来发送这种消息，所以这种情况只可能发生在不依赖 libpq 的客户端中。如果这种情况经常发生，那在它可能发生的会话中设置 <a class="xref" href="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER">max_parallel_workers_per_gather</a>为零是一个很好的主意，这样可以避免产生连续运行时次优的查询计划。
      </p></li></ul></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="how-parallel-query-works.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="parallel-query.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="parallel-plans.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">15.1. 并行查询如何工作 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 15.3. 并行计划</td></tr></table></div></body></html>