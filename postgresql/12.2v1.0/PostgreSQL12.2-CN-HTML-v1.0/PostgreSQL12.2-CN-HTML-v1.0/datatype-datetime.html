<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.5. 日期/时间类型</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="datatype-binary.html" title="8.4. 二进制数据类型" /><link rel="next" href="datatype-boolean.html" title="8.6. 布尔类型" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.5. 日期/时间类型</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="datatype-binary.html" title="8.4. 二进制数据类型">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="第 8 章 数据类型">上一级</a></td><th width="60%" align="center">第 8 章 数据类型</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="datatype-boolean.html" title="8.6. 布尔类型">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="DATATYPE-DATETIME"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.5. 日期/时间类型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="datatype-datetime.html#DATATYPE-DATETIME-INPUT">8.5.1.  日期/时间输入</a></span></dt><dt><span class="sect2"><a href="datatype-datetime.html#DATATYPE-DATETIME-OUTPUT">8.5.2. 日期/时间输出</a></span></dt><dt><span class="sect2"><a href="datatype-datetime.html#DATATYPE-TIMEZONES">8.5.3.  时区</a></span></dt><dt><span class="sect2"><a href="datatype-datetime.html#DATATYPE-INTERVAL-INPUT">8.5.4. 间隔输入</a></span></dt><dt><span class="sect2"><a href="datatype-datetime.html#DATATYPE-INTERVAL-OUTPUT">8.5.5. 间隔输出</a></span></dt></dl></div><a id="id-1.5.7.13.2" class="indexterm"></a><a id="id-1.5.7.13.3" class="indexterm"></a><a id="id-1.5.7.13.4" class="indexterm"></a><a id="id-1.5.7.13.5" class="indexterm"></a><a id="id-1.5.7.13.6" class="indexterm"></a><a id="id-1.5.7.13.7" class="indexterm"></a><a id="id-1.5.7.13.8" class="indexterm"></a><a id="id-1.5.7.13.9" class="indexterm"></a><a id="id-1.5.7.13.10" class="indexterm"></a><a id="id-1.5.7.13.11" class="indexterm"></a><p>
    <span class="productname">PostgreSQL</span>支持<acronym class="acronym">SQL</acronym>中所有的日期和时间类型，如<a class="xref" href="datatype-datetime.html#DATATYPE-DATETIME-TABLE" title="表 8.9. 日期/时间类型">表 8.9</a>所示。这些数据类型上可用的操作如<a class="xref" href="functions-datetime.html" title="9.9. 时间/日期函数和操作符">第 9.9 节</a>所述。日期根据公历来计算，即使对于该历法被引入之前的年份也一样（见<a class="xref" href="datetime-units-history.html" title="B.5. 单位的历史">第 B.5 节</a>）。
   </p><div class="table" id="DATATYPE-DATETIME-TABLE"><p class="title"><strong>表 8.9. 日期/时间类型</strong></p><div class="table-contents"><table class="table" summary="日期/时间类型" border="1"><colgroup><col /><col /><col /><col /><col /><col /></colgroup><thead><tr><th>名字</th><th>存储尺寸</th><th>描述</th><th>最小值</th><th>最大值</th><th>解析度</th></tr></thead><tbody><tr><td><code class="type">timestamp [ (<em class="replaceable"><code>p</code></em>) ] [ without time zone ]</code></td><td>8字节</td><td>包括日期和时间（无时区）</td><td>4713 BC</td><td>294276 AD</td><td>1微秒</td></tr><tr><td><code class="type">timestamp [ (<em class="replaceable"><code>p</code></em>) ] with time zone</code></td><td>8字节</td><td>包括日期和时间，有时区</td><td>4713 BC</td><td>294276 AD</td><td>1微秒</td></tr><tr><td><code class="type">date</code></td><td>4字节</td><td>日期（没有一天中的时间）</td><td>4713 BC</td><td>5874897 AD</td><td>1日</td></tr><tr><td><code class="type">time [ (<em class="replaceable"><code>p</code></em>) ] [ without time zone ]</code></td><td>8字节</td><td>一天中的时间（无日期）</td><td>00:00:00</td><td>24:00:00</td><td>1微秒</td></tr><tr><td><code class="type">time [ (<em class="replaceable"><code>p</code></em>) ] with time zone</code></td><td>12字节</td><td>仅仅是一天中的时间（没有日期），带有时区</td><td>00:00:00+1459</td><td>24:00:00-1459</td><td>1微秒</td></tr><tr><td><code class="type">interval [ <em class="replaceable"><code>fields</code></em> ] [ (<em class="replaceable"><code>p</code></em>) ]</code></td><td>16字节</td><td>时间间隔</td><td>-178000000年</td><td>178000000年</td><td>1微秒</td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注意</h3><p>
     SQL要求只写<code class="type">timestamp</code>等效于<code class="type">timestamp without time zone</code>，并且<span class="productname">PostgreSQL</span>鼓励这种行为。<code class="type">timestamptz</code>被接受为<code class="type">timestamp with time zone</code>的一种简写，这是一种<span class="productname">PostgreSQL</span>的扩展。
    </p></div><p>
    <code class="type">time</code>、<code class="type">timestamp</code>和<code class="type">interval</code>接受一个可选的精度值 <em class="replaceable"><code>p</code></em>，这个精度值声明在秒域中小数点之后保留的位数。缺省情况下，在精度上没有明确的边界。<em class="replaceable"><code>p</code></em>允许的范围是从 0 到 6。
   </p><p>
    <code class="type">interval</code>类型有一个附加选项，它可以通过写下面之一的短语来限制存储的fields的集合：
</p><pre class="literallayout">
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
</pre><p>
    注意如果<em class="replaceable"><code>fields</code></em>和<em class="replaceable"><code>p</code></em>被指定，<em class="replaceable"><code>fields</code></em>必须包括<code class="literal">SECOND</code>，因为精度只应用于秒。
   </p><p>
    类型<code class="type">time with time zone</code>是 SQL 标准定义的，但是该定义显示出了一些会影响可用性的性质。在大多数情况下， <code class="type">date</code>、<code class="type">time</code>、<code class="type">timestamp without time zone</code>和<code class="type">timestamp with time zone</code>的组合就应该能提供任何应用所需的全范围的日期/时间功能。
   </p><div class="sect2" id="DATATYPE-DATETIME-INPUT"><div class="titlepage"><div><div><h3 class="title">8.5.1.  日期/时间输入</h3></div></div></div><p>
     日期和时间的输入可以接受几乎任何合理的格式，包括 ISO 8601、<acronym class="acronym">SQL</acronym>-兼容的、传统<span class="productname">POSTGRES</span>的和其他的形式。 对于一些格式，日期输入里的日、月和年的顺序会让人混淆， 并且支持指定所预期的这些域的顺序。把<a class="xref" href="runtime-config-client.html#GUC-DATESTYLE">DateStyle</a>参数设置为<code class="literal">MDY</code>，就是选择“月－日－年”的解释，设置为<code class="literal">DMY</code>就是 “日－月－年”，而<code class="literal">YMD</code>是 “年－月－日”。
    </p><p>
     <span class="productname">PostgreSQL</span>在处理日期/时间输入上比<acronym class="acronym">SQL</acronym>标准要求的更灵活。 参阅<a class="xref" href="datetime-appendix.html" title="附录 B. 日期/时间支持">附录 B</a>获取关于日期/时间输入的准确的分析规则和可识别文本域，包括月份、星期几和时区。
    </p><p>
     请记住任何日期或者时间的文字输入需要由单引号包围，就象一个文本字符串一样。参考<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS-GENERIC" title="4.1.2.7. 其他类型的常量">第 4.1.2.7 节</a>获取更多信息。<acronym class="acronym">SQL</acronym>要求下面的语法
</p><pre class="synopsis">
<em class="replaceable"><code>type</code></em> [ (<em class="replaceable"><code>p</code></em>) ] '<em class="replaceable"><code>value</code></em>'
</pre><p>
     其中<em class="replaceable"><code>p</code></em>是一个可选的精度声明，它给出了在秒域中的小数位数目。精度可以被指定给<code class="type">time</code>、<code class="type">timestamp</code>和<code class="type">interval</code>类型，并且可以取从0到6的值。这允许前文所述的值。如果在一个常数声明中没有指定任何精度，它将默认取文字值的精度（但不能超过6位）。
    </p><div class="sect3" id="id-1.5.7.13.18.5"><div class="titlepage"><div><div><h4 class="title">8.5.1.1. 日期</h4></div></div></div><a id="id-1.5.7.13.18.5.2" class="indexterm"></a><p>
     <a class="xref" href="datatype-datetime.html#DATATYPE-DATETIME-DATE-TABLE" title="表 8.10. 日期输入">表 8.10</a>显示了<code class="type">date</code>类型可能的输入方式。
    </p><div class="table" id="DATATYPE-DATETIME-DATE-TABLE"><p class="title"><strong>表 8.10. 日期输入</strong></p><div class="table-contents"><table class="table" summary="日期输入" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>例子</th><th>描述</th></tr></thead><tbody><tr><td>1999-01-08</td><td>ISO 8601; 任何模式下的1月8日
         （推荐格式）</td></tr><tr><td>January 8, 1999</td><td>在任何<code class="varname">datestyle</code>输入模式下都无歧义</td></tr><tr><td>1/8/1999</td><td><code class="literal">MDY</code>模式中的1月8日；<code class="literal">DMY</code>模式中的8月1日</td></tr><tr><td>1/18/1999</td><td><code class="literal">MDY</code>模式中的1月18日；在其他模式中被拒绝</td></tr><tr><td>01/02/03</td><td><code class="literal">MDY</code>模式中的2003年1月2日；
          <code class="literal">DMY</code>模式中的2003年2月1日；
          <code class="literal">YMD</code>模式中的2001年2月3日
         </td></tr><tr><td>1999-Jan-08</td><td>任何模式下的1月8日</td></tr><tr><td>Jan-08-1999</td><td>任何模式下的1月8日</td></tr><tr><td>08-Jan-1999</td><td>任何模式下的1月8日</td></tr><tr><td>99-Jan-08</td><td><code class="literal">YMD</code>模式中的1月8日，否则错误</td></tr><tr><td>08-Jan-99</td><td>1月8日，除了在<code class="literal">YMD</code>模式中错误</td></tr><tr><td>Jan-08-99</td><td>1月8日，除了在<code class="literal">YMD</code>模式中错误</td></tr><tr><td>19990108</td><td>ISO 8601; 任何模式中的1999年1月8日</td></tr><tr><td>990108</td><td>ISO 8601; 任何模式中的1999年1月8日</td></tr><tr><td>1999.008</td><td>年和一年中的日子</td></tr><tr><td>J2451187</td><td>儒略日期</td></tr><tr><td>January 8, 99 BC</td><td>公元前99年</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect3" id="id-1.5.7.13.18.6"><div class="titlepage"><div><div><h4 class="title">8.5.1.2. 时间</h4></div></div></div><a id="id-1.5.7.13.18.6.2" class="indexterm"></a><a id="id-1.5.7.13.18.6.3" class="indexterm"></a><a id="id-1.5.7.13.18.6.4" class="indexterm"></a><p>
      当日时间类型是<code class="type">time [ (<em class="replaceable"><code>p</code></em>) ] without time zone</code>和<code class="type">time [ (<em class="replaceable"><code>p</code></em>) ] with time zone</code>。 只写<code class="type">time</code>等效于<code class="type">time without time zone</code>。
     </p><p>
      这些类型的有效输入由当日时间后面跟着可选的时区组成（参阅<a class="xref" href="datatype-datetime.html#DATATYPE-DATETIME-TIME-TABLE" title="表 8.11. 时间输入">表 8.11</a>和<a class="xref" href="datatype-datetime.html#DATATYPE-TIMEZONE-TABLE" title="表 8.12. 时区输入">表 8.12</a>）。 如果在<code class="type">time without time zone</code>的输入中指定了时区，那么它会被无声地忽略。你也可以指定一个日期但是它会被忽略，除非你使用了一个涉及到夏令时规则的时区，例如<code class="literal">America/New_York</code>。在这种情况下，为了判断是应用了标准时间还是夏令时时间，要求指定该日期。适当的时区偏移被记录在<code class="type">time with time zone</code>值中。
     </p><div class="table" id="DATATYPE-DATETIME-TIME-TABLE"><p class="title"><strong>表 8.11. 时间输入</strong></p><div class="table-contents"><table class="table" summary="时间输入" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>例子</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal">04:05:06.789</code></td><td>ISO 8601</td></tr><tr><td><code class="literal">04:05:06</code></td><td>ISO 8601</td></tr><tr><td><code class="literal">04:05</code></td><td>ISO 8601</td></tr><tr><td><code class="literal">040506</code></td><td>ISO 8601</td></tr><tr><td><code class="literal">04:05 AM</code></td><td>和04:05一样，AM并不影响值</td></tr><tr><td><code class="literal">04:05 PM</code></td><td>和16:05一样，输入的小时必须为 &lt;= 12</td></tr><tr><td><code class="literal">04:05:06.789-8</code></td><td>ISO 8601</td></tr><tr><td><code class="literal">04:05:06-08:00</code></td><td>ISO 8601</td></tr><tr><td><code class="literal">04:05-08:00</code></td><td>ISO 8601</td></tr><tr><td><code class="literal">040506-08</code></td><td>ISO 8601</td></tr><tr><td><code class="literal">04:05:06 PST</code></td><td>缩写指定的时区</td></tr><tr><td><code class="literal">2003-04-12 04:05:06 America/New_York</code></td><td>全名指定的时区</td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="DATATYPE-TIMEZONE-TABLE"><p class="title"><strong>表 8.12. 时区输入</strong></p><div class="table-contents"><table class="table" summary="时区输入" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>例子</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal">PST</code></td><td>缩写（太平洋标准时间）</td></tr><tr><td><code class="literal">America/New_York</code></td><td>完整时区名</td></tr><tr><td><code class="literal">PST8PDT</code></td><td>POSIX风格的时区声明</td></tr><tr><td><code class="literal">-8:00</code></td><td>PST的ISO-8601偏移</td></tr><tr><td><code class="literal">-800</code></td><td>PST的ISO-8601偏移</td></tr><tr><td><code class="literal">-8</code></td><td>PST的ISO-8601偏移</td></tr><tr><td><code class="literal">zulu</code></td><td>UTC的军方缩写</td></tr><tr><td><code class="literal">z</code></td><td><code class="literal">zulu</code>的短形式</td></tr></tbody></table></div></div><br class="table-break" /><p>
     参考<a class="xref" href="datatype-datetime.html#DATATYPE-TIMEZONES" title="8.5.3.  时区">第 8.5.3 节</a>可以了解如何指定时区。
    </p></div><div class="sect3" id="id-1.5.7.13.18.7"><div class="titlepage"><div><div><h4 class="title">8.5.1.3. 时间戳</h4></div></div></div><a id="id-1.5.7.13.18.7.2" class="indexterm"></a><a id="id-1.5.7.13.18.7.3" class="indexterm"></a><a id="id-1.5.7.13.18.7.4" class="indexterm"></a><p>
      时间戳类型的有效输入由一个日期和时间的串接组成，后面跟着一个可选的时区，一个可选的<code class="literal">AD</code>或者<code class="literal">BC</code>（另外，<code class="literal">AD</code>/<code class="literal">BC</code>可以出现在时区前面，但这个顺序并非最佳）。 因此：

</p><pre class="programlisting">
1999-01-08 04:05:06
</pre><p>
      和：
</p><pre class="programlisting">
1999-01-08 04:05:06 -8:00
</pre><p>

      都是有效的值，它遵循<acronym class="acronym">ISO</acronym> 8601 标准。另外，使用广泛的格式：
</p><pre class="programlisting">
January 8 04:05:06 1999 PST
</pre><p>
      也被支持。
     </p><p>
      <acronym class="acronym">SQL</acronym>标准通过<span class="quote">“<span class="quote">+</span>”</span>或者<span class="quote">“<span class="quote">-</span>”</span>符号的存在以及时间后面的时区偏移来区分<code class="type">timestamp without time zone</code>和<code class="type">timestamp with time zone</code>文字。因此，根据标准，

      </p><pre class="programlisting">TIMESTAMP '2004-10-19 10:23:54'</pre><p>

      是一个<code class="type">timestamp without time zone</code>， 而

      </p><pre class="programlisting">TIMESTAMP '2004-10-19 10:23:54+02'</pre><p>

      是一个<code class="type">timestamp with time zone</code>。<span class="productname">PostgreSQL</span>从来不会在确定文字串的类型之前检查其内容，因此会把上面两个都看做是 <code class="type">timestamp without time zone</code>。因此要保证把上面的文字当作<code class="type">timestamp with time zone</code>看待， 就要给它正确的显式类型：

      </p><pre class="programlisting">TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</pre><p>

      如果一个文字已被确定是<code class="type">timestamp without time zone</code>，<span class="productname">PostgreSQL</span>将不声不响忽略任何其中指出的时区。 即，结果值是从输入值的日期/时间域衍生出来的，并且没有就时区进行调整。
     </p><p>
      对于<code class="type">timestamp with time zone</code>，内部存储的值总是 UTC （全球统一时间，以前也叫格林威治时间<acronym class="acronym">GMT</acronym>）。如果一个输入值有明确的时区声明， 那么它将用该时区合适的偏移量转换成 UTC。如果在输入串里没有时区声明， 那么它就被假设是在系统的<a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a>参数里的那个时区，然后使用这个 <code class="varname">timezone</code>时区的偏移转换成 UTC。
     </p><p>
      如果一个<code class="type">timestamp with time zone</code>值被输出，那么它总是从 UTC 转换成当前的<code class="varname">timezone</code>时区，并且显示为该时区的本地时间。要看其它时区的时间，要么修改<code class="varname">timezone</code>，要么使用<code class="literal">AT TIME ZONE</code>构造（参阅<a class="xref" href="functions-datetime.html#FUNCTIONS-DATETIME-ZONECONVERT" title="9.9.3. AT TIME ZONE">第 9.9.3 节</a>）。
     </p><p>
      在<code class="type">timestamp without time zone</code>和<code class="type">timestamp with time zone</code>之间的转换通常假设<code class="type">timestamp without time zone</code>值应该以<code class="varname">timezone</code>本地时间的形式接受或者写出。为该转换指定一个不同的可以用<code class="literal">AT TIME ZONE</code>。
     </p></div><div class="sect3" id="id-1.5.7.13.18.8"><div class="titlepage"><div><div><h4 class="title">8.5.1.4. 特殊值</h4></div></div></div><a id="id-1.5.7.13.18.8.2" class="indexterm"></a><a id="id-1.5.7.13.18.8.3" class="indexterm"></a><p>
      为了方便，<span class="productname">PostgreSQL</span>支持一些特殊日期/时间输入值，如<a class="xref" href="datatype-datetime.html#DATATYPE-DATETIME-SPECIAL-TABLE" title="表 8.13. 特殊日期/时间输入">表 8.13</a>所示。这些值中<code class="literal">infinity</code>和<code class="literal">-infinity</code>被在系统内部以特殊方式表示并且将被原封不动地显示。但是其他的仅仅只是概念上的速写，当被读到的时候会被转换为正常的日期/时间值（特殊地，<code class="literal">now</code>及相关串在被读到时立刻被转换到一个指定的时间值）。在作为常量在SQL命令中使用时，所有这些值需要被包括在单引号内。
     </p><div class="table" id="DATATYPE-DATETIME-SPECIAL-TABLE"><p class="title"><strong>表 8.13. 特殊日期/时间输入</strong></p><div class="table-contents"><table class="table" summary="特殊日期/时间输入" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>输入串</th><th>合法类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal">epoch</code></td><td><code class="type">date</code>, <code class="type">timestamp</code></td><td>1970-01-01 00:00:00+00（Unix系统时间0）</td></tr><tr><td><code class="literal">infinity</code></td><td><code class="type">date</code>, <code class="type">timestamp</code></td><td>比任何其他时间戳都晚</td></tr><tr><td><code class="literal">-infinity</code></td><td><code class="type">date</code>, <code class="type">timestamp</code></td><td>比任何其他时间戳都早</td></tr><tr><td><code class="literal">now</code></td><td><code class="type">date</code>, <code class="type">time</code>, <code class="type">timestamp</code></td><td>当前事务的开始时间</td></tr><tr><td><code class="literal">today</code></td><td><code class="type">date</code>, <code class="type">timestamp</code></td><td>今日午夜 (<code class="literal">00:00</code>) </td></tr><tr><td><code class="literal">tomorrow</code></td><td><code class="type">date</code>, <code class="type">timestamp</code></td><td>明日午夜 (<code class="literal">00:00</code>) </td></tr><tr><td><code class="literal">yesterday</code></td><td><code class="type">date</code>, <code class="type">timestamp</code></td><td>昨日午夜 (<code class="literal">00:00</code>) </td></tr><tr><td><code class="literal">allballs</code></td><td><code class="type">time</code></td><td>00:00:00.00 UTC</td></tr></tbody></table></div></div><br class="table-break" /><p>
      下列<acronym class="acronym">SQL</acronym>-兼容的函数可以被用来为相应的数据类型获得当前时间值：
      <code class="literal">CURRENT_DATE</code>、<code class="literal">CURRENT_TIME</code>、
      <code class="literal">CURRENT_TIMESTAMP</code>、<code class="literal">LOCALTIME</code>、
      <code class="literal">LOCALTIMESTAMP</code>。后四种接受一个可选的亚秒精度声明（参见<a class="xref" href="functions-datetime.html#FUNCTIONS-DATETIME-CURRENT" title="9.9.4. 当前日期/时间">第 9.9.4 节</a>）。注意这些是SQL函数并且在数据输入串中<span class="emphasis"><em>不</em></span>被识别。
     </p></div></div><div class="sect2" id="DATATYPE-DATETIME-OUTPUT"><div class="titlepage"><div><div><h3 class="title">8.5.2. 日期/时间输出</h3></div></div></div><a id="id-1.5.7.13.19.2" class="indexterm"></a><a id="id-1.5.7.13.19.3" class="indexterm"></a><p>
     时间/日期类型的输出格式可以设成四种风格之一： ISO 8601、<acronym class="acronym">SQL</acronym>（Ingres）、传统的<span class="productname">POSTGRES</span>（Unix的<span class="application">date</span>格式）或 German 。缺省是<acronym class="acronym">ISO</acronym>格式（<acronym class="acronym">ISO</acronym>标准要求使用 ISO 8601 格式。<acronym class="acronym">ISO</acronym>输出格式的名字是历史偶然）。<a class="xref" href="datatype-datetime.html#DATATYPE-DATETIME-OUTPUT-TABLE" title="表 8.14. 日期/时间输出风格">表 8.14</a>显示了每种输出风格的例子。<code class="type">date</code>和<code class="type">time</code>类型的 输出通常只有日期或时间部分和例子中一致。不过，<span class="productname">POSTGRES</span>风格输出的是<acronym class="acronym">ISO</acronym>格式的只有日期的值。
    </p><div class="table" id="DATATYPE-DATETIME-OUTPUT-TABLE"><p class="title"><strong>表 8.14. 日期/时间输出风格</strong></p><div class="table-contents"><table class="table" summary="日期/时间输出风格" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>风格声明</th><th>描述</th><th>例子</th></tr></thead><tbody><tr><td><code class="literal">ISO</code></td><td>ISO 8601, SQL标准</td><td><code class="literal">1997-12-17 07:37:16-08</code></td></tr><tr><td><code class="literal">SQL</code></td><td>传统风格</td><td><code class="literal">12/17/1997 07:37:16.00 PST</code></td></tr><tr><td><code class="literal">Postgres</code></td><td>原始风格</td><td><code class="literal">Wed Dec 17 07:37:16 1997 PST</code></td></tr><tr><td><code class="literal">German</code></td><td>地区风格</td><td><code class="literal">17.12.1997 07:37:16.00 PST</code></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注意</h3><p>
      ISO 8601指定使用大写字母<code class="literal">T</code>来分隔日期和时间。<span class="productname">PostgreSQL</span>在输入上接受这种格式，但是在输出时它采用一个空格而不是<code class="literal">T</code>，如上所示。和一些其他数据库系统一样，这是为了可读性以及与RFC 3339的一致性。
     </p></div><p>
     <acronym class="acronym">SQL</acronym>和POSTGRES风格中，如果DMY域顺序被指定，“日”将出现在“月”之前，否则“月”出现在“日”之前（有关该设置如何影响输入值的解释，请参考<a class="xref" href="datatype-datetime.html#DATATYPE-DATETIME-INPUT" title="8.5.1.  日期/时间输入">第 8.5.1 节</a>）。<a class="xref" href="datatype-datetime.html#DATATYPE-DATETIME-OUTPUT2-TABLE" title="表 8.15. 日期顺序习惯">表 8.15</a>给出了例子。
    </p><div class="table" id="DATATYPE-DATETIME-OUTPUT2-TABLE"><p class="title"><strong>表 8.15. 日期顺序习惯</strong></p><div class="table-contents"><table class="table" summary="日期顺序习惯" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th><code class="varname">datestyle</code>设置</th><th>输入顺序</th><th>例子输出</th></tr></thead><tbody><tr><td><code class="literal">SQL, DMY</code></td><td><em class="replaceable"><code>日</code></em>/<em class="replaceable"><code>月</code></em>/<em class="replaceable"><code>年</code></em></td><td><code class="literal">17/12/1997 15:37:16.00 CET</code></td></tr><tr><td><code class="literal">SQL, MDY</code></td><td><em class="replaceable"><code>月</code></em>/<em class="replaceable"><code>日</code></em>/<em class="replaceable"><code>年</code></em></td><td><code class="literal">12/17/1997 07:37:16.00 PST</code></td></tr><tr><td><code class="literal">Postgres, DMY</code></td><td><em class="replaceable"><code>日</code></em>/<em class="replaceable"><code>月</code></em>/<em class="replaceable"><code>年</code></em></td><td><code class="literal">Wed 17 Dec 07:37:16 1997 PST</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
     日期/时间风格可以由用户使用<code class="command">SET datestyle</code>命令选取，在<code class="filename">postgresql.conf</code>配置文件里的参数<a class="xref" href="runtime-config-client.html#GUC-DATESTYLE">DateStyle</a>设置或者在服务器或客户端的<code class="envar">PGDATESTYLE</code>环境变量里设置。
    </p><p>
     格式化函数<code class="function">to_char</code>（见<a class="xref" href="functions-formatting.html" title="9.8. 数据类型格式化函数">第 9.8 节</a>）也可以作为一个更灵活的方式来格式化日期/时间输出。
    </p></div><div class="sect2" id="DATATYPE-TIMEZONES"><div class="titlepage"><div><div><h3 class="title">8.5.3.  时区</h3></div></div></div><a id="id-1.5.7.13.20.2" class="indexterm"></a><p>
    时区和时区习惯不仅仅受地球几何形状的影响，还受到政治决定的影响。 到了19世纪，全球的时区变得稍微标准化了些，但是还是易于遭受随意的修改，部分是因为夏时制规
    则。<span class="productname">PostgreSQL</span>使用广泛使用的 IANA (Olson) 时区数据库来得到有关历史时区规则的信息。对于未来的时间，我们假设关于一个给定时区的最新已知
    规则将会一直持续到无穷远的未来。
   </p><p>
     <span class="productname">PostgreSQL</span>努力在典型使用中与<acronym class="acronym">SQL</acronym>标准的定义相兼容。但<acronym class="acronym">SQL</acronym>标准在日期和时间类型和功能上有一些奇怪的混淆。两个显而易见的问题是：

     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        尽管<code class="type">date</code>类型与时区没有联系，而<code class="type">time</code>类型却可以有。 然而，现实世界的时区只有在与时间和日期都关联时才有意义， 因为偏移（时差）可能因为实行类似夏时制这样的制度而在一年里有所变化。
       </p></li><li class="listitem"><p>
        缺省的时区会指定一个到<acronym class="acronym">UTC</acronym>的数字常量偏移（时差）。因此，当跨<acronym class="acronym">DST</acronym>边界做日期/时间算术时， 我们根本不可能适应于夏时制时间。
       </p></li></ul></div><p>
    </p><p>
     为了克服这些困难，我们建议在使用时区的时候，使用那些同时包含日期和时间的日期/时间类型。我们<span class="emphasis"><em>不</em></span>建议使用类型 <code class="type">time with time zone</code> （尽管<span class="productname">PostgreSQL</span>出于遗留应用以及与<acronym class="acronym">SQL</acronym>标准兼容性的考虑支持这个类型）。 <span class="productname">PostgreSQL</span>假设你用于任何类型的本地时区都只包含日期或时间。
    </p><p>
     在系统内部，所有时区相关的日期和时间都用<acronym class="acronym">UTC</acronym>存储。它们在被显示给客户端之前会被转换成由<a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a>配置参数指定的本地时间。
    </p><p>
     <span class="productname">PostgreSQL</span>允许你使用三种不同形式指定时区：
     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        一个完整的时区名字，例如<code class="literal">America/New_York</code>。能被识别的时区名字被列在<code class="literal">pg_timezone_names</code>视图中（参见<a class="xref" href="view-pg-timezone-names.html" title="51.92. pg_timezone_names">第 51.92 节</a>）。<span class="productname">PostgreSQL</span>用广泛使用的 IANA 时区数据来实现该目的，因此相同的时区名字也可以在其他软件中被识别。
       </p></li><li class="listitem"><p>
        一个时区缩写，例如<code class="literal">PST</code>。这样一种声明仅仅定义了到UTC的一个特定偏移，而不像完整时区名那样指出整套夏令时转换日期规则。能被识别的缩写被列在<code class="literal">pg_timezone_abbrevs</code>视图中（参见<a class="xref" href="view-pg-timezone-abbrevs.html" title="51.91. pg_timezone_abbrevs">第 51.91 节</a>）。你不能将配置参数<a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a>或<a class="xref" href="runtime-config-logging.html#GUC-LOG-TIMEZONE">log_timezone</a>设置成一个时区缩写，但是你可以在日期/时间输入值和<code class="literal">AT TIME ZONE</code>操作符中使用时区缩写。
       </p></li><li class="listitem"><p>
        除了时区名和缩写，<span class="productname">PostgreSQL</span>将接受POSIX-风格的
        时区声明，形式为<em class="replaceable"><code>STD</code></em><em class="replaceable"><code>offset</code></em>或
        <em class="replaceable"><code>STD</code></em><em class="replaceable"><code>offset</code></em><em class="replaceable"><code>DST</code></em>，
        其中<em class="replaceable"><code>STD</code></em>是一个区域缩写、<em class="replaceable"><code>offset</code></em>是从UTC西
        起的以小时计的数字偏移量、<em class="replaceable"><code>DST</code></em>是一个可选的夏令时区域缩
        写（被假定为给定偏移量提前一小时）。例如，如果<code class="literal">EST5EDT</code>还不是一
        个被识别的区域名，它可以被接受并且可能和美国东海岸时间的功效相同。在这种语法中，
        一个时区缩写可以是一个字母的字符串或者由尖括号（<code class="literal">&lt;&gt;</code>）包围
        的任意字符串。当一个夏令时区域缩写出现时，会假定根据 IANA 时区数据库的
        <code class="filename">posixrules</code>条目中使用的同一个夏令时转换规则使用它。
        在一个标准的<span class="productname">PostgreSQL</span>安装中，
        <code class="filename">posixrules</code>和<code class="literal">US/Eastern</code>相同，
        因此POSIX-风格的时区声明遵循美国的夏令时规则。如果需要，你可以通过替换
        <code class="filename">posixrules</code>文件来调整这种行为。
       </p></li></ul></div><p>

     简而言之，在缩写和全称之间是有不同的：缩写表示从UTC开始的一个特定偏移量，
     而很多全称表示一个本地夏令时规则并且因此具有两种可能的UTC偏移量。例如，
     <code class="literal">2014-06-04 12:00 America/New_York</code>表示纽约本地时间的中午，
     这个特殊的日期是东部夏令时间（UTC-4）。因此<code class="literal">2014-06-04 12:00 EDT</code>
     指定的是同一个时间点。但是<code class="literal">2014-06-04 12:00 EST</code>指定东部标准时间的
     中午（UTC-5），不管在那个日期夏令时是否生效。
    </p><p>
     更要命的是，某些行政区已经使用相同的时区缩写在不同的时间表示不同的 UTC 偏移量。例如，
     在莫斯科<code class="literal">MSK</code>在某些年份表示 UTC+3 而在另一些年份表示 UTC+4。 <span class="application">PostgreSQL</span> 会根据在指定的日期它们到底表示什么（或者最近表示什么）
     来解释这种缩写。但是，正如上面的<code class="literal">EST</code>例子所示，这并不是必须和那一天的本地
     标准时间相同。
    </p><p>
     你应该注意到POSIX-风格的时区特性可能导致伪造的输入被接受，因为它没有对区域缩写合理性的检查。例如<code class="literal">SET TIMEZONE TO FOOBAR0</code>将会正常工作，让系统实际使用一个相当奇怪的UTC缩写。另一个需要记住的问题是在POSIX时区名中，正值的偏移量被用于格林威治<span class="emphasis"><em>以西</em></span>的位置。在其他情况下，<span class="productname">PostgreSQL</span>将遵循 ISO-8601 惯例，认为正值的时区偏移量是格林威治<span class="emphasis"><em>以东</em></span>。
    </p><p>
     在所有情况下，时区名及其缩写都是大小写不敏感的（这是对<span class="productname">PostgreSQL</span> 8.2之前版本的一个修改，在这些版本中某些环境下时区名是大小写敏感的而在另外一些环境中却是大小写不敏感的）。
    </p><p>
     时区名和缩写都不是硬写在服务器中的，它们是从存储在安装目录下的<code class="filename">.../share/timezone/</code>和<code class="filename">.../share/timezonesets/</code>子目录中获取的（参见<a class="xref" href="datetime-config-files.html" title="B.4. 日期/时间配置文件">第 B.4 节</a>）。
    </p><p>
     <a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a>配置参数可以在文件<code class="filename">postgresql.conf</code>中被设置，或者使用<a class="xref" href="runtime-config.html" title="第 19 章 服务器配置">第 19 章</a>中描述的任何一种标准方法设置。同时也有一些特殊的方法来设置它：

     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <acronym class="acronym">SQL</acronym>命令<code class="command">SET TIME ZONE</code>为会话设置时区。它是<code class="command">SET TIMEZONE TO</code>的另一种拼写，它更加符合SQL的语法。
       </p></li><li class="listitem"><p>
        <span class="application">libpq</span>客户端使用<code class="envar">PGTZ</code>环境变量来通过连接发送一个<code class="command">SET TIME ZONE</code>命令给服务器。
       </p></li></ul></div><p>
    </p></div><div class="sect2" id="DATATYPE-INTERVAL-INPUT"><div class="titlepage"><div><div><h3 class="title">8.5.4. 间隔输入</h3></div></div></div><a id="id-1.5.7.13.21.2" class="indexterm"></a><p>
      <code class="type">interval</code>值可以使用下列语法书写：

</p><pre class="synopsis">
[<span class="optional">@</span>] <em class="replaceable"><code>quantity</code></em> <em class="replaceable"><code>unit</code></em> [<span class="optional"><em class="replaceable"><code>quantity</code></em> <em class="replaceable"><code>unit</code></em>...</span>] [<span class="optional"><em class="replaceable"><code>direction</code></em></span>]
</pre><p>

     其中<em class="replaceable"><code>quantity</code></em>是一个数字（很可能是有符号的）；
     <em class="replaceable"><code>unit</code></em>是<code class="literal">毫秒</code>、
     <code class="literal">millisecond</code>、<code class="literal">second</code>、
     <code class="literal">minute</code>、<code class="literal">hour</code>、<code class="literal">day</code>、
     <code class="literal">week</code>、<code class="literal">month</code>、<code class="literal">year</code>、
     <code class="literal">decade</code>、<code class="literal">century</code>、<code class="literal">millennium</code>
     或者缩写或者这些单位的复数；
     <em class="replaceable"><code>direction</code></em>可以是<code class="literal">ago</code>或者为空。At符号（<code class="literal">@</code>）是一个可选的噪声。不同单位的数量通过合适的符号计数被隐式地添加。<code class="literal">ago</code>对所有域求反。如果<a class="xref" href="runtime-config-client.html#GUC-INTERVALSTYLE">IntervalStyle</a>被设置为<code class="literal">postgres_verbose</code>，该语法也被用于间隔输出。
    </p><p>
     日、小时、分钟和秒的数量可以不适用显式的单位标记指定。例如，<code class="literal">'1 12:59:10'</code>被读作<code class="literal">'1 day 12 hours 59 min 10 sec'</code>。同样，一个年和月的组合可以使用一个横线指定，例如<code class="literal">'200-10'</code>被读作<code class="literal">'200年10个月'</code>（这些较短的形式事实上是<acronym class="acronym">SQL</acronym>标准唯一许可的形式，并且在<code class="varname">IntervalStyle</code>被设置为<code class="literal">sql_standard</code>时用于输出）。
    </p><p>
     间隔值也可以被写成 ISO 8601 时间间隔，使用该标准4.4.3.2小节的<span class="quote">“<span class="quote">带标志符的格式</span>”</span>或者4.4.3.3小节的<span class="quote">“<span class="quote">替代格式</span>”</span>。带标志符的格式看起来像这样：
</p><pre class="synopsis">
P <em class="replaceable"><code>quantity</code></em> <em class="replaceable"><code>unit</code></em> [<span class="optional"> <em class="replaceable"><code>quantity</code></em> <em class="replaceable"><code>unit</code></em> ...</span>] [<span class="optional"> T [<span class="optional"> <em class="replaceable"><code>quantity</code></em> <em class="replaceable"><code>unit</code></em> ...</span>]</span>]
</pre><p>
      该串必须以一个<code class="literal">P</code>开始，并且可以包括一个引入当日时间单位的<code class="literal">T</code>。可用的单位缩写在<a class="xref" href="datatype-datetime.html#DATATYPE-INTERVAL-ISO8601-UNITS" title="表 8.16. ISO 8601 间隔单位缩写">表 8.16</a>中给出。单位可以被忽略，并且可以以任何顺序指定，但是小于一天的单位必须出现在<code class="literal">T</code>之后。特别地，<code class="literal">M</code>的含义取决于它出现在<code class="literal">T</code>之前还是之后。
     </p><div class="table" id="DATATYPE-INTERVAL-ISO8601-UNITS"><p class="title"><strong>表 8.16. ISO 8601 间隔单位缩写</strong></p><div class="table-contents"><table class="table" summary="ISO 8601 间隔单位缩写" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>缩写</th><th>含义</th></tr></thead><tbody><tr><td>Y</td><td>年</td></tr><tr><td>M</td><td>月（在日期部分中）</td></tr><tr><td>W</td><td>周</td></tr><tr><td>D</td><td>日</td></tr><tr><td>H</td><td>小时</td></tr><tr><td>M</td><td>分钟 (在时间部分中）</td></tr><tr><td>S</td><td>秒</td></tr></tbody></table></div></div><br class="table-break" /><p>
      如果使用替代格式：
</p><pre class="synopsis">
P [<span class="optional"> <em class="replaceable"><code>years</code></em>-<em class="replaceable"><code>months</code></em>-<em class="replaceable"><code>days</code></em> </span>] [<span class="optional"> T <em class="replaceable"><code>hours</code></em>:<em class="replaceable"><code>minutes</code></em>:<em class="replaceable"><code>seconds</code></em> </span>]
</pre><p>
      串必须以<code class="literal">P</code>开始，并且一个<code class="literal">T</code>分隔间隔的日期和时间部分。其值按照类似于 ISO 8601日期的数字给出。
    </p><p>
     在用一个<em class="replaceable"><code>域</code></em>声明书写一个间隔常量时，或者为一个用<em class="replaceable"><code>域</code></em>声明定义的间隔列赋予一个串时，对于为标记的量的解释依赖于<em class="replaceable"><code>域</code></em>。例如<code class="literal">INTERVAL '1' YEAR</code>被解读成1年，而<code class="literal">INTERVAL '1'</code>表示1秒。同样，<em class="replaceable"><code>域</code></em>声明允许的最后一个有效域<span class="quote">“<span class="quote">右边</span>”</span>的域值会被无声地丢弃掉。例如书写<code class="literal">INTERVAL '1 day 2:03:04' HOUR TO MINUTE</code>将会导致丢弃秒域，而不是日域。
    </p><p>
     根据<acronym class="acronym">SQL</acronym>标准，一个间隔值的所有域都必须由相同的符号，这样一个领头的负号将会应用到所有域；例如在间隔文字<code class="literal">'-1 2:03:04'</code>中的负号会被应用于日、小时、分钟和秒部分。<span class="productname">PostgreSQL</span>允许域具有不同的符号，并且在习惯上认为以文本表示的每个域具有独立的符号，因此在这个例子中小时、分钟和秒部分被认为是正值。如果<code class="varname">IntervalStyle</code>被设置为<code class="literal">sql_standard</code>，则一个领头的符号将被认为是应用于所有域（但是仅当没有额外符号出现）。否则将使用传统的<span class="productname">PostgreSQL</span>解释。为了避免混淆，我们推荐在任何域为负值时为每一个域都附加一个显式的符号。
    </p><p>
     在冗长的输入格式中，以及在更紧凑输入格式的某些域中，域值可以有分数部分；例如<code class="literal">'1.5 week'</code>或<code class="literal">'01:02:03.45'</code>。这样的输入被转换为合适的月数、日数和秒数用于存储。当这样会导致月和日中的分数时，分数被加到低序域中，使用的转换因子是1月=30日和1日=24小时。例如，<code class="literal">'1.5 month'</code>会变成1月和15日。只有秒总是在输出时被显示为分数。
    </p><p>
     <a class="xref" href="datatype-datetime.html#DATATYPE-INTERVAL-INPUT-EXAMPLES" title="表 8.17. 间隔输入">表 8.17</a>展示了一些有效<code class="type">interval</code>输入的例子。
    </p><div class="table" id="DATATYPE-INTERVAL-INPUT-EXAMPLES"><p class="title"><strong>表 8.17. 间隔输入</strong></p><div class="table-contents"><table class="table" summary="间隔输入" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>例子</th><th>描述</th></tr></thead><tbody><tr><td>1-2</td><td>SQL标准格式：1年2个月</td></tr><tr><td>3 4:05:06</td><td>SQL标准格式：3日4小时5分钟6秒</td></tr><tr><td>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</td><td>传统Postgres格式：1年2个月3日4小时5分钟6秒钟</td></tr><tr><td>P1Y2M3DT4H5M6S</td><td><span class="quote">“<span class="quote">带标志符的</span>”</span>ISO 8601 格式：含义同上</td></tr><tr><td>P0001-02-03T04:05:06</td><td>ISO 8601 的<span class="quote">“<span class="quote">替代格式</span>”</span>：含义同上</td></tr></tbody></table></div></div><br class="table-break" /><p>
     在内部，<code class="type">interval</code>值被存储为months、days以及seconds。之所以这样做是因为一个月中的天数是变化的，并且在涉及到夏令时调整时一天可以有23或者25个小时。months以及days域是整数，而seconds域可以存储分数。因为区间通常是从常量字符串或者<code class="type">timestamp</code>减法创建而来，这种存储方法在大部分情况下都很好，但是也可能导致预料之外的结果：

</p><pre class="programlisting">
SELECT EXTRACT(hours from '80 minutes'::interval);
 date_part
-----------
         1

SELECT EXTRACT(days from '80 hours'::interval);
 date_part
-----------
         0
</pre><p>

     函数<code class="function">justify_days</code>和<code class="function">justify_hours</code>可以用来调整溢出其正常范围之外的days和hours。
    </p></div><div class="sect2" id="DATATYPE-INTERVAL-OUTPUT"><div class="titlepage"><div><div><h3 class="title">8.5.5. 间隔输出</h3></div></div></div><a id="id-1.5.7.13.22.2" class="indexterm"></a><p>
     间隔类型的输出格式可以被设置为四种风格之一：<code class="literal">sql_standard</code>、<code class="literal">postgres</code>、<code class="literal">postgres_verbose</code>或<code class="literal">iso_8601</code>，设置方法使用<code class="literal">SET intervalstyle</code>命令。默认值为<code class="literal">postgres</code>格式。<a class="xref" href="datatype-datetime.html#INTERVAL-STYLE-OUTPUT-TABLE" title="表 8.18. 间隔输出风格例子">表 8.18</a>展示了每种输出风格的例子。
    </p><p>
     如果间隔值符合SQL标准的限制（仅年-月或仅日-时间，没有正负值部分的混合），<code class="literal">sql_standard</code>风格为间隔文字串产生符合SQL标准规范的输出。否则输出将看起来像一个标准的年-月文字串跟着一个日-时间文字串，并且带有显式添加的符号以区分混合符号的间隔。
    </p><p>
     当<a class="xref" href="runtime-config-client.html#GUC-DATESTYLE">DateStyle</a>参数被设置为<code class="literal">ISO</code>时，<code class="literal">postgres</code>风格的输出匹配<span class="productname">PostgreSQL</span> 8.4版本以前的输出。
    </p><p>
     当<code class="varname">DateStyle</code>参数被设置为非<code class="literal">ISO</code>输出时，<code class="literal">postgres_verbose</code>风格的输出匹配<span class="productname">PostgreSQL</span> 8.4版本以前的输出。
    </p><p>
     <code class="literal">iso_8601</code>风格的输出匹配在ISO 8601标准的4.4.3.2小节中描述的<span class="quote">“<span class="quote">带标志符的格式</span>”</span>。
    </p><div class="table" id="INTERVAL-STYLE-OUTPUT-TABLE"><p class="title"><strong>表 8.18. 间隔输出风格例子</strong></p><div class="table-contents"><table class="table" summary="间隔输出风格例子" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>风格声明</th><th>年-月间隔</th><th>日-时间间隔</th><th>混合间隔</th></tr></thead><tbody><tr><td><code class="literal">sql_standard</code></td><td>1-2</td><td>3 4:05:06</td><td>-1-2 +3 -4:05:06</td></tr><tr><td><code class="literal">postgres</code></td><td>1 year 2 mons</td><td>3 days 04:05:06</td><td>-1 year -2 mons +3 days -04:05:06</td></tr><tr><td><code class="literal">postgres_verbose</code></td><td>@ 1 year 2 mons</td><td>@ 3 days 4 hours 5 mins 6 secs</td><td>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</td></tr><tr><td><code class="literal">iso_8601</code></td><td>P1Y2M</td><td>P3DT4H5M6S</td><td>P-1Y-2M3DT-4H-5M-6S</td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="datatype-binary.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="datatype-boolean.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">8.4. 二进制数据类型 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 8.6. 布尔类型</td></tr></table></div></body></html>