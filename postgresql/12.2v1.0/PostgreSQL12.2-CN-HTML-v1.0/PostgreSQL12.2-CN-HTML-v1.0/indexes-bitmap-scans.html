<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.5. 组合多个索引</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="indexes-ordering.html" title="11.4. 索引和ORDER BY" /><link rel="next" href="indexes-unique.html" title="11.6. 唯一索引" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.5. 组合多个索引</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-ordering.html" title="11.4. 索引和ORDER BY">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="第 11 章 索引">上一级</a></td><th width="60%" align="center">第 11 章 索引</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-unique.html" title="11.6. 唯一索引">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="INDEXES-BITMAP-SCANS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.5. 组合多个索引</h2></div></div></div><a id="id-1.5.10.8.2" class="indexterm"></a><a id="id-1.5.10.8.3" class="indexterm"></a><p>
   只有查询子句中在索引列上使用了索引操作符类中的操作符并且通过<code class="literal">AND</code>连接时才能使用单一索引。例如，给定一个<code class="literal">(a, b)</code> 上的索引，查询条件<code class="literal">WHERE a = 5 AND b = 6</code>可以使用该索引，而查询<code class="literal">WHERE a = 5 OR b = 6</code>不能直接使用该索引。
  </p><p>
   幸运的是，<span class="productname">PostgreSQL</span>具有组合多个索引（包括多次使用同一个索引）的能力来处理那些不 能用单个索引扫描实现的情况。系统能在多个索引扫描之间安排<code class="literal">AND</code>和<code class="literal">OR</code>条件。例如， <code class="literal">WHERE x = 42 OR x = 47 OR x = 53 OR x = 99</code>这样一个查询可以被分解成为四个独立的在<code class="literal">x</code>上索引扫描，每一个扫描使用其中一个条件。这些查询的结果将被“或”起来形成最后的结果。另一个例子是如果我们在<code class="literal">x</code>和<code class="literal">y</code>上都有独立的索引，<code class="literal">WHERE x = 5 AND y = 6</code>这样的查询的一种可能的实现方式就是分别使用两个索引配合相应的条件，然后将结果“与”起来得到最后的结果行。
  </p><p>
   为了组合多个索引，系统扫描每一个所需的索引并在内存中准备一个<em class="firstterm">位图</em>用于指示表中符合索引条件的行的位置。然后这些位图会被根据查询的需要“与”和“或”起来。最后，实际的表行将被访问并返回。表行将被以物理顺序访问，因为位图就是以这种顺序布局的。这意味着原始索引中的任何排序都会被丢失，并且如果存在一个<code class="literal">ORDER BY</code>子句就需要一个单独的排序步骤。由于这个原因以及每一个附加的索引都需要额外的时间，即使有额外的索引可用，规划器有时也会选择使用单一索引扫描。
  </p><p>
   在所有的应用（除了最简单的应用）中，可能会有多种有用的索引组合，数据库开发人员必须做出权衡以决定提供哪些索引。有时候多列索引最好，但是有时更好的选择是创建单独的索引并依赖于索引组合特性。例如，如果我们的查询中有时只涉及到列<code class="literal">x</code>，有时候只涉及到列<code class="literal">y</code>，还有时候会同时涉及到两列，我们可以选择在x和y上创建两个独立索引然后依赖索引组合来处理同时涉及到两列的查询。我们当然也可以创建一个<code class="literal">(x, y)</code>上的多列索引。当查询同时涉及到两列时，该索引会比组合索引效率更高，但是正如<a class="xref" href="indexes-multicolumn.html" title="11.3. 多列索引">第 11.3 节</a>中讨论的，它在只涉及到y的查询中几乎完全无用，因此它不能是唯一的一个索引。一个多列索引和一个<code class="literal">y</code>上的独立索引的组合将会工作得很好。多列索引可以用于那些只涉及到<code class="literal">x</code>的查询，尽管它比<code class="literal">x</code>上的独立索引更大且更慢。最后一种选择是创建所有三个索引，但是这种选择最适合表经常被执行所有三种查询但是很少被更新的情况。如果其中一种查询要明显少于其他类型的查询，我们可能需要只为常见类型的查询创建两个索引。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-ordering.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-unique.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">11.4. 索引和<code class="literal">ORDER BY</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 11.6. 唯一索引</td></tr></table></div></body></html>