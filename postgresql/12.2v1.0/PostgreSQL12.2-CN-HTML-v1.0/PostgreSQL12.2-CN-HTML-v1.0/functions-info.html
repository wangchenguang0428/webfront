<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.25. 系统信息函数和运算符</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="functions-srf.html" title="9.24. 集合返回函数" /><link rel="next" href="functions-admin.html" title="9.26. 系统管理函数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">9.25. 系统信息函数和运算符</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-srf.html" title="9.24. 集合返回函数">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="第 9 章 函数和操作符">上一级</a></td><th width="60%" align="center">第 9 章 函数和操作符</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="functions-admin.html" title="9.26. 系统管理函数">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="FUNCTIONS-INFO"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.25. 系统信息函数和运算符</h2></div></div></div><p>
   <a class="xref" href="functions-info.html#FUNCTIONS-INFO-SESSION-TABLE" title="表 9.63. 会话信息函数">表 9.63</a>展示了多个可以抽取会话和系统信息的函数。
  </p><p>
   除了本节列出的函数，还有一些与统计系统相关的函数也提供系统信息。详见<a class="xref" href="monitoring-stats.html#MONITORING-STATS-VIEWS" title="27.2.2. 查看统计信息">第 27.2.2 节</a>。
  </p><div class="table" id="FUNCTIONS-INFO-SESSION-TABLE"><p class="title"><strong>表 9.63. 会话信息函数</strong></p><div class="table-contents"><table class="table" summary="会话信息函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">current_catalog</code></code></td><td><code class="type">name</code></td><td>当前数据库名（SQL 标准中称作<span class="quote">“<span class="quote">目录</span>”</span>）</td></tr><tr><td><code class="literal"><code class="function">current_database()</code></code></td><td><code class="type">name</code></td><td>当前数据库名</td></tr><tr><td><code class="literal"><code class="function">current_query()</code></code></td><td><code class="type">text</code></td><td>当前正在执行的查询的文本，和客户端提交的一样（可能包含多于一个语句）</td></tr><tr><td><code class="literal"><code class="function">current_role</code></code></td><td><code class="type">name</code></td><td>等效于<code class="function">current_user</code></td></tr><tr><td><code class="literal"><code class="function">current_schema</code>[()]</code></td><td><code class="type">name</code></td><td>当前模式名</td></tr><tr><td><code class="literal"><code class="function">current_schemas(<code class="type">boolean</code>)</code></code></td><td><code class="type">name[]</code></td><td>搜索路径中的模式名，可以选择是否包含隐式模式</td></tr><tr><td><code class="literal"><code class="function">current_user</code></code></td><td><code class="type">name</code></td><td>当前执行上下文的用户名</td></tr><tr><td><code class="literal"><code class="function">inet_client_addr()</code></code></td><td><code class="type">inet</code></td><td>远程连接的地址</td></tr><tr><td><code class="literal"><code class="function">inet_client_port()</code></code></td><td><code class="type">int</code></td><td>远程连接的端口</td></tr><tr><td><code class="literal"><code class="function">inet_server_addr()</code></code></td><td><code class="type">inet</code></td><td>本地连接的地址</td></tr><tr><td><code class="literal"><code class="function">inet_server_port()</code></code></td><td><code class="type">int</code></td><td>本地连接的端口</td></tr><tr><td><code class="literal"><code class="function">pg_backend_pid()</code></code></td><td><code class="type">int</code></td><td>
        与当前会话关联的服务器进程的进程 ID
       </td></tr><tr><td><code class="literal"><code class="function">pg_blocking_pids(<code class="type">int</code>)</code></code></td><td><code class="type">int[]</code></td><td>阻塞指定服务器进程ID获得锁的进程 ID</td></tr><tr><td><code class="literal"><code class="function">pg_conf_load_time()</code></code></td><td><code class="type">timestamp with time zone</code></td><td>配置载入时间</td></tr><tr><td><code class="literal"><code class="function">pg_current_logfile([<span class="optional"><code class="type">text</code></span>])</code></code></td><td><code class="type">text</code></td><td>当前日志收集器在使用的主日志文件名或者所要求格式的日志的文件名</td></tr><tr><td><code class="literal"><code class="function">pg_my_temp_schema()</code></code></td><td><code class="type">oid</code></td><td>会话的临时模式的 OID，如果没有则为 0</td></tr><tr><td><code class="literal"><code class="function">pg_is_other_temp_schema(<code class="type">oid</code>)</code></code></td><td><code class="type">boolean</code></td><td>模式是另一个会话的临时模式吗？</td></tr><tr><td><code class="literal"><code class="function">pg_jit_available()</code></code></td><td><code class="type">boolean</code></td><td>这个会话中<acronym class="acronym">JIT</acronym>编译是否可用（见<a class="xref" href="jit.html" title="第 31 章 即时编译（JIT）">第 31 章</a>）？如果<a class="xref" href="runtime-config-query.html#GUC-JIT">jit</a>被设置为假，则返回<code class="literal">false</code>。</td></tr><tr><td><code class="literal"><code class="function">pg_listening_channels()</code></code></td><td><code class="type">setof text</code></td><td>会话当前正在监听的频道名称</td></tr><tr><td><code class="literal"><code class="function">pg_notification_queue_usage()</code></code></td><td><code class="type">double</code></td><td>异步通知队列当前被占用的分数（0-1）</td></tr><tr><td><code class="literal"><code class="function">pg_postmaster_start_time()</code></code></td><td><code class="type">timestamp with time zone</code></td><td>服务器启动时间</td></tr><tr><td><code class="literal"><code class="function">pg_safe_snapshot_blocking_pids(<code class="type">int</code>)</code></code></td><td><code class="type">int[]</code></td><td>阻止指定服务器进程ID获取安全快照的进程ID</td></tr><tr><td><code class="literal"><code class="function">pg_trigger_depth()</code></code></td><td><code class="type">int</code></td><td><span class="productname">PostgreSQL</span>触发器的当前嵌套层次（如果没有调用则为 0，直接或间接，从一个触发器内部开始）</td></tr><tr><td><code class="literal"><code class="function">session_user</code></code></td><td><code class="type">name</code></td><td>会话用户名</td></tr><tr><td><code class="literal"><code class="function">user</code></code></td><td><code class="type">name</code></td><td>等价于<code class="function">current_user</code></td></tr><tr><td><code class="literal"><code class="function">version()</code></code></td><td><code class="type">text</code></td><td><span class="productname">PostgreSQL</span>版本信息。机器可读的版本还可见<a class="xref" href="runtime-config-preset.html#GUC-SERVER-VERSION-NUM">server_version_num</a>。</td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注意</h3><p>
     <code class="function">current_catalog</code>、<code class="function">current_role</code>、<code class="function">current_schema</code>、<code class="function">current_user</code>、<code class="function">session_user</code>和<code class="function">user</code>在<acronym class="acronym">SQL</acronym>里有特殊的语意状态： 它们被调用时结尾不要跟着园括号（在 PostgreSQL 中，圆括号可以有选择性地被用于<code class="function">current_schema</code>，但是不能和其他的一起用）。
    </p></div><a id="id-1.5.8.30.6" class="indexterm"></a><a id="id-1.5.8.30.7" class="indexterm"></a><a id="id-1.5.8.30.8" class="indexterm"></a><a id="id-1.5.8.30.9" class="indexterm"></a><a id="id-1.5.8.30.10" class="indexterm"></a><a id="id-1.5.8.30.11" class="indexterm"></a><a id="id-1.5.8.30.12" class="indexterm"></a><a id="id-1.5.8.30.13" class="indexterm"></a><a id="id-1.5.8.30.14" class="indexterm"></a><a id="id-1.5.8.30.15" class="indexterm"></a><a id="id-1.5.8.30.16" class="indexterm"></a><a id="id-1.5.8.30.17" class="indexterm"></a><a id="id-1.5.8.30.18" class="indexterm"></a><p>
    <code class="function">session_user</code>通常是发起当前数据库连接的用户，不过超级用户可以用<a class="xref" href="sql-set-session-authorization.html" title="SET SESSION AUTHORIZATION"><span class="refentrytitle">SET SESSION AUTHORIZATION</span></a>修改这个设置。<code class="function">current_user</code>是用于权限检查的用户标识。通常， 它总是等于会话用户，但是可以被<a class="xref" href="sql-set-role.html" title="SET ROLE"><span class="refentrytitle">SET ROLE</span></a>改变。它也会在函数执行的过程中随着属性<code class="literal">SECURITY DEFINER</code>的改变而改变。在 Unix 的说法里，那么会话用户是<span class="quote">“<span class="quote">真实用户</span>”</span>，而当前用户是<span class="quote">“<span class="quote">有效用户</span>”</span>。<code class="function">current_role</code>以及<code class="function">user</code>是<code class="function">current_user</code>的同义词（SQL标准在<code class="function">current_role</code>和<code class="function">current_user</code>之间做了区分，但<span class="productname">PostgreSQL</span>不区分，因为它把用户和角色统一成了一种实体）。
   </p><p>
    <code class="function">current_schema</code>返回在搜索路径中的第一个模式名（如果搜索路径是空则返回空值）。 如果创建表或者其它命名对象时没有声明目标模式，那么它将是被用于这些对象的模式。<code class="function">current_schemas(boolean)</code>返回一个在搜索路径中出现的所有模式名的数组。布尔选项决定<code class="literal">pg_catalog</code>这样的隐式包含的系统模式是否包含在返回的搜索路径中。
   </p><div class="note"><h3 class="title">注意</h3><p>
     搜索路径可以在运行时修改。命令是：
</p><pre class="programlisting">
SET search_path TO <em class="replaceable"><code>schema</code></em> [<span class="optional">, <em class="replaceable"><code>schema</code></em>, ...</span>]
</pre><p>
    </p></div><a id="id-1.5.8.30.22" class="indexterm"></a><a id="id-1.5.8.30.23" class="indexterm"></a><a id="id-1.5.8.30.24" class="indexterm"></a><a id="id-1.5.8.30.25" class="indexterm"></a><p>
     <code class="function">inet_client_addr</code>返回当前客户端的 IP 地址，<code class="function">inet_client_port</code>返回它的端口号。 <code class="function">inet_server_addr</code>返回接受当前连接的服务器的 IP 地址，而<code class="function">inet_server_port</code>返回对应的端口号。如果连接是通过 Unix 域套接字进行的，那么所有这些函数都返回 NULL。
   </p><a id="id-1.5.8.30.27" class="indexterm"></a><p>
    <code class="function">pg_blocking_pids</code>返回一个进程 ID 的数组，数组中的进程中的会话阻塞了指定进程 ID 所代表的服务器进程，如果指定的服务器进程不存在或者没有被阻塞则返回空数组。如果一个进程持有与另一个进程加锁请求冲突的锁（硬锁），或者前者正在等待一个与后者加锁请求冲突的锁并且前者在该锁的等待队列中位于后者的前面（软锁），则前者会阻塞后者。在使用并行查询时，这个函数的结果总是会列出客户端可见的进程 ID（即<code class="function">pg_backend_pid</code>的结果），即便实际的锁是由工作者进程所持有或者等待也是如此。这样造成的后果是，结果中可能会有很多重复的 PID。还要注意当一个预备事务持有一个冲突锁时，这个函数的结果中它将被表示为一个为零的进程 ID。对这个函数的频繁调用可能对数据库性能有一些影响，因为它需要短时间地独占访问锁管理器的共享状态。
   </p><a id="id-1.5.8.30.29" class="indexterm"></a><p>
    <code class="function">pg_conf_load_time</code>返回服务器配置文件最近被载入的<code class="type">timestamp with time zone</code>（如果当前会话在那时就已经存在，这个值将是该会话自己重新读取配置文件的时间，因此在不同的会话中这个读数会有一点变化。如果不是这样，这个值就是 postmaster 进程重读配置文件的时间）。
   </p><a id="id-1.5.8.30.31" class="indexterm"></a><a id="id-1.5.8.30.32" class="indexterm"></a><a id="id-1.5.8.30.33" class="indexterm"></a><a id="id-1.5.8.30.34" class="indexterm"></a><p>
    <code class="function">pg_current_logfile</code>以<code class="type">text</code>类型返回当前被日志收集器使用的日志文件的路径。该路径包括<a class="xref" href="runtime-config-logging.html#GUC-LOG-DIRECTORY">log_directory</a>目录和日志文件名。日志收集必须被启用，否则返回值为<code class="literal">NULL</code>。当多个日志文件存在并且每一个都有不同的格式时，不带参数调用<code class="function">pg_current_logfile</code>会返回这样的文件的路径：在所有的文件中，没有任何文件的格式在列表<span class="systemitem">stderr</span>、<span class="systemitem">csvlog</span>中排在这个文件的格式前面。如果没有任何日志文件有上述格式，则返回<code class="literal">NULL</code>。要请求一种特定的文件格式，可以以<code class="type">text</code>将<span class="systemitem">csvlog</span>或者<span class="systemitem">stderr</span>作为可选参数的值。当所请求的日志格式不是已配置的<a class="xref" href="runtime-config-logging.html#GUC-LOG-DESTINATION">log_destination</a>时，会返回<code class="literal">NULL</code>。<code class="function">pg_current_logfile</code>反映了<code class="filename">current_logfiles</code>文件的内容。
   </p><a id="id-1.5.8.30.36" class="indexterm"></a><a id="id-1.5.8.30.37" class="indexterm"></a><p>
    <code class="function">pg_my_temp_schema</code>返回当前会话临时模式的 OID，如果没有使用临时模式（因为它没有创建任何临时表）则返回零。如果给定的 OID 是另一个会话的临时模式的 OID，则<code class="function">pg_is_other_temp_schema</code>返回真（这是有用的，例如，要将其他会话的临时表从一个目录显示中排除）。
   </p><a id="id-1.5.8.30.39" class="indexterm"></a><a id="id-1.5.8.30.40" class="indexterm"></a><p>
    <code class="function">pg_listening_channels</code>返回当前会话正在监听的异步通知频道的名称的集合。<code class="function">pg_notification_queue_usage</code>返回等待处理的通知占可用的通知空间的比例，它是一个 0-1 范围内的<code class="type">double</code>值。详见<a class="xref" href="sql-listen.html" title="LISTEN"><span class="refentrytitle">LISTEN</span></a>和<a class="xref" href="sql-notify.html" title="NOTIFY"><span class="refentrytitle">NOTIFY</span></a>。
   </p><a id="id-1.5.8.30.42" class="indexterm"></a><p>
    <code class="function">pg_postmaster_start_time</code>返回服务器启动的<code class="type">timestamp with time zone</code>。
   </p><a id="id-1.5.8.30.44" class="indexterm"></a><p>
    <code class="function">pg_safe_snapshot_blocking_pids</code>一个进程ID的数组，它们代表阻止指定进程ID对应的服务器进程获取安全快照的会话，如果没有这类服务器进程或者它没有被阻塞，则会返回一个空数组。一个运行着<code class="literal">SERIALIZABLE</code>事务的会话会阻止<code class="literal">SERIALIZABLE READ ONLY DEFERRABLE</code>事务获取快照，直到后者确定避免拿到任何谓词锁是安全的。更多有关可序列化以及可延迟事务的信息请参考<a class="xref" href="transaction-iso.html#XACT-SERIALIZABLE" title="13.2.3. 可序列化隔离级别">第 13.2.3 节</a>。频繁调用这个函数可能会对数据库性能产生一些影响，因为它需要短时间访问谓词锁管理器的共享状态。
   </p><a id="id-1.5.8.30.46" class="indexterm"></a><p>
    <code class="function">version</code>返回一个描述<span class="productname">PostgreSQL</span>服务器版本的字符串。你也可以从<a class="xref" href="runtime-config-preset.html#GUC-SERVER-VERSION">server_version</a>或者一个机器可读的版本<a class="xref" href="runtime-config-preset.html#GUC-SERVER-VERSION-NUM">server_version_num</a>得到这个信息。软件开发者应该使用<code class="literal">server_version_num</code>（从 8.2 开始可用）或者<a class="xref" href="libpq-status.html#LIBPQ-PQSERVERVERSION">
      <code class="function">PQserverVersion</code>
      
     </a>，而不必解析文本形式的版本。
   </p><a id="id-1.5.8.30.48" class="indexterm"></a><p>
   <a class="xref" href="functions-info.html#FUNCTIONS-INFO-ACCESS-TABLE" title="表 9.64. 访问权限查询函数">表 9.64</a>列出那些允许用户编程查询对象访问权限的函数。参阅<a class="xref" href="ddl-priv.html" title="5.7. 权限">第 5.7 节</a>获取更多有关权限的信息。
  </p><div class="table" id="FUNCTIONS-INFO-ACCESS-TABLE"><p class="title"><strong>表 9.64. 访问权限查询函数</strong></p><div class="table-contents"><table class="table" summary="访问权限查询函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">has_any_column_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>table</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有表中任意列上的权限</td></tr><tr><td><code class="literal"><code class="function">has_any_column_privilege</code>(<em class="parameter"><code>table</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有表中任意列上的权限</td></tr><tr><td><code class="literal"><code class="function">has_column_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>table</code></em>,
                                  <em class="parameter"><code>column</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有列的权限</td></tr><tr><td><code class="literal"><code class="function">has_column_privilege</code>(<em class="parameter"><code>table</code></em>,
                                  <em class="parameter"><code>column</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有列的权限</td></tr><tr><td><code class="literal"><code class="function">has_database_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>database</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有数据库的权限</td></tr><tr><td><code class="literal"><code class="function">has_database_privilege</code>(<em class="parameter"><code>database</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有数据库的权限</td></tr><tr><td><code class="literal"><code class="function">has_foreign_data_wrapper_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>fdw</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有外部数据包装器上的权限</td></tr><tr><td><code class="literal"><code class="function">has_foreign_data_wrapper_privilege</code>(<em class="parameter"><code>fdw</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有外部数据包装器上的权限</td></tr><tr><td><code class="literal"><code class="function">has_function_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>function</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有函数上的权限</td></tr><tr><td><code class="literal"><code class="function">has_function_privilege</code>(<em class="parameter"><code>function</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有函数上的权限</td></tr><tr><td><code class="literal"><code class="function">has_language_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>language</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有语言上的权限</td></tr><tr><td><code class="literal"><code class="function">has_language_privilege</code>(<em class="parameter"><code>language</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有语言上的权限</td></tr><tr><td><code class="literal"><code class="function">has_schema_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>schema</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有模式上的权限</td></tr><tr><td><code class="literal"><code class="function">has_schema_privilege</code>(<em class="parameter"><code>schema</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有模式上的权限</td></tr><tr><td><code class="literal"><code class="function">has_sequence_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>sequence</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有序列上的权限</td></tr><tr><td><code class="literal"><code class="function">has_sequence_privilege</code>(<em class="parameter"><code>sequence</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有序列上的权限</td></tr><tr><td><code class="literal"><code class="function">has_server_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>server</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有外部服务器上的权限</td></tr><tr><td><code class="literal"><code class="function">has_server_privilege</code>(<em class="parameter"><code>server</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有外部服务器上的权限</td></tr><tr><td><code class="literal"><code class="function">has_table_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>table</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有表上的权限</td></tr><tr><td><code class="literal"><code class="function">has_table_privilege</code>(<em class="parameter"><code>table</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有表上的权限</td></tr><tr><td><code class="literal"><code class="function">has_tablespace_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>tablespace</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有表空间上的权限</td></tr><tr><td><code class="literal"><code class="function">has_tablespace_privilege</code>(<em class="parameter"><code>tablespace</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有表空间上的权限</td></tr><tr><td><code class="literal"><code class="function">has_type_privilege</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>type</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有类型的特权</td></tr><tr><td><code class="literal"><code class="function">has_type_privilege</code>(<em class="parameter"><code>type</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有类型的特权</td></tr><tr><td><code class="literal"><code class="function">pg_has_role</code>(<em class="parameter"><code>user</code></em>,
                                  <em class="parameter"><code>role</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>用户有没有角色上的权限</td></tr><tr><td><code class="literal"><code class="function">pg_has_role</code>(<em class="parameter"><code>role</code></em>,
                                  <em class="parameter"><code>privilege</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户有没有角色上的权限</td></tr><tr><td><code class="literal"><code class="function">row_security_active</code>(<em class="parameter"><code>table</code></em>)</code>
       </td><td><code class="type">boolean</code></td><td>当前用户是否在表上开启了行级安全性</td></tr></tbody></table></div></div><br class="table-break" /><a id="id-1.5.8.30.51" class="indexterm"></a><a id="id-1.5.8.30.52" class="indexterm"></a><a id="id-1.5.8.30.53" class="indexterm"></a><a id="id-1.5.8.30.54" class="indexterm"></a><a id="id-1.5.8.30.55" class="indexterm"></a><a id="id-1.5.8.30.56" class="indexterm"></a><a id="id-1.5.8.30.57" class="indexterm"></a><a id="id-1.5.8.30.58" class="indexterm"></a><a id="id-1.5.8.30.59" class="indexterm"></a><a id="id-1.5.8.30.60" class="indexterm"></a><a id="id-1.5.8.30.61" class="indexterm"></a><a id="id-1.5.8.30.62" class="indexterm"></a><a id="id-1.5.8.30.63" class="indexterm"></a><a id="id-1.5.8.30.64" class="indexterm"></a><p>
    <code class="function">has_table_privilege</code>判断一个用户是否可以用某种特定的方式访问一个表。 该用户可以通过名字或者 OID （<code class="literal">pg_authid.oid</code>） 来指定，也可以用<code class="literal">public</code>表示 PUBLIC 伪角色。如果省略该参数，则使用<code class="function">current_user</code>。 该表可以通过名字或者 OID 指定（因此，实际上有六种 <code class="function">has_table_privilege</code>的变体，我们可以通过它们的参数数目和类型来区分它们） 。如果用名字指定，那么在必要时该名字可以是模式限定的。 所希望的权限类型是用一个文本串来指定的，它必须是下面的几个值之一： <code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>、<code class="literal">DELETE</code>、<code class="literal">TRUNCATE</code>、<code class="literal">REFERENCES</code>或<code class="literal">TRIGGER</code>。<code class="literal">WITH GRANT OPTION</code>可以被选择增加到一个权限类型来测试是否该权限是使用转授选项得到。另外，可以使用逗号分隔来列出多个权限类型，在这种情况下只要具有其中之一的权限则结果为<code class="literal">真</code>（权限字符串的大小写并不重要，可以在权限名称之间出现额外的空白，但是在权限名内部不能有空白）。一些例子：
</p><pre class="programlisting">
SELECT has_table_privilege('myschema.mytable', 'select');
SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');
</pre><p>
   </p><p>
    <code class="function">has_sequence_privilege</code>检查一个用户是否能以某种特定方式访问一个序列。它的参数可能性和<code class="function">has_table_privilege</code>相似。所希望测试的访问权限类型必须是下列之一：<code class="literal">USAGE</code>、<code class="literal">SELECT</code>或<code class="literal">UPDATE</code>。
   </p><p>
    <code class="function">has_any_column_privilege</code>检查一个用户是否能以特定方式访问一个表的任意列。其参数可能性和<code class="function">has_table_privilege</code>类似，除了所希望的访问权限类型必须是下面值的某种组合：<code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>或<code class="literal">REFERENCES</code>。注意在表层面上具有这些权限的任意一个都会隐式地把它授权给表中的每一列，因此如果<code class="function">has_table_privilege</code>对同样的参数返回真则<code class="function">has_any_column_privilege</code>将总是返回<code class="literal">真</code>。但是如果在至少一列上有一个该权限的列级授权，<code class="function">has_any_column_privilege</code>也会成功。
   </p><p>
    <code class="function">has_column_privilege</code>检查一个用户是否能以特定方式访问一个列。它的参数可能性与<code class="function">has_table_privilege</code>类似，并且列还可以使用名字或者属性号来指定。希望的访问权限类型必须是下列值的某种组合：<code class="literal">SELECT</code>、<code class="literal">INSERT</code>、<code class="literal">UPDATE</code>或<code class="literal">REFERENCES</code>。注意在表级别上具有这些权限中的任意一种将会隐式地把它授予给表上的每一列。
   </p><p>
    <code class="function">has_database_privilege</code>检查一个用户是否能以特定方式访问一个数据库。它的参数可能性类似 <code class="function">has_table_privilege</code>。希望的访问权限类型必须是以下值的某种组合：<code class="literal">CREATE</code>、<code class="literal">CONNECT</code>、<code class="literal">TEMPORARY</code>或<code class="literal">TEMP</code>（等价于<code class="literal">TEMPORARY</code>）。
   </p><p>
    <code class="function">has_function_privilege</code>检查一个用户是否能以特定方式访问一个函数。其参数可能性类似<code class="function">has_table_privilege</code>。在用一个文本串而不是 OID 指定一个函数时，允许的输入和<code class="type">regprocedure</code>数据类型一样（参阅 <a class="xref" href="datatype-oid.html" title="8.19. 对象标识符类型">第 8.19 节</a>）。希望的访问权限类型必须是<code class="literal">EXECUTE</code>。一个例子：
</p><pre class="programlisting">
SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');
</pre><p>
   </p><p>
    <code class="function">has_foreign_data_wrapper_privilege</code>检查一个用户是否能以特定方式访问一个外部数据包装器。它的参数可能性类似于<code class="function">has_table_privilege</code>。希望的访问权限类型必须是<code class="literal">USAGE</code>。
   </p><p>
    <code class="function">has_language_privilege</code>检查一个用户是否可以以某种特定的方式访问一个过程语言。 其参数可能性类似 <code class="function">has_table_privilege</code>。希望的访问权限类型必须是<code class="literal">USAGE</code>。
   </p><p>
    <code class="function">has_schema_privilege</code>检查一个用户是否可以以某种特定的方式访问一个模式。 其参数可能性类似 <code class="function">has_table_privilege</code>。希望的访问权限类型必须是<code class="literal">CREATE</code>或<code class="literal">USAGE</code>。
   </p><p>
    <code class="function">has_server_privilege</code>检查一个用户是否可以以某种特定的方式访问一个外部服务器。 其参数可能性类似 <code class="function">has_table_privilege</code>。希望的访问权限类型必须是<code class="literal">USAGE</code>。
   </p><p>
    <code class="function">has_tablespace_privilege</code>检查一个用户是否可以以某种特定的方式访问一个表空间。其参数可能性类似 <code class="function">has_table_privilege</code>。希望的访问权限类型必须是<code class="literal">CREATE</code>。
   </p><p>
    <code class="function">has_type_privilege</code>检查一个用户是否能以特定的方式访问一种类型。其参数的可能性类同于<code class="function">has_table_privilege</code>。在用字符串而不是 OID 指定类型时，允许的输入和<code class="type">regtype</code>数据类型相同（见<a class="xref" href="datatype-oid.html" title="8.19. 对象标识符类型">第 8.19 节</a>）。期望的访问特权类型必须等于<code class="literal">USAGE</code>。
   </p><p>
    <code class="function">pg_has_role</code>检查一个用户是否可以以某种特定的方式访问一个角色。其参数可能性类似 <code class="function">has_table_privilege</code>，除了<code class="literal">public</code>不能被允许作为一个用户名。希望的访问权限类型必须是下列值的某种组合：<code class="literal">MEMBER</code>或<code class="literal">USAGE</code>。<code class="literal">MEMBER</code>表示该角色中的直接或间接成员关系（即使用<code class="command">SET ROLE</code>的权力），而<code class="literal">USAGE</code>表示不做<code class="command">SET ROLE</code>的情况下该角色的权限是否立即可用。
   </p><p>
    <code class="function">row_security_active</code>检查在
    <code class="function">current_user</code>的上下文和环境中是否为指定的
    表激活了行级安全性。表可以用名称或者 OID 指定。
   </p><p>
   <a class="xref" href="functions-info.html#FUNCTIONS-ACLITEM-FN-TABLE" title="表 9.66. aclitem Functions">表 9.66</a> 显示了<code class="type">aclitem</code>类型的可用操作符，它是访问权限的目录表示。 有关如何读取访问权限值的信息，请参阅 <a class="xref" href="ddl-priv.html" title="5.7. 权限">第 5.7 节</a>。
  </p><a id="id-1.5.8.30.80" class="indexterm"></a><a id="id-1.5.8.30.81" class="indexterm"></a><a id="id-1.5.8.30.82" class="indexterm"></a><a id="id-1.5.8.30.83" class="indexterm"></a><a id="id-1.5.8.30.84" class="indexterm"></a><div class="table" id="FUNCTIONS-ACLITEM-OP-TABLE"><p class="title"><strong>表 9.65. <code class="type">aclitem</code> Operators</strong></p><div class="table-contents"><table class="table" summary="aclitem Operators" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>操作符</th><th>描述</th><th>例子</th><th>结果</th></tr></thead><tbody><tr><td> <code class="literal">=</code> </td><td>equal</td><td><code class="literal">'calvin=r*w/hobbes'::aclitem = 'calvin=r*w*/hobbes'::aclitem</code></td><td><code class="literal">f</code></td></tr><tr><td> <code class="literal">@&gt;</code> </td><td>包含元素</td><td><code class="literal">'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] @&gt; 'calvin=r*w/hobbes'::aclitem</code></td><td><code class="literal">t</code></td></tr><tr><td> <code class="literal">~</code> </td><td>包含元素</td><td><code class="literal">'{calvin=r*w/hobbes,hobbes=r*w*/postgres}'::aclitem[] ~ 'calvin=r*w/hobbes'::aclitem</code></td><td><code class="literal">t</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
    <a class="xref" href="functions-info.html#FUNCTIONS-ACLITEM-FN-TABLE" title="表 9.66. aclitem Functions">表 9.66</a> 显示了一些额外的函数来管理<code class="type">aclitem</code>类型。
   </p><div class="table" id="FUNCTIONS-ACLITEM-FN-TABLE"><p class="title"><strong>表 9.66. <code class="type">aclitem</code> Functions</strong></p><div class="table-contents"><table class="table" summary="aclitem Functions" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">acldefault</code>(<em class="parameter"><code>type</code></em>,
        <em class="parameter"><code>ownerId</code></em>)</code></td><td><code class="type">aclitem[]</code></td><td>获取属于<em class="parameter"><code>ownerId</code></em>的对象的默认访问权限。</td></tr><tr><td><code class="literal"><code class="function">aclexplode</code>(<em class="parameter"><code>aclitem[]</code></em>)</code></td><td><code class="type">setof record</code></td><td>获取 <code class="type">aclitem</code> 数组为元组</td></tr><tr><td><code class="literal"><code class="function">makeaclitem</code>(<em class="parameter"><code>grantee</code></em>, <em class="parameter"><code>grantor</code></em>, <em class="parameter"><code>privilege</code></em>, <em class="parameter"><code>grantable</code></em>)</code></td><td><code class="type">aclitem</code></td><td>从输入中建立一个<code class="type">aclitem</code>。</td></tr></tbody></table></div></div><br class="table-break" /><p>
    <code class="function">acldefault</code>返回属于角色<em class="parameter"><code>ownerId</code></em>的<em class="parameter"><code>type</code></em>类型的对象的内置默认访问权限。 这些代表了当对象的ACL条目为空时将被假定的访问权限。 (默认的访问权限在<a class="xref" href="ddl-priv.html" title="5.7. 权限">第 5.7 节</a>中描述了)。
     <em class="parameter"><code>type</code></em> 参数是一个 <code class="type">CHAR</code>: 
    'c' for <code class="literal">COLUMN</code>,
    'r' for <code class="literal">TABLE</code> 和类表对象,
    's' for <code class="literal">SEQUENCE</code>,
    'd' for <code class="literal">DATABASE</code>,
    'f' for <code class="literal">FUNCTION</code> 或者 <code class="literal">PROCEDURE</code>,
    'l' for <code class="literal">LANGUAGE</code>,
    'L' for <code class="literal">LARGE OBJECT</code>,
    'n' for <code class="literal">SCHEMA</code>,
    't' for <code class="literal">TABLESPACE</code>,
    'F' for <code class="literal">FOREIGN DATA WRAPPER</code>,
    'S' for <code class="literal">FOREIGN SERVER</code>,
    'T' for <code class="literal">TYPE</code> 或者 <code class="literal">DOMAIN</code>.
   </p><p>
    <code class="function">aclexplode</code>返回一个<code class="type">aclitem</code>数组作为行集。输出的列是grantor <code class="type">oid</code>, grantee <code class="type">oid</code> (<code class="literal">0</code> for <code class="literal">PUBLIC</code>), 被授权为 <code class="type">text</code> (<code class="literal">SELECT</code>, ...)
    以及权限是否可以被授予<code class="type">boolean</code>。<code class="function">makeaclitem</code>执行反向操作。
   </p><p>
   <a class="xref" href="functions-info.html#FUNCTIONS-INFO-SCHEMA-TABLE" title="表 9.67. 模式可见性查询函数">表 9.67</a>展示了决定是否一个特定对象在当前模式搜索路径中<em class="firstterm">可见</em>的函数。例如，如果一个表所在的模式在当前搜索路径中并且在它之前没有出现过相同的名字，这个表就被说是可见的。这等价于在语句中表可以被用名称引用但不加显式的模式限定。要列出所有可见表的名字：
</p><pre class="programlisting">
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</pre><p>
  </p><a id="id-1.5.8.30.91" class="indexterm"></a><div class="table" id="FUNCTIONS-INFO-SCHEMA-TABLE"><p class="title"><strong>表 9.67. 模式可见性查询函数</strong></p><div class="table-contents"><table class="table" summary="模式可见性查询函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">pg_collation_is_visible(<em class="parameter"><code>collation_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>排序规则在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_conversion_is_visible(<em class="parameter"><code>conversion_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>转换在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_function_is_visible(<em class="parameter"><code>function_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>函数在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_opclass_is_visible(<em class="parameter"><code>opclass_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>操作符类在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_operator_is_visible(<em class="parameter"><code>operator_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>操作符在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_opfamily_is_visible(<em class="parameter"><code>opclass_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>操作符族在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_statistics_obj_is_visible(<em class="parameter"><code>stat_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>是搜索路径中的统计信息对象</td></tr><tr><td><code class="literal"><code class="function">pg_table_is_visible(<em class="parameter"><code>table_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>表在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_ts_config_is_visible(<em class="parameter"><code>config_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>文本搜索配置在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_ts_dict_is_visible(<em class="parameter"><code>dict_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>文本搜索字典在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_ts_parser_is_visible(<em class="parameter"><code>parser_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>文本搜索解析器在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_ts_template_is_visible(<em class="parameter"><code>template_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>文本搜索模板在搜索路径中可见吗？</td></tr><tr><td><code class="literal"><code class="function">pg_type_is_visible(<em class="parameter"><code>type_oid</code></em>)</code></code>
       </td><td><code class="type">boolean</code></td><td>类型（或域）在搜索路径中可见吗？</td></tr></tbody></table></div></div><br class="table-break" /><a id="id-1.5.8.30.93" class="indexterm"></a><a id="id-1.5.8.30.94" class="indexterm"></a><a id="id-1.5.8.30.95" class="indexterm"></a><a id="id-1.5.8.30.96" class="indexterm"></a><a id="id-1.5.8.30.97" class="indexterm"></a><a id="id-1.5.8.30.98" class="indexterm"></a><a id="id-1.5.8.30.99" class="indexterm"></a><a id="id-1.5.8.30.100" class="indexterm"></a><a id="id-1.5.8.30.101" class="indexterm"></a><a id="id-1.5.8.30.102" class="indexterm"></a><a id="id-1.5.8.30.103" class="indexterm"></a><a id="id-1.5.8.30.104" class="indexterm"></a><a id="id-1.5.8.30.105" class="indexterm"></a><p>
    每一个函数对一种数据库对象执行可见性检查。注意<code class="function">pg_table_is_visible</code>也可被用于视图、物化视图、索引、序列和外部表，<code class="function">pg_function_is_visible</code>也能被用于过程和聚集，<code class="function">pg_type_is_visible</code>也可以被用于域。对于函数和操作符，如果在路径中更早的地方没有出现具有相同名称<span class="emphasis"><em>和参数数据类型</em></span>的对象，该对象在搜索路径中是可见的。对于操作符类，名称和相关的索引访问方法都要考虑。
   </p><p>
    所有这些函数都要求用对象 OID 来标识将被检查的对象。如果你想用名称来测试一个对象，使用 OID 别名类型（<code class="type">regclass</code>、<code class="type">regtype</code>、<code class="type">regprocedure</code>、<code class="type">regoperator</code>、<code class="type">regconfig</code>或<code class="type">regdictionary</code>）将会很方便。例如：
</p><pre class="programlisting">
SELECT pg_type_is_visible('myschema.widget'::regtype);
</pre><p>
    注意以这种方式测试一个非模式限定的类型名没什么意义 — 如果该名称完全能被识别，它必须是可见的。
   </p><a id="id-1.5.8.30.108" class="indexterm"></a><a id="id-1.5.8.30.109" class="indexterm"></a><a id="id-1.5.8.30.110" class="indexterm"></a><a id="id-1.5.8.30.111" class="indexterm"></a><a id="id-1.5.8.30.112" class="indexterm"></a><a id="id-1.5.8.30.113" class="indexterm"></a><a id="id-1.5.8.30.114" class="indexterm"></a><a id="id-1.5.8.30.115" class="indexterm"></a><a id="id-1.5.8.30.116" class="indexterm"></a><a id="id-1.5.8.30.117" class="indexterm"></a><a id="id-1.5.8.30.118" class="indexterm"></a><a id="id-1.5.8.30.119" class="indexterm"></a><a id="id-1.5.8.30.120" class="indexterm"></a><a id="id-1.5.8.30.121" class="indexterm"></a><a id="id-1.5.8.30.122" class="indexterm"></a><a id="id-1.5.8.30.123" class="indexterm"></a><a id="id-1.5.8.30.124" class="indexterm"></a><a id="id-1.5.8.30.125" class="indexterm"></a><a id="id-1.5.8.30.126" class="indexterm"></a><a id="id-1.5.8.30.127" class="indexterm"></a><a id="id-1.5.8.30.128" class="indexterm"></a><a id="id-1.5.8.30.129" class="indexterm"></a><a id="id-1.5.8.30.130" class="indexterm"></a><a id="id-1.5.8.30.131" class="indexterm"></a><a id="id-1.5.8.30.132" class="indexterm"></a><a id="id-1.5.8.30.133" class="indexterm"></a><a id="id-1.5.8.30.134" class="indexterm"></a><a id="id-1.5.8.30.135" class="indexterm"></a><a id="id-1.5.8.30.136" class="indexterm"></a><a id="id-1.5.8.30.137" class="indexterm"></a><a id="id-1.5.8.30.138" class="indexterm"></a><p>
   <a class="xref" href="functions-info.html#FUNCTIONS-INFO-CATALOG-TABLE" title="表 9.68. 系统目录信息函数">表 9.68</a>列出了从系统目录抽取信息的函数。
  </p><div class="table" id="FUNCTIONS-INFO-CATALOG-TABLE"><p class="title"><strong>表 9.68. 系统目录信息函数</strong></p><div class="table-contents"><table class="table" summary="系统目录信息函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">format_type(<em class="parameter"><code>type_oid</code></em>, <em class="parameter"><code>typemod</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得一个数据类型的 SQL 名字</td></tr><tr><td><code class="literal"><code class="function">pg_get_constraintdef(<em class="parameter"><code>constraint_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得一个约束的定义</td></tr><tr><td><code class="literal"><code class="function">pg_get_constraintdef(<em class="parameter"><code>constraint_oid</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得一个约束的定义</td></tr><tr><td><code class="literal"><code class="function">pg_get_expr(<em class="parameter"><code>pg_node_tree</code></em>, <em class="parameter"><code>relation_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>反编译一个表达式的内部形式，假定其中的任何 Var 指向由第二个参数指示的关系</td></tr><tr><td><code class="literal"><code class="function">pg_get_expr(<em class="parameter"><code>pg_node_tree</code></em>, <em class="parameter"><code>relation_oid</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</code></code></td><td><code class="type">text</code></td><td>反编译一个表达式的内部形式，假定其中的任何 Var 指向由第二个参数指示的关系</td></tr><tr><td><code class="literal"><code class="function">pg_get_functiondef(<em class="parameter"><code>func_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得一个函数或过程的定义</td></tr><tr><td><code class="literal"><code class="function">pg_get_function_arguments(<em class="parameter"><code>func_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得一个函数或过程定义的参数列表（带有默认值）</td></tr><tr><td><code class="literal"><code class="function">pg_get_function_identity_arguments(<em class="parameter"><code>func_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得标识一个函数或过程的参数列表（不带默认值）</td></tr><tr><td><code class="literal"><code class="function">pg_get_function_result(<em class="parameter"><code>func_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得函数的<code class="literal">RETURNS</code>子句（对过程返回空）</td></tr><tr><td><code class="literal"><code class="function">pg_get_indexdef(<em class="parameter"><code>index_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得索引的<code class="command">CREATE INDEX</code>命令</td></tr><tr><td><code class="literal"><code class="function">pg_get_indexdef(<em class="parameter"><code>index_oid</code></em>, <em class="parameter"><code>column_no</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得索引的<code class="command">CREATE INDEX</code>命令，或者当<em class="parameter"><code>column_no</code></em>为非零时只得到一个索引列的定义</td></tr><tr><td><code class="literal"><code class="function">pg_get_keywords()</code></code></td><td><code class="type">setof record</code></td><td>获得 SQL 关键字的列表及其分类</td></tr><tr><td><code class="literal"><code class="function">pg_get_ruledef(<em class="parameter"><code>rule_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得规则的<code class="command">CREATE RULE</code>命令</td></tr><tr><td><code class="literal"><code class="function">pg_get_ruledef(<em class="parameter"><code>rule_oid</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得规则的<code class="command">CREATE RULE</code>命令</td></tr><tr><td><code class="literal"><code class="function">pg_get_serial_sequence(<em class="parameter"><code>table_name</code></em>, <em class="parameter"><code>column_name</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得一个序列列或标识列使用的序列的名称</td></tr><tr><td><code class="literal"><code class="function">pg_get_statisticsobjdef(<em class="parameter"><code>statobj_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>为扩展的统计信息对象得到<code class="command">CREATE STATISTICS</code>命令</td></tr><tr><td><code class="function">pg_get_triggerdef</code>(<em class="parameter"><code>trigger_oid</code></em>)</td><td><code class="type">text</code></td><td>获得触发器的<code class="command">CREATE [ CONSTRAINT ] TRIGGER</code>命令</td></tr><tr><td><code class="function">pg_get_triggerdef</code>(<em class="parameter"><code>trigger_oid</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</td><td><code class="type">text</code></td><td>获得触发器的<code class="command">CREATE [ CONSTRAINT ] TRIGGER</code>命令</td></tr><tr><td><code class="literal"><code class="function">pg_get_userbyid(<em class="parameter"><code>role_oid</code></em>)</code></code></td><td><code class="type">name</code></td><td>获得给定 OID 指定的角色名</td></tr><tr><td><code class="literal"><code class="function">pg_get_viewdef(<em class="parameter"><code>view_name</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得视图或物化视图的底层<code class="command">SELECT</code>命令（<span class="emphasis"><em>已废弃</em></span>）</td></tr><tr><td><code class="literal"><code class="function">pg_get_viewdef(<em class="parameter"><code>view_name</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得视图或物化视图的底层<code class="command">SELECT</code>命令（<span class="emphasis"><em>已废弃</em></span>）</td></tr><tr><td><code class="literal"><code class="function">pg_get_viewdef(<em class="parameter"><code>view_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得视图或物化视图的底层<code class="command">SELECT</code>命令</td></tr><tr><td><code class="literal"><code class="function">pg_get_viewdef(<em class="parameter"><code>view_oid</code></em>, <em class="parameter"><code>pretty_bool</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得视图或物化视图的底层<code class="command">SELECT</code>命令</td></tr><tr><td><code class="literal"><code class="function">pg_get_viewdef(<em class="parameter"><code>view_oid</code></em>, <em class="parameter"><code>wrap_column_int</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得视图或物化视图的底层<code class="command">SELECT</code>命令；带域的行被包装成指定的列数，并隐含了优质打印</td></tr><tr><td><code class="literal"><code class="function">pg_index_column_has_property(<em class="parameter"><code>index_oid</code></em>, <em class="parameter"><code>column_no</code></em>, <em class="parameter"><code>prop_name</code></em>)</code></code></td><td><code class="type">boolean</code></td><td>测试一个索引列是否有指定的性质</td></tr><tr><td><code class="literal"><code class="function">pg_index_has_property(<em class="parameter"><code>index_oid</code></em>, <em class="parameter"><code>prop_name</code></em>)</code></code></td><td><code class="type">boolean</code></td><td>测试一个索引是否有指定的性质</td></tr><tr><td><code class="literal"><code class="function">pg_indexam_has_property(<em class="parameter"><code>am_oid</code></em>, <em class="parameter"><code>prop_name</code></em>)</code></code></td><td><code class="type">boolean</code></td><td>测试一个索引访问方法是否有指定的性质</td></tr><tr><td><code class="literal"><code class="function">pg_options_to_table(<em class="parameter"><code>reloptions</code></em>)</code></code></td><td><code class="type">setof record</code></td><td>获得存储选项的名称/值对的集合</td></tr><tr><td><code class="literal"><code class="function">pg_tablespace_databases(<em class="parameter"><code>tablespace_oid</code></em>)</code></code></td><td><code class="type">setof oid</code></td><td>获得在该表空间中有对象的数据库的 OID 的集合</td></tr><tr><td><code class="literal"><code class="function">pg_tablespace_location(<em class="parameter"><code>tablespace_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得这个表空间所在的文件系统的路径</td></tr><tr><td><code class="literal"><code class="function">pg_typeof(<em class="parameter"><code>any</code></em>)</code></code></td><td><code class="type">regtype</code></td><td>获得任意值的数据类型</td></tr><tr><td><code class="literal"><code class="function">collation for (<em class="parameter"><code>any</code></em>)</code></code></td><td><code class="type">text</code></td><td>获得该参数的排序规则</td></tr><tr><td><code class="literal"><code class="function">to_regclass(<em class="parameter"><code>rel_name</code></em>)</code></code></td><td><code class="type">regclass</code></td><td>得到指定关系的 OID</td></tr><tr><td><code class="literal"><code class="function">to_regproc(<em class="parameter"><code>func_name</code></em>)</code></code></td><td><code class="type">regproc</code></td><td>得到指定函数的 OID</td></tr><tr><td><code class="literal"><code class="function">to_regprocedure(<em class="parameter"><code>func_name</code></em>)</code></code></td><td><code class="type">regprocedure</code></td><td>得到指定函数的 OID</td></tr><tr><td><code class="literal"><code class="function">to_regoper(<em class="parameter"><code>operator_name</code></em>)</code></code></td><td><code class="type">regoper</code></td><td>得到指定操作符的 OID</td></tr><tr><td><code class="literal"><code class="function">to_regoperator(<em class="parameter"><code>operator_name</code></em>)</code></code></td><td><code class="type">regoperator</code></td><td>得到指定操作符的 OID</td></tr><tr><td><code class="literal"><code class="function">to_regtype(<em class="parameter"><code>type_name</code></em>)</code></code></td><td><code class="type">regtype</code></td><td>得到指定类型的 OID</td></tr><tr><td><code class="literal"><code class="function">to_regnamespace(<em class="parameter"><code>schema_name</code></em>)</code></code></td><td><code class="type">regnamespace</code></td><td>得到指定模式的 OID</td></tr><tr><td><code class="literal"><code class="function">to_regrole(<em class="parameter"><code>role_name</code></em>)</code></code></td><td><code class="type">regrole</code></td><td>得到指定角色的 OID</td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="function">format_type</code>返回一个数据类型的 SQL 名称，它由它的类型 OID 标识并且可能是一个类型修饰符。如果不知道相关的修饰符，则为类型修饰符传递 NULL。
  </p><p>
   <code class="function">pg_get_keywords</code>返回一组记录描述服务器识别的 SQL 关键字。<code class="structfield">word</code>列包含关键字。<code class="structfield">catcode</code>列包含一个分类码：<code class="literal">U</code>为未被预定，<code class="literal">C</code> 为列名，<code class="literal">T</code>类型或函数名，<code class="literal">R</code>为预留。<code class="structfield">catdesc</code>列包含一个可能本地化的描述分类的字符串。
  </p><p>
   <code class="function">pg_get_constraintdef</code>、<code class="function">pg_get_indexdef</code>、<code class="function">pg_get_ruledef</code>、<code class="function">pg_get_statisticsobjdef</code>和<code class="function">pg_get_triggerdef</code>分别重建一个约束、索引、规则、扩展统计对象或触发器的创建命令（注意这是一个反编译的重构，而不是命令的原始文本）。<code class="function">pg_get_expr</code>反编译一个表达式的内部形式，例如一个列的默认值。在检查系统目录内容时有用。如果表达式可能包含 Var，在第二个参数中指定它们引用的关系的 OID；如果不会出现 Var，第二个参数设置为 0 即可。<code class="function">pg_get_viewdef</code>重构定义一个视图的<code class="command">SELECT</code>查询。这些函数的大部分都有两种变体，一种可以可选地<span class="quote">“<span class="quote">优质打印</span>”</span>结果。优质打印的格式可读性更强，但是默认格式更可能被未来版本的<span class="productname">PostgreSQL</span>以相同的方式解释。在转出目的中避免使用优质打印输出。为优质打印参数传递<code class="literal">假</code>将得到和不带该参数的变体相同的结果。
  </p><p>
   <code class="function">pg_get_functiondef</code>为一个函数返回一个完整的<code class="command">CREATE OR REPLACE FUNCTION</code>语句。<code class="function">pg_get_function_arguments</code>返回一个函数的参数列表，形式按照它们出现在<code class="command">CREATE FUNCTION</code>中的那样。<code class="function">pg_get_function_result</code>类似地返回函数的合适的<code class="literal">RETURNS</code>子句。<code class="function">pg_get_function_identity_arguments</code>返回标识一个函数必要的参数列表，形式和它们出现在<code class="command">ALTER FUNCTION</code>中的一样。这种形式忽略默认值。
  </p><p>
   <code class="function">pg_get_serial_sequence</code>返回与一个列相关联的序列的名称，如果与列相关联的序列则返回 NULL。如果该列是一个标识列，相关联的序列是为该标识列内部创建的序列。对于使用序列类型之一（<code class="type">serial</code>、<code class="type">smallserial</code>、<code class="type">bigserial</code>）创建的列，它是为那个序列列定义创建的序列。在后一种情况中，这种关联可以用<code class="command">ALTER SEQUENCE OWNED BY</code>修改或者移除（该函数可能应该已经被<code class="function">pg_get_owned_sequence</code>调用，它当前的名称反映了它通常被<code class="type">serial</code>或<code class="type">bigserial</code>列使用）。第一个输入参数是一个带可选模式的表名，第二个参数是一个列名。因为第一个参数可能是一个模式和表，它不能按照一个双引号包围的标识符来对待，意味着它默认情况下是小写的。而第二个参数只是一个列名，将被当作一个双引号包围的来处理并且会保留其大小写。函数返回的值会被适当地格式化以便传递给序列函数（参见<a class="xref" href="functions-sequence.html" title="9.16. 序列操作函数">第 9.16 节</a>）。一种典型的用法是为标识列或者序列列读取当前值，例如：
</p><pre class="programlisting">
SELECT currval(pg_get_serial_sequence('sometable', 'id'));
</pre><p>
  </p><p>
   <code class="function">pg_get_userbyid</code>抽取给定 OID 的角色的名称。
  </p><p>
   <code class="function">pg_index_column_has_property</code>、<code class="function">pg_index_has_property</code>和<code class="function">pg_indexam_has_property</code>返回指定的索引列、索引或者索引访问方法是否具有指定性质。如果性质的名称找不到或者不适用于特定的对象，亦或者 OID 或者列号不表示合法的对象，则返回<code class="literal">NULL</code>。列的性质可参见<a class="xref" href="functions-info.html#FUNCTIONS-INFO-INDEX-COLUMN-PROPS" title="表 9.69. 索引列属性">表 9.69</a>，索引的性质可参见<a class="xref" href="functions-info.html#FUNCTIONS-INFO-INDEX-PROPS" title="表 9.70. 索引性质">表 9.70</a>，访问方法的性质可参见<a class="xref" href="functions-info.html#FUNCTIONS-INFO-INDEXAM-PROPS" title="表 9.71. 索引访问方法性质">表 9.71</a>（注意扩展访问方法可以为其索引定义额外的性质）。
  </p><div class="table" id="FUNCTIONS-INFO-INDEX-COLUMN-PROPS"><p class="title"><strong>表 9.69. 索引列属性</strong></p><div class="table-contents"><table class="table" summary="索引列属性" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal">asc</code></td><td>在向前扫描时列是按照升序排列吗？
      </td></tr><tr><td><code class="literal">desc</code></td><td>在向前扫描时列是按照降序排列吗？
      </td></tr><tr><td><code class="literal">nulls_first</code></td><td>在向前扫描时列排序会把空值排在前面吗？
      </td></tr><tr><td><code class="literal">nulls_last</code></td><td>在向前扫描时列排序会把空值排在最后吗？
      </td></tr><tr><td><code class="literal">orderable</code></td><td>列具有已定义的排序顺序吗？
      </td></tr><tr><td><code class="literal">distance_orderable</code></td><td>列能否通过一个<span class="quote">“<span class="quote">distance</span>”</span>操作符（例如<code class="literal">ORDER BY col &lt;-&gt; constant</code>）有序地扫描？
      </td></tr><tr><td><code class="literal">returnable</code></td><td>列值是否可以通过一次只用索引扫描返回？
      </td></tr><tr><td><code class="literal">search_array</code></td><td>列是否天然支持<code class="literal">col = ANY(array)</code>搜索？
      </td></tr><tr><td><code class="literal">search_nulls</code></td><td>列是否支持<code class="literal">IS NULL</code>和<code class="literal">IS NOT NULL</code>搜索？
      </td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="FUNCTIONS-INFO-INDEX-PROPS"><p class="title"><strong>表 9.70. 索引性质</strong></p><div class="table-contents"><table class="table" summary="索引性质" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal">clusterable</code></td><td>索引是否可以用于<code class="literal">CLUSTER</code>命令？
      </td></tr><tr><td><code class="literal">index_scan</code></td><td>索引是否支持普通扫描（非位图）？
      </td></tr><tr><td><code class="literal">bitmap_scan</code></td><td>索引是否支持位图扫描？
      </td></tr><tr><td><code class="literal">backward_scan</code></td><td>在扫描中扫描方向能否被更改（为了支持游标上无需物化的<code class="literal">FETCH BACKWARD</code>）？
      </td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="FUNCTIONS-INFO-INDEXAM-PROPS"><p class="title"><strong>表 9.71. 索引访问方法性质</strong></p><div class="table-contents"><table class="table" summary="索引访问方法性质" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal">can_order</code></td><td>访问方法是否支持<code class="literal">ASC</code>、<code class="literal">DESC</code>以及<code class="literal">CREATE INDEX</code>中的有关关键词？
      </td></tr><tr><td><code class="literal">can_unique</code></td><td>访问方法是否支持唯一索引？
      </td></tr><tr><td><code class="literal">can_multi_col</code></td><td>访问方法是否支持多列索引？
      </td></tr><tr><td><code class="literal">can_exclude</code></td><td>访问方法是否支持排除约束？
      </td></tr><tr><td><code class="literal">can_include</code></td><td>访问方法是否支持<code class="literal">CREATE INDEX</code>的<code class="literal">INCLUDE</code>子句？
      </td></tr></tbody></table></div></div><br class="table-break" /><p>
   当传入<code class="structname">pg_class</code>.<code class="structfield">reloptions</code>或<code class="structname">pg_attribute</code>.<code class="structfield">attoptions</code>时，<code class="function">pg_options_to_table</code>返回存储选项名称/值对（<em class="replaceable"><code>option_name</code></em>/<em class="replaceable"><code>option_value</code></em>）的集合。
  </p><p>
   <code class="function">pg_tablespace_databases</code>允许一个表空间被检查。它返回一组数据库的 OID，这些数据库都有对象存储在该表空间中。如果这个函数返回任何行，则该表空间为非空并且不能被删除。为了显示该表空间中的指定对象，你将需要连接到<code class="function">pg_tablespace_databases</code>标识的数据库并且查询它们的<code class="structname">pg_class</code>目录。
  </p><p>
   <code class="function">pg_typeof</code>返回传递给它的值的数据类型的 OID。这在检修或者动态构建 SQL 查询时有用。函数被声明为返回<code class="type">regtype</code>，它是一个 OID 别名类型（见<a class="xref" href="datatype-oid.html" title="8.19. 对象标识符类型">第 8.19 节</a>）；这表明它和一个用于比较目的的 OID 相同，但是作为一个类型名称显示。例如：
</p><pre class="programlisting">
SELECT pg_typeof(33);

 pg_typeof 
-----------
 integer
(1 row)

SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);
 typlen 
--------
      4
(1 row)
</pre><p>
  </p><p>
   表达式<code class="literal">collation for</code>返回传递给它的值的排序规则。例子：
</p><pre class="programlisting">
SELECT collation for (description) FROM pg_description LIMIT 1;
 pg_collation_for 
------------------
 "default"
(1 row)

SELECT collation for ('foo' COLLATE "de_DE");
 pg_collation_for 
------------------
 "de_DE"
(1 row)
</pre><p>
  值可能被加上引号并且变成模式限定的。如果从参数表达式得不到排序规则，则返回一个空值。如果参数不是一个可排序的数据类型，则抛出一个错误。
  </p><p>
   <code class="function">to_regclass</code>、<code class="function">to_regproc</code>、<code class="function">to_regprocedure</code>, <code class="function">to_regoper</code>、<code class="function">to_regoperator</code>、<code class="function">to_regtype</code>、<code class="function">to_regnamespace</code>和<code class="function">to_regrole</code>函数把关系、函数、操作符、类型、模式和角色的名称（以<code class="type">text</code>给出）分别转换成、<code class="type">regclass</code>、<code class="type">regproc</code>、<code class="type">regprocedure</code>、<code class="type">regoper</code>、<code class="type">regoperator</code>、<code class="type">regtype</code>、<code class="type">regnamespace</code>和<code class="type">regrole</code>对象。这些函数与 text 转换的不同在于它们不接受数字 OID，并且在名称无法找到时不会抛出错误而是返回空。对于<code class="function">to_regproc</code>和<code class="function">to_regoper</code>，如果给定名称匹配多个对象时返回空。
  </p><a id="id-1.5.8.30.156" class="indexterm"></a><a id="id-1.5.8.30.157" class="indexterm"></a><a id="id-1.5.8.30.158" class="indexterm"></a><a id="id-1.5.8.30.159" class="indexterm"></a><p>
   <a class="xref" href="functions-info.html#FUNCTIONS-INFO-OBJECT-TABLE" title="表 9.72. 对象信息和定位函数">表 9.72</a>列出了与数据库对象
   标识和定位有关的函数。
  </p><div class="table" id="FUNCTIONS-INFO-OBJECT-TABLE"><p class="title"><strong>表 9.72. 对象信息和定位函数</strong></p><div class="table-contents"><table class="table" summary="对象信息和定位函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">pg_describe_object(<em class="parameter"><code>catalog_id</code></em>, <em class="parameter"><code>object_id</code></em>, <em class="parameter"><code>object_sub_id</code></em>)</code></code></td><td><code class="type">text</code></td><td>得到一个数据库对象的描述</td></tr><tr><td><code class="literal"><code class="function">pg_identify_object(<em class="parameter"><code>catalog_id</code></em> <code class="type">oid</code>, <em class="parameter"><code>object_id</code></em> <code class="type">oid</code>, <em class="parameter"><code>object_sub_id</code></em> <code class="type">integer</code>)</code></code></td><td><em class="parameter"><code>type</code></em> <code class="type">text</code>, <em class="parameter"><code>schema</code></em> <code class="type">text</code>, <em class="parameter"><code>name</code></em> <code class="type">text</code>, <em class="parameter"><code>identity</code></em> <code class="type">text</code></td><td>得到一个数据库对象的标识</td></tr><tr><td><code class="literal"><code class="function">pg_identify_object_as_address(<em class="parameter"><code>catalog_id</code></em> <code class="type">oid</code>, <em class="parameter"><code>object_id</code></em> <code class="type">oid</code>, <em class="parameter"><code>object_sub_id</code></em> <code class="type">integer</code>)</code></code></td><td><em class="parameter"><code>type</code></em> <code class="type">text</code>, <em class="parameter"><code>name</code></em> <code class="type">text[]</code>, <em class="parameter"><code>args</code></em> <code class="type">text[]</code></td><td>得到一个数据库对象的地址的外部表示</td></tr><tr><td><code class="literal"><code class="function">pg_get_object_address(<em class="parameter"><code>type</code></em> <code class="type">text</code>, <em class="parameter"><code>name</code></em> <code class="type">text[]</code>, <em class="parameter"><code>args</code></em> <code class="type">text[]</code>)</code></code></td><td><em class="parameter"><code>class_id</code></em> <code class="type">oid</code>, <em class="parameter"><code>object_id</code></em> <code class="type">oid</code>, <em class="parameter"><code>object_sub_id</code></em> <code class="type">int32</code></td><td>从一个数据库对象的内部表示得到它的地址</td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="function">pg_describe_object</code>返回由目录OID、对象OID以及子对象ID（例如表中的一个列号，当子对象引用了一整个对象时其ID为零）指定的数据库对象的文本描述。这种描述是为
   了人类可读的，并且可能是被翻译过的，具体取决于服务器配置。这有助于确定一
   个存储在<code class="structname">pg_depend</code>目录中的对象的标识。
  </p><p>
   <code class="function">pg_identify_object</code>返回一行，其中包含有足以唯一标识
   由目录 OID、对象 OID 和一个（可能为零的）子对象 ID 指定的数据库对象的信息。
   该信息是共机器读取的，并且不会被翻译。<em class="parameter"><code>type</code></em>标识数据库对象
   的类型；<em class="parameter"><code>schema</code></em>是该对象所属的模式名，如果对象类型不属于
   模式则为<code class="literal">NULL</code>；如果名称（加上方案名，如果相关）足以唯一标识对象，则<em class="parameter"><code>name</code></em>就是对象的名称（必要时会被加上引号），否则为<code class="literal">NULL</code>；<em class="parameter"><code>identity</code></em>是完整的对象标识，
   它会表现为与对象类型相关的精确格式，并且如有必要，该格式中的每个部分都会
   被模式限定。
  </p><p>
   <code class="function">pg_identify_object_as_address</code>返回一行，其中包含有
   足以唯一标识由目录 OID、对象 OID 和一个（可能为零的）子对象 ID 指定的数据
   库对象的信息。返回的信息独立于当前服务器，也就是说，它可以被用来在另一个
   服务器中标识一个具有相同命名的对象。<em class="parameter"><code>type</code></em>标识数据库对象
   的类型；<em class="parameter"><code>object_names</code></em>和<em class="parameter"><code>object_args</code></em>是文本数组，它们一起
   构成了对对象的引用。这三个值可以被传递给
   <code class="function">pg_get_object_address</code>以获得该对象的内部地址。这个函数是
   <code class="function">pg_get_object_address</code>的逆函数。
  </p><p>
   <code class="function">pg_get_object_address</code>返回一行，其中包含有足以唯一
   标识由类型、对象名和参数数组指定的数据库对象的信息。返回值可以被用在诸如
   <code class="structname">pg_depend</code>等系统目录中并且可以被传递给
   <code class="function">pg_identify_object</code>或<code class="function">pg_describe_object</code>等其他
   系统函数。<em class="parameter"><code>class_id</code></em>是包含该对象的系统目录 OID；
   <em class="parameter"><code>objid</code></em>是对象本身的 OID，而
   <em class="parameter"><code>objsubid</code></em>是子对象 ID，如果没有则为零。这个函数是
   <code class="function">pg_identify_object_as_address</code>的逆函数。
  </p><a id="id-1.5.8.30.166" class="indexterm"></a><a id="id-1.5.8.30.167" class="indexterm"></a><a id="id-1.5.8.30.168" class="indexterm"></a><a id="id-1.5.8.30.169" class="indexterm"></a><p>
    <a class="xref" href="functions-info.html#FUNCTIONS-INFO-COMMENT-TABLE" title="表 9.73. 注释信息函数">表 9.73</a>中展示的函数抽取注释，注释是由<a class="xref" href="sql-comment.html" title="COMMENT"><span class="refentrytitle">COMMENT</span></a>命令在以前存储的。如果对指定参数找不到注释，则返回空值。
   </p><div class="table" id="FUNCTIONS-INFO-COMMENT-TABLE"><p class="title"><strong>表 9.73. 注释信息函数</strong></p><div class="table-contents"><table class="table" summary="注释信息函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">col_description(<em class="parameter"><code>table_oid</code></em>, <em class="parameter"><code>column_number</code></em>)</code></code></td><td><code class="type">text</code></td><td>为一个表列获得注释</td></tr><tr><td><code class="literal"><code class="function">obj_description(<em class="parameter"><code>object_oid</code></em>, <em class="parameter"><code>catalog_name</code></em>)</code></code></td><td><code class="type">text</code></td><td>为一个数据库对象获得注释</td></tr><tr><td><code class="literal"><code class="function">obj_description(<em class="parameter"><code>object_oid</code></em>)</code></code></td><td><code class="type">text</code></td><td>为一个数据库对象获得注释（<span class="emphasis"><em>已被废弃</em></span>）</td></tr><tr><td><code class="literal"><code class="function">shobj_description(<em class="parameter"><code>object_oid</code></em>, <em class="parameter"><code>catalog_name</code></em>)</code></code></td><td><code class="type">text</code></td><td>为一个共享数据库对象获得注释</td></tr></tbody></table></div></div><br class="table-break" /><p>
    <code class="function">col_description</code>为一个表列返回注释，该表列由所在表的 OID 和它的列号指定（<code class="function">obj_description</code>不能被用在表列，因为表列没有自己的 OID）。
   </p><p>
    <code class="function">obj_description</code>的双参数形式返回一个由其 OID 和所在系统目录名称指定的数据库对象的注释。例如，<code class="literal">obj_description(123456,'pg_class')</code>将会检索出 OID 为123456的表的注释。<code class="function">obj_description</code>的单参数形式只要求对象 OID。它已经被废弃，因为无法保证 OID 在不同系统目录之间是唯一的；这样可能会返回错误的注释。
   </p><p>
    <code class="function">shobj_description</code>用起来就像<code class="function">obj_description</code>，但是前者是用于检索共享对象上的注释。某些系统目录对于一个集簇中的所有数据库是全局的，并且其中的对象的描述也是全局存储的。
   </p><a id="id-1.5.8.30.175" class="indexterm"></a><a id="id-1.5.8.30.176" class="indexterm"></a><a id="id-1.5.8.30.177" class="indexterm"></a><a id="id-1.5.8.30.178" class="indexterm"></a><a id="id-1.5.8.30.179" class="indexterm"></a><a id="id-1.5.8.30.180" class="indexterm"></a><a id="id-1.5.8.30.181" class="indexterm"></a><a id="id-1.5.8.30.182" class="indexterm"></a><p>
    <a class="xref" href="functions-info.html#FUNCTIONS-TXID-SNAPSHOT" title="表 9.74. 事务 ID 和快照">表 9.74</a>中展示的函数以一种可导出的形式提供了服务器事务信息。这些函数的主要用途是判断在两个快照之间哪些事务被提交。
   </p><div class="table" id="FUNCTIONS-TXID-SNAPSHOT"><p class="title"><strong>表 9.74. 事务 ID 和快照</strong></p><div class="table-contents"><table class="table" summary="事务 ID 和快照" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">txid_current()</code></code></td><td><code class="type">bigint</code></td><td>获得当前事务 ID，如果当前事务没有 ID 则分配一个新的 ID</td></tr><tr><td><code class="literal"><code class="function">txid_current_if_assigned()</code></code></td><td><code class="type">bigint</code></td><td>与<code class="function">txid_current()</code>相同，但是在事务没有分配ID时是返回空值而不是分配一个新的事务ID</td></tr><tr><td><code class="literal"><code class="function">txid_current_snapshot()</code></code></td><td><code class="type">txid_snapshot</code></td><td>获得当前快照</td></tr><tr><td><code class="literal"><code class="function">txid_snapshot_xip(<em class="parameter"><code>txid_snapshot</code></em>)</code></code></td><td><code class="type">setof bigint</code></td><td>获得快照中正在进行的事务 ID</td></tr><tr><td><code class="literal"><code class="function">txid_snapshot_xmax(<em class="parameter"><code>txid_snapshot</code></em>)</code></code></td><td><code class="type">bigint</code></td><td>获得快照的<code class="literal">xmax</code></td></tr><tr><td><code class="literal"><code class="function">txid_snapshot_xmin(<em class="parameter"><code>txid_snapshot</code></em>)</code></code></td><td><code class="type">bigint</code></td><td>获得快照的<code class="literal">xmin</code></td></tr><tr><td><code class="literal"><code class="function">txid_visible_in_snapshot(<em class="parameter"><code>bigint</code></em>, <em class="parameter"><code>txid_snapshot</code></em>)</code></code></td><td><code class="type">boolean</code></td><td>事务 ID 在快照中可见吗？（不能用于子事务 ID）</td></tr><tr><td><code class="literal"><code class="function">txid_status(<em class="parameter"><code>bigint</code></em>)</code></code></td><td><code class="type">text</code></td><td>报告给定事务的状态：<code class="literal">committed</code>、<code class="literal">aborted</code>、<code class="literal">in progress</code>，如果事务ID太老则为空值</td></tr></tbody></table></div></div><br class="table-break" /><p>
    内部事务 ID 类型（<code class="type">xid</code>）是 32 位宽并且每 40 亿个事务就会回卷。但是，这些函数导出一种 64 位格式，它被使用一个<span class="quote">“<span class="quote">世代</span>”</span>计数器，这样在一个安装的生命期内不会回卷。这些函数使用的数据类型<code class="type">txid_snapshot</code>存储了在一个特定时刻有关事务 ID 可见性的信息。它的成分在<a class="xref" href="functions-info.html#FUNCTIONS-TXID-SNAPSHOT-PARTS" title="表 9.75. 快照成分">表 9.75</a>中描述。
   </p><div class="table" id="FUNCTIONS-TXID-SNAPSHOT-PARTS"><p class="title"><strong>表 9.75. 快照成分</strong></p><div class="table-contents"><table class="table" summary="快照成分" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td><code class="type">xmin</code></td><td>
         仍然活动的最早的事务 ID （txid）。所有更早的事务要么已经被提交并且可见，要么已经被回滚并且死亡。
       </td></tr><tr><td><code class="type">xmax</code></td><td>
        第一个还未分配的 txid。所有大于等于它的 txid 在快照的时刻还没有开始，并且因此是不可见的。
       </td></tr><tr><td><code class="type">xip_list</code></td><td>
        在快照时刻活动的 txid。这个列表只包括那些位于<code class="literal">xmin</code>和<code class="literal">xmax</code>之间的活动 txid；可能有活动的超过<code class="literal">xmax</code>的 txid。一个满足<code class="literal">xmin &lt;= txid &lt; xmax</code>并且不在这个列表中的 txid 在快照时刻已经结束，并且因此根据其提交状态要么可见要么死亡。该列表不包括子事务的 txid。
       </td></tr></tbody></table></div></div><br class="table-break" /><p>
    <code class="type">txid_snapshot</code>的文本表示是<code class="literal"><em class="replaceable"><code>xmin</code></em>:<em class="replaceable"><code>xmax</code></em>:<em class="replaceable"><code>xip_list</code></em></code>。例如<code class="literal">10:20:10,14,15</code>表示<code class="literal">xmin=10, xmax=20, xip_list=10, 14, 15</code>。
   </p><p>
    <code class="function">txid_status(bigint)</code>报告一个近期事务的提交状态。当一个应用和数据库服务器的连接在<code class="literal">COMMIT</code>正在进行时断开，应用可以用它来判断事务是提交了还是中止了。一个事务的状态将被报告为<code class="literal">in progress</code>、<code class="literal">committed</code>或者<code class="literal">aborted</code>，前提是该事务的发生时间足够近，这样系统才会保留它的提交状态。如果事务太老，则系统中不会留下对该事务的引用并且提交状态信息也已经被抛弃，那么这个函数将会返回NULL。注意，预备事务会被报告为<code class="literal">in progress</code>，如果应用需要判断该txid是否是一个预备事务，应用必须检查<a class="link" href="view-pg-prepared-xacts.html" title="51.78. pg_prepared_xacts"><code class="literal">pg_prepared_xacts</code></a>。
   </p><p>
    <a class="xref" href="functions-info.html#FUNCTIONS-COMMIT-TIMESTAMP" title="表 9.76. 已提交事务信息">表 9.76</a>中展示的函数提供了有关于
    已经提交事务的信息。这些函数主要提供有关事务何时被提交的信息。只有当
    <a class="xref" href="runtime-config-replication.html#GUC-TRACK-COMMIT-TIMESTAMP">track_commit_timestamp</a>配置选项被启用时它们才能
    提供有用的数据，并且只对已提交事务提供数据。
   </p><div class="table" id="FUNCTIONS-COMMIT-TIMESTAMP"><p class="title"><strong>表 9.76. 已提交事务信息</strong></p><div class="table-contents"><table class="table" summary="已提交事务信息" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <a id="id-1.5.8.30.190.2.2.1.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_xact_commit_timestamp(<em class="parameter"><code>xid</code></em>)</code></code>
       </td><td><code class="type">timestamp with time zone</code></td><td>得到一个事务的提交时间戳</td></tr><tr><td>
        <a id="id-1.5.8.30.190.2.2.2.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_last_committed_xact()</code></code>
       </td><td><em class="parameter"><code>xid</code></em> <code class="type">xid</code>, <em class="parameter"><code>timestamp</code></em> <code class="type">timestamp with time zone</code></td><td>得到最后一个已提交事务的事务 ID 和提交时间戳</td></tr></tbody></table></div></div><br class="table-break" /><p>
    <a class="xref" href="functions-info.html#FUNCTIONS-CONTROLDATA" title="表 9.77. 控制数据函数">表 9.77</a>中所展示的函数能打印<code class="command">initdb</code>期间初始化的信息，例如系统目录版本。它们也能显示有关预写式日志和检查点处理的信息。这些信息是集簇范围内的，不与任何特定的一个数据库相关。对于同一种来源，它们返回和<a class="xref" href="app-pgcontroldata.html" title="pg_controldata"><span class="refentrytitle"><span class="application">pg_controldata</span></span></a>大致相同的信息，不过其形式更适合于<acronym class="acronym">SQL</acronym>函数。
   </p><div class="table" id="FUNCTIONS-CONTROLDATA"><p class="title"><strong>表 9.77. 控制数据函数</strong></p><div class="table-contents"><table class="table" summary="控制数据函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <a id="id-1.5.8.30.192.2.2.1.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_control_checkpoint()</code></code>
       </td><td><code class="type">record</code></td><td>
        返回有关当前检查点状态的信息。
       </td></tr><tr><td>
        <a id="id-1.5.8.30.192.2.2.2.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_control_system()</code></code>
       </td><td><code class="type">record</code></td><td>
        返回有关当前控制文件状态的信息。
       </td></tr><tr><td>
        <a id="id-1.5.8.30.192.2.2.3.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_control_init()</code></code>
       </td><td><code class="type">record</code></td><td>
        返回有关集簇初始化状态的信息。
       </td></tr><tr><td>
        <a id="id-1.5.8.30.192.2.2.4.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_control_recovery()</code></code>
       </td><td><code class="type">record</code></td><td>
        返回有关恢复状态的信息。
       </td></tr></tbody></table></div></div><br class="table-break" /><p>
    <code class="function">pg_control_checkpoint</code>返回一个<a class="xref" href="functions-info.html#FUNCTIONS-PG-CONTROL-CHECKPOINT" title="表 9.78. pg_control_checkpoint列">表 9.78</a>中所示的记录
   </p><div class="table" id="FUNCTIONS-PG-CONTROL-CHECKPOINT"><p class="title"><strong>表 9.78. <code class="function">pg_control_checkpoint</code>列</strong></p><div class="table-contents"><table class="table" summary="pg_control_checkpoint列" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>列名</th><th>数据类型</th></tr></thead><tbody><tr><td><code class="literal">checkpoint_location</code></td><td><code class="type">pg_lsn</code></td></tr><tr><td><code class="literal">redo_lsn</code></td><td><code class="type">pg_lsn</code></td></tr><tr><td><code class="literal">redo_wal_file</code></td><td><code class="type">text</code></td></tr><tr><td><code class="literal">timeline_id</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">prev_timeline_id</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">full_page_writes</code></td><td><code class="type">boolean</code></td></tr><tr><td><code class="literal">next_xid</code></td><td><code class="type">text</code></td></tr><tr><td><code class="literal">next_oid</code></td><td><code class="type">oid</code></td></tr><tr><td><code class="literal">next_multixact_id</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">next_multi_offset</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">oldest_xid</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">oldest_xid_dbid</code></td><td><code class="type">oid</code></td></tr><tr><td><code class="literal">oldest_active_xid</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">oldest_multi_xid</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">oldest_multi_dbid</code></td><td><code class="type">oid</code></td></tr><tr><td><code class="literal">oldest_commit_ts_xid</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">newest_commit_ts_xid</code></td><td><code class="type">xid</code></td></tr><tr><td><code class="literal">checkpoint_time</code></td><td><code class="type">timestamp with time zone</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
    <code class="function">pg_control_system</code>返回一个<a class="xref" href="functions-info.html#FUNCTIONS-PG-CONTROL-SYSTEM" title="表 9.79. pg_control_system列">表 9.79</a>中所示的记录
   </p><div class="table" id="FUNCTIONS-PG-CONTROL-SYSTEM"><p class="title"><strong>表 9.79. <code class="function">pg_control_system</code>列</strong></p><div class="table-contents"><table class="table" summary="pg_control_system列" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>列名</th><th>数据类型</th></tr></thead><tbody><tr><td><code class="literal">pg_control_version</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">catalog_version_no</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">system_identifier</code></td><td><code class="type">bigint</code></td></tr><tr><td><code class="literal">pg_control_last_modified</code></td><td><code class="type">timestamp with time zone</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
    <code class="function">pg_control_init</code>返回一个<a class="xref" href="functions-info.html#FUNCTIONS-PG-CONTROL-INIT" title="表 9.80. pg_control_init列">表 9.80</a>中所示的记录
   </p><div class="table" id="FUNCTIONS-PG-CONTROL-INIT"><p class="title"><strong>表 9.80. <code class="function">pg_control_init</code>列</strong></p><div class="table-contents"><table class="table" summary="pg_control_init列" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>列名</th><th>数据类型</th></tr></thead><tbody><tr><td><code class="literal">max_data_alignment</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">database_block_size</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">blocks_per_segment</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">wal_block_size</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">bytes_per_wal_segment</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">max_identifier_length</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">max_index_columns</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">max_toast_chunk_size</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">large_object_chunk_size</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">float4_pass_by_value</code></td><td><code class="type">boolean</code></td></tr><tr><td><code class="literal">float8_pass_by_value</code></td><td><code class="type">boolean</code></td></tr><tr><td><code class="literal">data_page_checksum_version</code></td><td><code class="type">integer</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
    <code class="function">pg_control_recovery</code>返回一个<a class="xref" href="functions-info.html#FUNCTIONS-PG-CONTROL-RECOVERY" title="表 9.81. pg_control_recovery列">表 9.81</a>中所示的记录
   </p><div class="table" id="FUNCTIONS-PG-CONTROL-RECOVERY"><p class="title"><strong>表 9.81. <code class="function">pg_control_recovery</code>列</strong></p><div class="table-contents"><table class="table" summary="pg_control_recovery列" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>列名</th><th>数据类型</th></tr></thead><tbody><tr><td><code class="literal">min_recovery_end_lsn</code></td><td><code class="type">pg_lsn</code></td></tr><tr><td><code class="literal">min_recovery_end_timeline</code></td><td><code class="type">integer</code></td></tr><tr><td><code class="literal">backup_start_lsn</code></td><td><code class="type">pg_lsn</code></td></tr><tr><td><code class="literal">backup_end_lsn</code></td><td><code class="type">pg_lsn</code></td></tr><tr><td><code class="literal">end_of_backup_record_required</code></td><td><code class="type">boolean</code></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-srf.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-admin.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">9.24. 集合返回函数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 9.26. 系统管理函数</td></tr></table></div></body></html>