<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>59.3. PostgreSQL 中的遗传查询优化（GEQO）</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="geqo-intro2.html" title="59.2. 遗传算法" /><link rel="next" href="geqo-biblio.html" title="59.4. 进一步阅读" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">59.3. PostgreSQL 中的遗传查询优化（<acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">GEQO</acronym>）</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="geqo-intro2.html" title="59.2. 遗传算法">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="geqo.html" title="第 59 章 遗传查询优化器">上一级</a></td><th width="60%" align="center">第 59 章 遗传查询优化器</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="geqo-biblio.html" title="59.4. 进一步阅读">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="GEQO-PG-INTRO"><div class="titlepage"><div><div><h2 class="title" style="clear: both">59.3. PostgreSQL 中的遗传查询优化（<acronym class="acronym">GEQO</acronym>）</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="geqo-pg-intro.html#id-1.10.12.5.6">59.3.1. 用<acronym class="acronym">GEQO</acronym>产生可能的计划</a></span></dt><dt><span class="sect2"><a href="geqo-pg-intro.html#GEQO-FUTURE">59.3.2. <span class="productname">PostgreSQL</span> <acronym class="acronym">GEQO</acronym>的未来实现任务</a></span></dt></dl></div><p>
    <acronym class="acronym">GEQO</acronym>模块把查询优化问题当做著名的货郎担问题（<acronym class="acronym">TSP</acronym>）来处理。可能的查询计划被编码为整数的串。每一个串表示从查询中一个关系到下一个关系的连接顺序。例如，连接树
</p><pre class="literallayout">
   /\
  /\ 2
 /\ 3
4  1
</pre><p>
    被编码为整数串 '4-1-3-2'，它表示首先连接关系 '4' 和 '1'，然后连接 '3'，最后连接 '2'。这里 1、2、3、4 是<span class="productname">PostgreSQL</span>优化器中的关系 ID。
   </p><p>
    <span class="productname">PostgreSQL</span>中<acronym class="acronym">GEQO</acronym>实现的特点有：

    </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p>
       一种<em class="firstterm">稳态</em> <acronym class="acronym">GA</acronym>（在种群中替换适应度最差的个体，而不是整代替换）的使用允许对改进的查询计划快速收敛。这对在合理时间内处理查询是最重要的；
      </p></li><li class="listitem" style="list-style-type: disc"><p>
       <em class="firstterm">边重组杂交</em>的使用特别适合于通过<acronym class="acronym">GA</acronym>为<acronym class="acronym">TSP</acronym>的解决方案保持低丢边率；
      </p></li><li class="listitem" style="list-style-type: disc"><p>
       遗传操作符变异被废弃，这样不需要修补机制来产生合法的<acronym class="acronym">TSP</acronym>旅行。
      </p></li></ul></div><p>
   </p><p>
    <acronym class="acronym">GEQO</acronym>模块的一部分是从 D. Whitley 的遗传算法中改编而来。
   </p><p>
    <acronym class="acronym">GEQO</acronym>模块允许<span class="productname">PostgreSQL</span>查询优化器支持通过非穷举搜索高效地处理大量连接的查询。
   </p><div class="sect2" id="id-1.10.12.5.6"><div class="titlepage"><div><div><h3 class="title">59.3.1. 用<acronym class="acronym">GEQO</acronym>产生可能的计划</h3></div></div></div><p>
    <acronym class="acronym">GEQO</acronym>规划处理使用标准的规划器代码来产生用于扫描个体关系的计划。然后使用遗传方法发展连接计划。如上所示，每一个候选连接计划被表示为一个连接基本关系的序列。在初始阶段，<acronym class="acronym">GEQO</acronym>代码简单地随机产生某些可能的连接序列。对于被考虑的每一个连接序列，标准规划器代码被调用来估算使用该序列执行查询的代价（对于连接序列的每一步，所有三种连接策略都被考虑；并且所有初始决定的关系扫描计划都可用。估计的代价是这些可能性中最低的那个。）。具有较低估计代价的连接序列被认为比具有较高代价的<span class="quote">“<span class="quote">更适合</span>”</span>。遗传算法会丢弃最不适应的候选。然后通过组合更适合的候选的基因来产生新的候选 — 即使从已知代价低的连接序列随机选择片段来创建用于考虑的新序列。这个处理将被重复，直到已经考虑的连接序列的数量达到一个预设值。然后在搜索中任何时候找到的最好的一个将被用来产生最终的计划。
   </p><p>
    由于在初始种群选择和后续最佳候选的<span class="quote">“<span class="quote">变异</span>”</span>过程中都采用了随机选择，所以这种处理天生就是非确定性的。要避免被选中计划发生出乎意料的改变，每次 GEQO 算法的运行都会使用当前<a class="xref" href="runtime-config-query.html#GUC-GEQO-SEED">geqo_seed</a>参数设置来重启它的随机数生成器。只要<code class="varname">geqo_seed</code>以及其他 GEQO 参数保持固定（以及其他规划器输入，如统计信息），对一个给定的查询将产生相同的计划。要试验不同的搜索路径，可以尝试改变<code class="varname">geqo_seed</code>。
   </p></div><div class="sect2" id="GEQO-FUTURE"><div class="titlepage"><div><div><h3 class="title">59.3.2. <span class="productname">PostgreSQL</span> <acronym class="acronym">GEQO</acronym>的未来实现任务</h3></div></div></div><p>
      仍需对改进遗传算法的参数设置做一些工作。在文件<code class="filename">src/backend/optimizer/geqo/geqo_main.c</code>、例程<code class="function">gimme_pool_size</code>和<code class="function">gimme_number_generations</code>中，我们必须为参数设置找到一种折中来满足两个互相竞争的需求：
      </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
         查询计划的最优性
        </p></li><li class="listitem"><p>
         计算时间
        </p></li></ul></div><p>
     </p><p>
      在当前的实现中，每一个候选连接序列的适应度通过运行标准规划器的连接选择和代价估计代码从零估算而来。即使不同的候选中使用了相似的连接子序列，还是需要重复大量的工作。通过保留子连接的代价估计可以在这种情况下节省很多时间。但问题在于要避免为了保留那样的状态而不合理地占用过多内存。
     </p><p>
      在更基础的层面上，用一个为 TSP 设计的 GA 算法来解决查询优化问题是否合适也还需要探讨。在 TSP 情况中，与任何子串（部分旅程）相关的代价独立于剩余的旅程，但是对于查询优化肯定不是这样。因此边重组杂交是否比变异过程更有效还存有疑问。
     </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="geqo-intro2.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="geqo.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="geqo-biblio.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">59.2. 遗传算法 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 59.4. 进一步阅读</td></tr></table></div></body></html>