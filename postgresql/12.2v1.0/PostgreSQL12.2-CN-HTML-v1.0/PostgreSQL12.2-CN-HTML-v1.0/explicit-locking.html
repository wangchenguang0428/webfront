<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>13.3. 显式锁定</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="transaction-iso.html" title="13.2. 事务隔离" /><link rel="next" href="applevel-consistency.html" title="13.4. 应用级别的数据完整性检查" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">13.3. 显式锁定</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="transaction-iso.html" title="13.2. 事务隔离">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="mvcc.html" title="第 13 章 并发控制">上一级</a></td><th width="60%" align="center">第 13 章 并发控制</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="applevel-consistency.html" title="13.4. 应用级别的数据完整性检查">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="EXPLICIT-LOCKING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">13.3. 显式锁定</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="explicit-locking.html#LOCKING-TABLES">13.3.1. 表级锁</a></span></dt><dt><span class="sect2"><a href="explicit-locking.html#LOCKING-ROWS">13.3.2. 行级锁</a></span></dt><dt><span class="sect2"><a href="explicit-locking.html#LOCKING-PAGES">13.3.3. 页级锁</a></span></dt><dt><span class="sect2"><a href="explicit-locking.html#LOCKING-DEADLOCKS">13.3.4. 死锁</a></span></dt><dt><span class="sect2"><a href="explicit-locking.html#ADVISORY-LOCKS">13.3.5. 咨询锁</a></span></dt></dl></div><a id="id-1.5.12.6.2" class="indexterm"></a><p>
    <span class="productname">PostgreSQL</span>提供了多种锁模式用于控制对表中数据的并发访问。 这些模式可以用于在<acronym class="acronym">MVCC</acronym>无法给出期望行为的情境中由应用控制的锁。 同样，大多数<span class="productname">PostgreSQL</span>命令会自动要求恰当的锁以保证被引用的表在命令的执行过程中 不会以一种不兼容的方式删除或修改（例如，<code class="command">TRUNCATE</code>无法安全地与同一表中上的其他操作并发地执行，因此它在表上获得一个排他锁来强制这种行为）。
   </p><p>
    要检查在一个数据库服务器中当前未解除的锁列表，可以使用<a class="link" href="view-pg-locks.html" title="51.74. pg_locks"><code class="structname">pg_locks</code></a>系统视图。 有关监控锁管理器子系统状态的更多信息，请参考<a class="xref" href="monitoring.html" title="第 27 章 监控数据库活动">第 27 章</a>。
   </p><div class="sect2" id="LOCKING-TABLES"><div class="titlepage"><div><div><h3 class="title">13.3.1. 表级锁</h3></div></div></div><a id="id-1.5.12.6.5.2" class="indexterm"></a><p>
    下面的列表显示了可用的锁模式和<span class="productname">PostgreSQL</span>自动使用它们的场合。 你也可以用<a class="xref" href="sql-lock.html" title="LOCK"><span class="refentrytitle">LOCK</span></a>命令显式获得这些锁。请记住所有这些锁模式都是表级锁，即使它们的名字包含<span class="quote">“<span class="quote">row</span>”</span>单词（这些名称是历史遗产）。 在一定程度上，这些名字反应了每种锁模式的典型用法 — 但是语意却都是一样的。 两种锁模式之间真正的区别是它们有着不同的冲突锁模式集合（参考<a class="xref" href="explicit-locking.html#TABLE-LOCK-COMPATIBILITY" title="表 13.2. 冲突的锁模式">表 13.2</a>）。 两个事务在同一时刻不能在同一个表上持有属于相互冲突模式的锁（但是，一个事务决不会和自身冲突。例如，它可以在同一个表上获得<code class="literal">ACCESS EXCLUSIVE</code>锁然后接着获取<code class="literal">ACCESS SHARE</code>锁）。非冲突锁模式可以由许多事务同时持有。 请特别注意有些锁模式是自冲突的（例如，在一个时刻<code class="literal">ACCESS EXCLUSIVE</code>锁不能被多于一个事务持有)而其他锁模式不是自冲突的（例如，<code class="literal">ACCESS SHARE</code>锁可以被多个事务持有)。
   </p><div class="variablelist"><p class="title"><strong>表级锁模式</strong></p><dl class="variablelist"><dt><span class="term">
        <code class="literal">ACCESS SHARE</code>
       </span></dt><dd><p>
         只与<code class="literal">ACCESS EXCLUSIVE</code>锁模式冲突。
        </p><p>
         <code class="command">SELECT</code>命令在被引用的表上获得一个这种模式的锁。通常，任何只<span class="emphasis"><em>读取</em></span>表而不修改它的查询都将获得这种锁模式。
        </p></dd><dt><span class="term">
        <code class="literal">ROW SHARE</code>
       </span></dt><dd><p>
         与<code class="literal">EXCLUSIVE</code>和<code class="literal">ACCESS EXCLUSIVE</code>锁模式冲突。
        </p><p>
         <code class="command">SELECT FOR UPDATE</code>和<code class="command">SELECT FOR SHARE</code>命令在目标表上取得一个这种模式的锁 （加上在被引用但没有选择<code class="option">FOR UPDATE/FOR SHARE</code>的任何其他表上的<code class="literal">ACCESS SHARE</code>锁）。
        </p></dd><dt><span class="term">
        <code class="literal">ROW EXCLUSIVE</code>
       </span></dt><dd><p>
         与<code class="literal">SHARE</code>、<code class="literal">SHARE ROW EXCLUSIVE</code>、<code class="literal">EXCLUSIVE</code>和<code class="literal">ACCESS EXCLUSIVE</code>锁模式冲突。
        </p><p>
         命令<code class="command">UPDATE</code>、<code class="command">DELETE</code>和<code class="command">INSERT</code>在目标表上取得这种锁模式（加上在任何其他被引用表上的<code class="literal">ACCESS SHARE</code>锁）。通常，这种锁模式将被任何<span class="emphasis"><em>修改表中数据</em></span>的命令取得。
        </p></dd><dt><span class="term">
        <code class="literal">SHARE UPDATE EXCLUSIVE</code>
       </span></dt><dd><p>
         与<code class="literal">SHARE UPDATE EXCLUSIVE</code>、<code class="literal">SHARE</code>、<code class="literal">SHARE ROW EXCLUSIVE</code>、<code class="literal">EXCLUSIVE</code>和<code class="literal">ACCESS EXCLUSIVE</code>锁模式冲突。这种模式保护一个表不受并发模式改变和<code class="command">VACUUM</code>运行的影响。
        </p><p>
         由<code class="command">VACUUM</code>（不带<code class="option">FULL</code>）、<code class="command">ANALYZE</code>、
         <code class="command">CREATE INDEX CONCURRENTLY</code>、<code class="command">REINDEX CONCURRENTLY</code>、
         <code class="command">CREATE STATISTICS</code>以及某些<code class="command">ALTER INDEX</code>和
         <code class="command">ALTER TABLE</code>的变体获得(完整的详细请参考<a class="xref" href="sql-alterindex.html" title="ALTER INDEX"><span class="refentrytitle">ALTER INDEX</span></a>
         和<a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>)。
        </p></dd><dt><span class="term">
        <code class="literal">SHARE</code>
       </span></dt><dd><p>
         与<code class="literal">ROW EXCLUSIVE</code>、<code class="literal">SHARE UPDATE EXCLUSIVE</code>、<code class="literal">SHARE ROW EXCLUSIVE</code>、<code class="literal">EXCLUSIVE</code>和<code class="literal">ACCESS EXCLUSIVE</code>锁模式冲突。这种模式保护一个表不受并发数据改变的影响。
        </p><p>
         由<code class="command">CREATE INDEX</code>（不带<code class="option">CONCURRENTLY</code>）取得。
        </p></dd><dt><span class="term">
        <code class="literal">SHARE ROW EXCLUSIVE</code>
       </span></dt><dd><p>
         与<code class="literal">ROW EXCLUSIVE</code>、<code class="literal">SHARE UPDATE EXCLUSIVE</code>、<code class="literal">SHARE</code>、<code class="literal">SHARE ROW EXCLUSIVE</code>、<code class="literal">EXCLUSIVE</code>和<code class="literal">ACCESS EXCLUSIVE</code>锁模式冲突。这种模式保护一个表不受并发数据修改所影响，并且是自排他的，这样在一个时刻只能有一个会话持有它。
        </p><p>
         由<code class="command">CREATE TRIGGER</code>和某些形式的
         <code class="command">ALTER TABLE</code>所获得（见
         <a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>）。
        </p></dd><dt><span class="term">
        <code class="literal">EXCLUSIVE</code>
       </span></dt><dd><p>
         与<code class="literal">ROW SHARE</code>、<code class="literal">ROW EXCLUSIVE</code>、<code class="literal">SHARE UPDATE EXCLUSIVE</code>、<code class="literal">SHARE</code>、<code class="literal">SHARE ROW EXCLUSIVE</code>、<code class="literal">EXCLUSIVE</code>和<code class="literal">ACCESS EXCLUSIVE</code>锁模式冲突。这种模式只允许并发的<code class="literal">ACCESS SHARE</code>锁，即只有来自于表的读操作可以与一个持有该锁模式的事务并行处理。
        </p><p>
         由<code class="command">REFRESH MATERIALIZED VIEW CONCURRENTLY</code>获得。
        </p></dd><dt><span class="term">
        <code class="literal">ACCESS EXCLUSIVE</code>
       </span></dt><dd><p>
         与所有模式的锁冲突（<code class="literal">ACCESS SHARE</code>、<code class="literal">ROW SHARE</code>、<code class="literal">ROW EXCLUSIVE</code>、<code class="literal">SHARE UPDATE EXCLUSIVE</code>、<code class="literal">SHARE</code>、<code class="literal">SHARE ROW EXCLUSIVE</code>、<code class="literal">EXCLUSIVE</code>和<code class="literal">ACCESS EXCLUSIVE</code>）。这种模式保证持有者是访问该表的唯一事务。
        </p><p>
         由<code class="command">ALTER TABLE</code>、<code class="command">DROP TABLE</code>、<code class="command">TRUNCATE</code>、<code class="command">REINDEX</code>、<code class="command">CLUSTER</code>、<code class="command">VACUUM FULL</code>和<code class="command">REFRESH MATERIALIZED VIEW</code>（不带<code class="option">CONCURRENTLY</code>）命令获取。
         很多形式的<code class="command">ALTER INDEX</code>和<code class="command">ALTER TABLE</code>也在这个层面上获得锁（见<a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>）。这也是未显式指定模式的<code class="command">LOCK TABLE</code>命令的默认锁模式。
        </p></dd></dl></div><div class="tip"><h3 class="title">提示</h3><p>
       只有一个<code class="literal">ACCESS EXCLUSIVE</code>锁阻塞一个<code class="command">SELECT</code>（不带<code class="option">FOR UPDATE/SHARE</code>）语句。
      </p></div><p>
    一旦被获取，一个锁通常将被持有直到事务结束。 但是如果在建立保存点之后才获得锁，那么在回滚到这个保存点的时候将立即释放该锁。 这与<code class="command">ROLLBACK</code>取消保存点之后所有的影响的原则保持一致。 同样的原则也适用于在<span class="application">PL/pgSQL</span>异常块中获得的锁：一个跳出块的错误将释放在块中获得的锁。
   </p><div class="table" id="TABLE-LOCK-COMPATIBILITY"><p class="title"><strong>表 13.2. 冲突的锁模式</strong></p><div class="table-contents"><table class="table" summary="冲突的锁模式" border="1"><colgroup><col /><col class="lockst" /><col /><col /><col /><col /><col /><col /><col class="lockend" /></colgroup><thead><tr><th rowspan="2">请求的锁模式</th><th colspan="8">当前的锁模式</th></tr><tr><th>ACCESS SHARE</th><th>ROW SHARE</th><th>ROW EXCLUSIVE</th><th>SHARE UPDATE EXCLUSIVE</th><th>SHARE</th><th>SHARE ROW EXCLUSIVE</th><th>EXCLUSIVE</th><th>ACCESS EXCLUSIVE</th></tr></thead><tbody><tr><td>ACCESS SHARE</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td></tr><tr><td>ROW SHARE</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td></tr><tr><td>ROW EXCLUSIVE</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>SHARE UPDATE EXCLUSIVE</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>SHARE</td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>SHARE ROW EXCLUSIVE</td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>EXCLUSIVE</td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>ACCESS EXCLUSIVE</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="LOCKING-ROWS"><div class="titlepage"><div><div><h3 class="title">13.3.2. 行级锁</h3></div></div></div><p>
     除了表级锁以外，还有行级锁，在下文列出了行级锁以及在哪些情境下<span class="productname">PostgreSQL</span>会自动使用它们。行级锁的完整冲突表请见<a class="xref" href="explicit-locking.html#ROW-LOCK-COMPATIBILITY" title="表 13.3. 冲突的行级锁">表 13.3</a>。注意一个事务可能会在相同的行上保持冲突的锁，甚至是在不同的子事务中。但是除此之外，两个事务永远不可能在相同的行上持有冲突的锁。行级锁不影响数据查询，它们只阻塞对同一行的<span class="emphasis"><em>写入者和加锁者</em></span>。
    </p><div class="variablelist"><p class="title"><strong>行级锁模式</strong></p><dl class="variablelist"><dt><span class="term">
        <code class="literal">FOR UPDATE</code>
       </span></dt><dd><p>
         <code class="literal">FOR UPDATE</code>会导致由<code class="command">SELECT</code>语句检索到的行被锁定，就好像它们要被更新。这可以阻止它们被其他事务锁定、修改或者删除，一直到当前事务结束。也就是说其他尝试<code class="command">UPDATE</code>、<code class="command">DELETE</code>、<code class="command">SELECT FOR UPDATE</code>、<code class="command">SELECT FOR NO KEY UPDATE</code>、<code class="command">SELECT FOR SHARE</code>或者<code class="command">SELECT FOR KEY SHARE</code>这些行的事务将被阻塞，直到当前事务结束。反过来，<code class="command">SELECT FOR UPDATE</code>将等待已经在相同行上运行以上这些命令的并发事务，并且接着锁定并且返回被更新的行（或者没有行，因为行可能已被删除）。不过，在一个<code class="literal">REPEATABLE READ</code>或<code class="literal">SERIALIZABLE</code>事务中，如果一个要被锁定的行在事务开始后被更改，将会抛出一个错误。进一步的讨论请见<a class="xref" href="applevel-consistency.html" title="13.4. 应用级别的数据完整性检查">第 13.4 节</a>。
        </p><p>        
         任何在一行上的<code class="command">DELETE</code>命令也会获得<code class="literal">FOR UPDATE</code>锁模式，在某些列上修改值的<code class="command">UPDATE</code>也会获得该锁模式。当前<code class="command">UPDATE</code>情况中被考虑的列集合是那些具有能用于外键的唯一索引的列（所以部分索引和表达式索引不被考虑），但是这种要求未来有可能会改变。
        </p></dd><dt><span class="term">
        <code class="literal">FOR NO KEY UPDATE</code>
       </span></dt><dd><p>
         行为与<code class="literal">FOR UPDATE</code>类似，不过获得的锁较弱：这种锁将不会阻塞尝试在相同行上获得锁的<code class="literal">SELECT FOR KEY SHARE</code>命令。任何不获取<code class="literal">FOR UPDATE</code>锁的<code class="command">UPDATE</code>也会获得这种锁模式。
        </p></dd><dt><span class="term">
        <code class="literal">FOR SHARE</code>
       </span></dt><dd><p>
         行为与<code class="literal">FOR NO KEY UPDATE</code>类似，不过它在每个检索到的行上获得一个共享锁而不是排他锁。一个共享锁会阻塞其他事务在这些行上执行<code class="command">UPDATE</code>、<code class="command">DELETE</code>、<code class="command">SELECT FOR UPDATE</code>或者<code class="command">SELECT FOR NO KEY UPDATE</code>，但是它不会阻止它们执行<code class="command">SELECT FOR SHARE</code>或者<code class="command">SELECT FOR KEY SHARE</code>。
        </p></dd><dt><span class="term">
        <code class="literal">FOR KEY SHARE</code>
       </span></dt><dd><p>
         行为与<code class="literal">FOR SHARE</code>类似，不过锁较弱：<code class="literal">SELECT FOR UPDATE</code>会被阻塞，但是<code class="literal">SELECT FOR NO KEY UPDATE</code>不会被阻塞。一个键共享锁会阻塞其他事务执行修改键值的<code class="command">DELETE</code>或者<code class="command">UPDATE</code>，但不会阻塞其他<code class="command">UPDATE</code>，也不会阻止<code class="command">SELECT FOR NO KEY UPDATE</code>、<code class="command">SELECT FOR SHARE</code>或者<code class="command">SELECT FOR KEY SHARE</code>。
        </p></dd></dl></div><p>
     <span class="productname">PostgreSQL</span>不会在内存里保存任何关于已修改行的信息，因此对一次锁定的行数没有限制。 不过，锁住一行会导致一次磁盘写，例如， <code class="command">SELECT FOR UPDATE</code>将修改选中的行以标记它们被锁住，并且因此会导致磁盘写入。
    </p><div class="table" id="ROW-LOCK-COMPATIBILITY"><p class="title"><strong>表 13.3. 冲突的行级锁</strong></p><div class="table-contents"><table class="table" summary="冲突的行级锁" border="1"><colgroup><col /><col class="lockst" /><col /><col /><col class="lockend" /></colgroup><thead><tr><th rowspan="2">要求的锁模式</th><th colspan="4">当前的锁模式</th></tr><tr><th>FOR KEY SHARE</th><th>FOR SHARE</th><th>FOR NO KEY UPDATE</th><th>FOR UPDATE</th></tr></thead><tbody><tr><td>FOR KEY SHARE</td><td align="center"> </td><td align="center"> </td><td align="center"> </td><td align="center">X</td></tr><tr><td>FOR SHARE</td><td align="center"> </td><td align="center"> </td><td align="center">X</td><td align="center">X</td></tr><tr><td>FOR NO KEY UPDATE</td><td align="center"> </td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr><tr><td>FOR UPDATE</td><td align="center">X</td><td align="center">X</td><td align="center">X</td><td align="center">X</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="LOCKING-PAGES"><div class="titlepage"><div><div><h3 class="title">13.3.3. 页级锁</h3></div></div></div><p>
     除了表级别和行级别的锁以外，页面级别的共享/排他锁被用来控制对共享缓冲池中表页面的读/写。 这些锁在行被抓取或者更新后马上被释放。应用开发者通常不需要关心页级锁，我们在这里提到它们只是为了完整。
    </p></div><div class="sect2" id="LOCKING-DEADLOCKS"><div class="titlepage"><div><div><h3 class="title">13.3.4. 死锁</h3></div></div></div><a id="id-1.5.12.6.8.2" class="indexterm"></a><p>
     显式锁定的使用可能会增加<em class="firstterm">死锁</em>的可能性，死锁是指两个（或多个）事务相互持有对方想要的锁。例如，如果事务 1 在表 A 上获得一个排他锁，同时试图获取一个在表 B 上的排他锁， 而事务 2 已经持有表 B 的排他锁，同时却正在请求表 A 上的一个排他锁，那么两个事务就都不能进行下去。<span class="productname">PostgreSQL</span>能够自动检测到死锁情况并且会通过中断其中一个事务从而允许其它事务完成来解决这个问题（具体哪个事务会被中断是很难预测的，而且也不应该依靠这样的预测）。
    </p><p>
     要注意死锁也可能会作为行级锁的结果而发生（并且因此，它们即使在没有使用显式锁定的情况下也会发生)。考虑如下情况，两个并发事务在修改一个表。第一个事务执行：

</p><pre class="screen">
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 11111;
</pre><p>

     这样就在指定帐号的行上获得了一个行级锁。然后，第二个事务执行：

</p><pre class="screen">
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 22222;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 11111;
</pre><p>

     第一个<code class="command">UPDATE</code>语句成功地在指定行上获得了一个行级锁，因此它成功更新了该行。 但是第二个<code class="command">UPDATE</code>语句发现它试图更新的行已经被锁住了，因此它等待持有该锁的事务结束。事务二现在就在等待事务一结束，然后再继续执行。现在，事务一执行：

</p><pre class="screen">
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 22222;
</pre><p>

     事务一试图在指定行上获得一个行级锁，但是它得不到：事务二已经持有了这样的锁。所以它要等待事务二完成。因此，事务一被事务二阻塞，而事务二也被事务一阻塞：一个死锁。 <span class="productname">PostgreSQL</span>将检测这样的情况并中断其中一个事务。
    </p><p>
     防止死锁的最好方法通常是保证所有使用一个数据库的应用都以一致的顺序在多个对象上获得锁。在上面的例子里，如果两个事务以同样的顺序更新那些行，那么就不会发生死锁。 我们也应该保证一个事务中在一个对象上获得的第一个锁是该对象需要的最严格的锁模式。如果我们无法提前验证这些，那么可以通过重试因死锁而中断的事务来即时处理死锁。
    </p><p>
     只要没有检测到死锁情况，寻求一个表级或行级锁的事务将无限等待冲突锁被释放。这意味着一个应用长时间保持事务开启不是什么好事（例如等待用户输入）。
    </p></div><div class="sect2" id="ADVISORY-LOCKS"><div class="titlepage"><div><div><h3 class="title">13.3.5. 咨询锁</h3></div></div></div><a id="id-1.5.12.6.9.2" class="indexterm"></a><a id="id-1.5.12.6.9.3" class="indexterm"></a><p>
     <span class="productname">PostgreSQL</span>提供了一种方法创建由应用定义其含义的锁。这种锁被称为<em class="firstterm">咨询锁</em>，因为系统并不强迫其使用 — 而是由应用来保证其正确的使用。咨询锁可用于 MVCC 模型不适用的锁定策略。例如，咨询锁的一种常用用法是模拟所谓<span class="quote">“<span class="quote">平面文件</span>”</span>数据管理系统典型的悲观锁策略。虽然一个存储在表中的标志可以被用于相同目的，但咨询锁更快、可以避免表膨胀并且会由服务器在会话结束时自动清理。
    </p><p>
     有两种方法在<span class="productname">PostgreSQL</span>中获取一个咨询锁：在会话级别或在事务级别。一旦在会话级别获得了咨询锁，它将被保持直到被显式释放或会话结束。不同于标准锁请求，会话级咨询锁请求不尊重事务语义：在一个后来被回滚的事务中得到的锁在回滚后仍然被保持，并且同样即使调用它的事务后来失败一个解锁也是有效的。一个锁在它所属的进程中可以被获取多次；对于每一个完成的锁请求必须有一个相应的解锁请求，直至锁被真正释放。在另一方面，事务级锁请求的行为更像普通锁请求：在事务结束时会自动释放它们，并且没有显式的解锁操作。这种行为通常比会话级别的行为更方便，因为它使用一个咨询锁的时间更短。对于同一咨询锁标识符的会话级别和事务级别的锁请求按照期望将彼此阻塞。如果一个会话已经持有了一个给定的咨询锁，由它发出的附加请求将总是成功，即使有其他会话在等待该锁；不管现有的锁和新请求是处在会话级别还是事务级别，这种说法都是真的。
    </p><p>
     和所有<span class="productname">PostgreSQL</span>中的锁一样，当前被任何会话所持有的咨询锁的完整列表可以在<a class="link" href="view-pg-locks.html" title="51.74. pg_locks"><code class="structname">pg_locks</code></a>系统视图中找到。
    </p><p>
     咨询锁和普通锁都被存储在一个共享内存池中，它的尺寸由<a class="xref" href="runtime-config-locks.html#GUC-MAX-LOCKS-PER-TRANSACTION">max_locks_per_transaction</a>和<a class="xref" href="runtime-config-connection.html#GUC-MAX-CONNECTIONS">max_connections</a>配置变量定义。 必须当心不要耗尽这些内存，否则服务器将不能再授予任何锁。这对服务器可以授予的咨询锁数量设置了一个上限，根据服务器的配置不同，这个限制通常是数万到数十万。
    </p><p>
     在使用咨询锁方法的特定情况下，特别是查询中涉及显式排序和<code class="literal">LIMIT</code>子句时，由于 SQL 表达式被计算的顺序，必须小心控制锁的获取。例如：
</p><pre class="screen">
SELECT pg_advisory_lock(id) FROM foo WHERE id = 12345; -- ok
SELECT pg_advisory_lock(id) FROM foo WHERE id &gt; 12345 LIMIT 100; -- danger!
SELECT pg_advisory_lock(q.id) FROM
(
  SELECT id FROM foo WHERE id &gt; 12345 LIMIT 100
) q; -- ok
</pre><p>
     在上述查询中，第二种形式是危险的，因为不能保证在锁定函数被执行之前应用<code class="literal">LIMIT</code>。这可能导致获得某些应用不期望的锁，并因此在会话结束之前无法释放。 从应用的角度来看，这样的锁将被挂起，虽然它们仍然在<code class="structname">pg_locks</code>中可见。
    </p><p>
     提供的操作咨询锁函数在<a class="xref" href="functions-admin.html#FUNCTIONS-ADVISORY-LOCKS" title="9.26.10. 咨询锁函数">第 9.26.10 节</a>中描述。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="transaction-iso.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="mvcc.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="applevel-consistency.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">13.2. 事务隔离 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 13.4. 应用级别的数据完整性检查</td></tr></table></div></body></html>