<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>25.2. 文件系统级别备份</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="backup-dump.html" title="25.1. SQL转储" /><link rel="next" href="continuous-archiving.html" title="25.3. 连续归档和时间点恢复（PITR）" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">25.2. 文件系统级别备份</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="backup-dump.html" title="25.1. SQL转储">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="backup.html" title="第 25 章 备份和恢复">上一级</a></td><th width="60%" align="center">第 25 章 备份和恢复</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="continuous-archiving.html" title="25.3. 连续归档和时间点恢复（PITR）">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="BACKUP-FILE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">25.2. 文件系统级别备份</h2></div></div></div><p>
   另外一种备份策略是直接复制<span class="productname">PostgreSQL</span>用于存储数据库中数据的文件，<a class="xref" href="creating-cluster.html" title="18.2. 创建一个数据库集簇">第 18.2 节</a>解释了这些文件的位置。你可以采用任何你喜欢的方式进行文件系统备份，例如：

</p><pre class="programlisting">
tar -cf backup.tar /usr/local/pgsql/data
</pre><p>
  </p><p>
   但是这种方法有两个限制，使得这种方法不实用，或者说至少比<span class="application">pg_dump</span>方法差：

   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
      为了得到一个可用的备份，数据库服务器<span class="emphasis"><em>必须</em></span>被关闭。例如阻止所有连接的半路措施是<span class="emphasis"><em>不起作用</em></span>的（部分原因是<code class="command">tar</code>和类似工具无法得到文件系统状态的一个原子的快照，还有服务器内部缓冲的原因）。关于停止服务器的信息可以在<a class="xref" href="server-shutdown.html" title="18.5. 关闭服务器">第 18.5 节</a>中找到。不用说，在恢复数据之前你也需要关闭服务器。
     </p></li><li class="listitem"><p>
      如果你已经深入地了解了数据库的文件系统布局的细节，你可能会有兴趣尝试通过相应的文件或目录来备份或恢复特定的表或数据库。这种方法也<span class="emphasis"><em>不会</em></span>起作用，因为包含在这些文件中的信息只有配合提交日志文件（<code class="filename">pg_xact/*</code>）才有用，提交日志文件包含了所有事务的提交状态。一个表文件只有和这些信息一起才有用。当然也不可能只恢复一个表及相关的<code class="filename">pg_xact</code>数据，因为这会导致数据库集簇中所有其他表变得无用。因此文件系统备份值适合于完整地备份或恢复整个数据库集簇。
     </p></li></ol></div><p>
  </p><p>
   另一种文件系统备份方法是创建一个数据目录的<span class="quote">“<span class="quote">一致快照</span>”</span>，如果文件系统支持此功能（并且你相信它的实现正确）。典型的过程是创建一个包含数据库的卷的<span class="quote">“<span class="quote">冻结快照</span>”</span>，然后从该快照复制整个数据目录（如上，不能是部分复制）到备份设备，最后释放冻结快照。即使在数据库服务器运行时，这种方式也有效。但是，以这种方式创建的备份保存的文件看起来就像数据库没有被正确关闭时的状态。因此，当你从备份数据上启动数据库服务器时，它会认为上一次的服务器实例崩溃了并尝试重放WAL日志。这不是问题，只是需要注意（当然WAL文件必须要包括在备份中）。你可以在拍摄快照之前执行一次<code class="command">CHECKPOINT</code>以便节省恢复时间。
  </p><p>
   如果你的数据库跨越多个文件系统，可能没有任何方式可以对所有卷获得完全同步的冻结快照。例如，如果你的数据文件和WAL日志放置在不同的磁盘上，或者表空间在不同的文件系统中，可能没有办法使用快照备份，因为快照<span class="emphasis"><em>必须</em></span>是同步的。在这些情况下，一定要仔细阅读你的文件系统文档以了解其对一致快照技术的支持。
  </p><p>
   如果没有可能获得同步快照，一种选择是将数据库服务器关闭足够长的时间以建立所有的冻结快照。另一种选择是执行一次连续归档基础备份（<a class="xref" href="continuous-archiving.html#BACKUP-BASE-BACKUP" title="25.3.2.  制作一个基础备份">第 25.3.2 节</a>），因为这种备份对于备份期间发生的文件系统改变是免疫的。这要求在备份过程中允许连续归档，恢复时使用连续归档恢复（<a class="xref" href="continuous-archiving.html#BACKUP-PITR-RECOVERY" title="25.3.4. 使用一个连续归档备份进行恢复">第 25.3.4 节</a>）。
  </p><p>
   还有一种选择是使用<span class="application">rsync</span>来执行一次文件系统备份。其做法是先在数据库服务器运行时执行<span class="application">rsync</span>，然后关闭数据库服务器足够长时间来做一次<code class="command">rsync --checksum</code>
（<code class="option">--checksum</code>是必需的，因为<code class="command">rsync</code>的文件修改
时间粒度只能精确到秒）。第二次<span class="application">rsync</span>会比第一次快，因为它只需要传送相对很少的数据，由于服务器是停止的，所以最终结果将是一致的。这种方法允许在最小停机时间内执行一次文件系统备份。
  </p><p>
   注意一个文件系统备份通常会比一个SQL转储体积更大（例如<span class="application">pg_dump</span>不需要转储索引的内容，而是转储用于重建索引的命令）。但是，做一次文件系统备份可能更快。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="backup-dump.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="backup.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="continuous-archiving.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">25.1. <acronym class="acronym">SQL</acronym>转储 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 25.3. 连续归档和时间点恢复（PITR）</td></tr></table></div></body></html>