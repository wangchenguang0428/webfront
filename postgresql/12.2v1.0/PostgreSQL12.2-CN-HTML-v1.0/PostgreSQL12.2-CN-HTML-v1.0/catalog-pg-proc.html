<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>51.39. pg_proc</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="catalog-pg-policy.html" title="51.38. pg_policy" /><link rel="next" href="catalog-pg-publication.html" title="51.40. pg_publication" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">51.39. <code xmlns="http://www.w3.org/1999/xhtml" class="structname">pg_proc</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="catalog-pg-policy.html" title="51.38. pg_policy">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="catalogs.html" title="第 51 章 系统目录">上一级</a></td><th width="60%" align="center">第 51 章 系统目录</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="catalog-pg-publication.html" title="51.40. pg_publication">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="CATALOG-PG-PROC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">51.39. <code class="structname">pg_proc</code></h2></div></div></div><a id="id-1.10.4.41.2" class="indexterm"></a><p>
   目录<code class="structname">pg_proc</code>存放有关函数、过程、聚集函数以及窗口函数（共称为例程）的信息。更多信息请参考<a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>、<a class="xref" href="sql-createprocedure.html" title="CREATE PROCEDURE"><span class="refentrytitle">CREATE PROCEDURE</span></a>和<a class="xref" href="xfunc.html" title="37.3. 用户定义的函数">第 37.3 节</a>。
  </p><p>
   如果<code class="structfield">proisagg</code>为真，则该项是一个聚集函数，在<code class="structfield">pg_aggregate</code>中应该有一个相匹配的行。
  </p><div class="table" id="id-1.10.4.41.5"><p class="title"><strong>表 51.39. <code class="structname">pg_proc</code>的列</strong></p><div class="table-contents"><table class="table" summary="pg_proc的列" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>类型</th><th>引用</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">oid</code></td><td><code class="type">oid</code></td><td> </td><td>行标识符</td></tr><tr><td><code class="structfield">proname</code></td><td><code class="type">name</code></td><td> </td><td>函数的名字</td></tr><tr><td><code class="structfield">pronamespace</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-namespace.html" title="51.32. pg_namespace"><code class="structname">pg_namespace</code></a>.oid</code></td><td>
       函数所属的名字空间的OID
      </td></tr><tr><td><code class="structfield">proowner</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-authid.html" title="51.8. pg_authid"><code class="structname">pg_authid</code></a>.oid</code></td><td>函数的拥有者</td></tr><tr><td><code class="structfield">prolang</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-language.html" title="51.29. pg_language"><code class="structname">pg_language</code></a>.oid</code></td><td>实现语言或该函数的调用接口</td></tr><tr><td><code class="structfield">procost</code></td><td><code class="type">float4</code></td><td> </td><td>估计的执行代价（以<a class="xref" href="runtime-config-query.html#GUC-CPU-OPERATOR-COST">cpu_operator_cost</a>为单位），如果<code class="structfield">proretset</code>为真，这是每行返回的代价</td></tr><tr><td><code class="structfield">prorows</code></td><td><code class="type">float4</code></td><td> </td><td>估计的结果行数量（如果<code class="structfield">proretset</code>为假，该值为0）</td></tr><tr><td><code class="structfield">provariadic</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-type.html" title="51.63. pg_type"><code class="structname">pg_type</code></a>.oid</code></td><td>可变数组参数的元素的数据类型，如果函数没有可变参数则为0</td></tr><tr><td><code class="structfield">prosupport</code></td><td><code class="type">regproc</code></td><td><code class="literal"><a class="link" href="catalog-pg-proc.html" title="51.39. pg_proc"><code class="structname">pg_proc</code></a>.oid</code></td><td>对于该函数可选的计划器支持函数（见<a class="xref" href="xfunc-optimization.html" title="37.11. 函数优化信息">第 37.11 节</a>）</td></tr><tr><td><code class="structfield">prokind</code></td><td><code class="type">char</code></td><td> </td><td><code class="literal">f</code>表示普通函数，<code class="literal">p</code>表示过程，<code class="literal">a</code>表示聚集函数，<code class="literal">w</code>表示窗口函数</td></tr><tr><td><code class="structfield">prosecdef</code></td><td><code class="type">bool</code></td><td> </td><td>函数是一个安全性定义者（即，一个<span class="quote">“<span class="quote">setuid</span>”</span>函数）</td></tr><tr><td><code class="structfield">proleakproof</code></td><td><code class="type">bool</code></td><td> </td><td>
       该函数没有副作用。除了通过返回值，没有关于参数的信息被传播。任何会抛出基于其参数值的错误信息的函数都不是泄露验证的。
      </td></tr><tr><td><code class="structfield">proisstrict</code></td><td><code class="type">bool</code></td><td> </td><td>
       当任意调用函数为空时，函数是否会返回空值。在那种情况下函数实际上根本不会被调用。非<span class="quote">“<span class="quote">strict</span>”</span>函数必须准备好处理空值输入。
      </td></tr><tr><td><code class="structfield">proretset</code></td><td><code class="type">bool</code></td><td> </td><td>函数是否返回一个集合（即，指定数据类型的多个值）</td></tr><tr><td><code class="structfield">provolatile</code></td><td><code class="type">char</code></td><td> </td><td>
       <code class="structfield">provolatile</code>说明函数是仅仅只依赖于它的输入参数，还是会被外部因素影响。值<code class="literal">i</code>表示<span class="quote">“<span class="quote">不变的</span>”</span>函数，它对于相同的输入总是输出相同的结果。值<code class="literal">s</code>表示<span class="quote">“<span class="quote">稳定的</span>”</span>函数，它的结果（对于固定输入）在一次扫描内不会变化。值<code class="literal">v</code>表示<span class="quote">“<span class="quote">不稳定的</span>”</span>函数，它的结果在任何时候都可能变化（使用<code class="literal">v</code>页表示函数具有副作用，所以对它们的调用无法得到优化）
      </td></tr><tr><td><code class="structfield">proparallel</code></td><td><code class="type">char</code></td><td> </td><td>
       <code class="structfield">proparallel</code>说明该函数在并行模式下是否能安全地运行。对于能在并行模式下不受限制安全运行的函数，这列是<code class="literal">s</code>。对于可以在并行模式下运行但是只限于由并行分组的领导者执行的函数，这列是<code class="literal">r</code>。对于在并行模式中不安全的函数，这列是<code class="literal">u</code>，这种函数的存在会强制一个顺序执行计划。
      </td></tr><tr><td><code class="structfield">pronargs</code></td><td><code class="type">int2</code></td><td> </td><td>输入参数的个数</td></tr><tr><td><code class="structfield">pronargdefaults</code></td><td><code class="type">int2</code></td><td> </td><td>具有默认值的参数个数</td></tr><tr><td><code class="structfield">prorettype</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-type.html" title="51.63. pg_type"><code class="structname">pg_type</code></a>.oid</code></td><td>返回值的数据类型</td></tr><tr><td><code class="structfield">proargtypes</code></td><td><code class="type">oidvector</code></td><td><code class="literal"><a class="link" href="catalog-pg-type.html" title="51.63. pg_type"><code class="structname">pg_type</code></a>.oid</code></td><td>
       一个函数参数的数据类型的数组。这只包括输入参数（含<code class="literal">INOUT</code>和<code class="literal">VARIADIC</code>参数），因此也表现了函数的调用特征。
      </td></tr><tr><td><code class="structfield">proallargtypes</code></td><td><code class="type">oid[]</code></td><td><code class="literal"><a class="link" href="catalog-pg-type.html" title="51.63. pg_type"><code class="structname">pg_type</code></a>.oid</code></td><td>
       一个函数参数的数据类型的数组。这包括所有参数（含<code class="literal">OUT</code>和<code class="literal">INOUT</code>参数）。但是，如果所有参数都是<code class="literal">IN</code>参数，这个域将为空。注意下标是从1开始 ，然而由于历史原因<code class="structfield">proargtypes</code>的下标是从0开始。
      </td></tr><tr><td><code class="structfield">proargmodes</code></td><td><code class="type">char[]</code></td><td> </td><td>
        一个函数参数的模式的数组。编码为：
        <code class="literal">i</code>表示<code class="literal">IN</code>参数 ，
        <code class="literal">o</code>表示<code class="literal">OUT</code>参数，
        <code class="literal">b</code>表示<code class="literal">INOUT</code>参数，
        <code class="literal">v</code>表示<code class="literal">VARIADIC</code>参数，
        <code class="literal">t</code>表示<code class="literal">TABLE</code>参数。
        如果所有的参数都是<code class="literal">IN</code>参数，这个域为空。注意这里的下标对应着<code class="structfield">proallargtypes</code>而不是<code class="structfield">proargtypes</code>中的位置。
      </td></tr><tr><td><code class="structfield">proargnames</code></td><td><code class="type">text[]</code></td><td> </td><td>
        一个函数参数的名字的数组。没有名字的参数在数组中设置为空字符串。如果没有一个参数有名字，这个域为空。注意这里的下标对应着<code class="structfield">proallargtypes</code>而不是<code class="structfield">proargtypes</code>中的位置。
      </td></tr><tr><td><code class="structfield">proargdefaults</code></td><td><code class="type">pg_node_tree</code></td><td> </td><td>
       默认值的表达式树（按照<code class="function">nodeToString()</code>的表现方式）。这是一个<code class="structfield">pronargdefaults</code>元素的列表，对应于最后<em class="replaceable"><code>N</code></em>个<span class="emphasis"><em>input</em></span>参数（即最后<em class="replaceable"><code>N</code></em>个<code class="structfield">proargtypes</code>位置）。如果没有一个参数具有默认值，这个域为空。
      </td></tr><tr><td><code class="structfield">protrftypes</code></td><td><code class="type">oid[]</code></td><td> </td><td>
       要在其上应用转换的数据类型的 OID。
      </td></tr><tr><td><code class="structfield">prosrc</code></td><td><code class="type">text</code></td><td> </td><td>
       这个域告诉函数处理者如何调用该函数。它可能是针对解释型语言的真实源码、一个符号链接、一个文件名或任何其他东西，这取决于实现语言/调用规范。
      </td></tr><tr><td><code class="structfield">probin</code></td><td><code class="type">text</code></td><td> </td><td>
       关于如何调用函数的附加信息。其解释是与语言相关的。
      </td></tr><tr><td><code class="structfield">proconfig</code></td><td><code class="type">text[]</code></td><td> </td><td>函数对于运行时配置变量的本地设置值</td></tr><tr><td><code class="structfield">proacl</code></td><td><code class="type">aclitem[]</code></td><td> </td><td>
       访问权限，详见<a class="xref" href="ddl-priv.html" title="5.7. 权限">第 5.7 节</a>
      </td></tr></tbody></table></div></div><br class="table-break" /><p>
   对于编译好的函数，包括内建的和动态载入的，<code class="structfield">prosrc</code>包含了函数的C语言名字（链接符号）。对于所有其他已知的语言类型，<code class="structfield">prosrc</code>包含函数的源码文本。除了对于动态载入的C函数之外，<code class="structfield">probin</code>是不被使用的。对于动态载入的C函数，它给定了包含该函数的共享库文件的名称。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="catalog-pg-policy.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="catalogs.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="catalog-pg-publication.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">51.38. <code class="structname">pg_policy</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 51.40. <code class="structname">pg_publication</code></td></tr></table></div></body></html>