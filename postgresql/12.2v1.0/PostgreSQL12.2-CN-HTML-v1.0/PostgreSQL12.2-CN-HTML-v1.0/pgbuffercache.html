<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.24. pg_buffercache</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="passwordcheck.html" title="F.23. passwordcheck" /><link rel="next" href="pgcrypto.html" title="F.25. pgcrypto" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.24. pg_buffercache</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="passwordcheck.html" title="F.23. passwordcheck">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="附录 F. 额外提供的模块">上一级</a></td><th width="60%" align="center">附录 F. 额外提供的模块</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="pgcrypto.html" title="F.25. pgcrypto">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="PGBUFFERCACHE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.24. pg_buffercache</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="pgbuffercache.html#id-1.11.7.33.7">F.24.1. <code class="structname">pg_buffercache</code>视图</a></span></dt><dt><span class="sect2"><a href="pgbuffercache.html#id-1.11.7.33.8">F.24.2. 样例输出</a></span></dt><dt><span class="sect2"><a href="pgbuffercache.html#id-1.11.7.33.9">F.24.3. 作者</a></span></dt></dl></div><a id="id-1.11.7.33.2" class="indexterm"></a><p>
  <code class="filename">pg_buffercache</code>模块提供了一种方法实时检查共享缓冲区。
 </p><a id="id-1.11.7.33.4" class="indexterm"></a><p>
  该模块提供了一个 C 函数<code class="function">pg_buffercache_pages</code>，它返回一个记录的集合，外加一个包装了该函数以便于使用的视图<code class="structname">pg_buffercache</code>。
 </p><p>
  默认情况下，使用仅限于超级用户和<code class="literal">pg_read_all_stats</code>
  角色的成员。可以使用<code class="command">GRANT</code>给其他人授予访问权限。
 </p><div class="sect2" id="id-1.11.7.33.7"><div class="titlepage"><div><div><h3 class="title">F.24.1. <code class="structname">pg_buffercache</code>视图</h3></div></div></div><p>
   视图显示的列的定义如<a class="xref" href="pgbuffercache.html#PGBUFFERCACHE-COLUMNS" title="表 F.15. pg_buffercache 列">表 F.15</a>所示。
  </p><div class="table" id="PGBUFFERCACHE-COLUMNS"><p class="title"><strong>表 F.15. <code class="structname">pg_buffercache</code> 列</strong></p><div class="table-contents"><table class="table" summary="pg_buffercache 列" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>类型</th><th>引用</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">bufferid</code></td><td><code class="type">integer</code></td><td> </td><td>ID，在范围 1..<code class="varname">shared_buffers</code>中</td></tr><tr><td><code class="structfield">relfilenode</code></td><td><code class="type">oid</code></td><td><code class="literal">pg_class.relfilenode</code></td><td>关系的文件结点编号</td></tr><tr><td><code class="structfield">reltablespace</code></td><td><code class="type">oid</code></td><td><code class="literal">pg_tablespace.oid</code></td><td>关系的表空间 OID</td></tr><tr><td><code class="structfield">reldatabase</code></td><td><code class="type">oid</code></td><td><code class="literal">pg_database.oid</code></td><td>关系的数据库 OID</td></tr><tr><td><code class="structfield">relforknumber</code></td><td><code class="type">smallint</code></td><td> </td><td>关系内的分叉数，见<code class="filename">include/common/relpath.h</code></td></tr><tr><td><code class="structfield">relblocknumber</code></td><td><code class="type">bigint</code></td><td> </td><td>关系内的页面数</td></tr><tr><td><code class="structfield">isdirty</code></td><td><code class="type">boolean</code></td><td> </td><td>页面是否为脏？</td></tr><tr><td><code class="structfield">usagecount</code></td><td><code class="type">smallint</code></td><td> </td><td>Clock-sweep 访问计数</td></tr><tr><td><code class="structfield">pinning_backends</code></td><td><code class="type">integer</code></td><td> </td><td>对这个缓冲区加 pin 的后端数量</td></tr></tbody></table></div></div><br class="table-break" /><p>
   共享缓存中的每一个缓冲区都有一行。没有使用的缓冲区的行中只有<code class="structfield">bufferid</code>为非空。共享的系统目录被显示为属于数据库零。
  </p><p>
   因为缓冲是所有数据库共享的，通常会有不属于当前数据库的关系的页面。这意味着对于一些行在<code class="structname">pg_class</code>中可能不会有匹配的连接行，或者甚至有错误的连接。如果你试图与<code class="structname">pg_class</code>连接，将连接限制于<code class="structfield">reldatabase</code>等于当前数据库 OID 或零的行是一个好主意。
  </p><p>
   当访问<code class="structname">pg_buffercache</code>视图时，内部缓冲区管理器会被锁住足够长时间来拷贝视图将显示的所有缓冲区状态数据。这确保了该视图会产生一个一致的结果集合，而不会不必要地长时间阻塞普通的缓冲区活动。尽管如此，如果经常读取这个视图还是会对数据库性能产生一些影响。
  </p></div><div class="sect2" id="id-1.11.7.33.8"><div class="titlepage"><div><div><h3 class="title">F.24.2. 样例输出</h3></div></div></div><pre class="screen">
regression=# SELECT c.relname, count(*) AS buffers
             FROM pg_buffercache b INNER JOIN pg_class c
             ON b.relfilenode = pg_relation_filenode(c.oid) AND
                b.reldatabase IN (0, (SELECT oid FROM pg_database
                                      WHERE datname = current_database()))
             GROUP BY c.relname
             ORDER BY 2 DESC
             LIMIT 10;

             relname             | buffers
---------------------------------+---------
 tenk2                           |     345
 tenk1                           |     141
 pg_proc                         |      46
 pg_class                        |      45
 pg_attribute                    |      43
 pg_class_relname_nsp_index      |      30
 pg_proc_proname_args_nsp_index  |      28
 pg_attribute_relid_attnam_index |      26
 pg_depend                       |      22
 pg_depend_reference_index       |      20
(10 rows)
</pre></div><div class="sect2" id="id-1.11.7.33.9"><div class="titlepage"><div><div><h3 class="title">F.24.3. 作者</h3></div></div></div><p>
   Mark Kirkwood <code class="email">&lt;<a class="email" href="mailto:markir@paradise.net.nz">markir@paradise.net.nz</a>&gt;</code>
  </p><p>
   设计建议： Neil Conway <code class="email">&lt;<a class="email" href="mailto:neilc@samurai.com">neilc@samurai.com</a>&gt;</code>
  </p><p>
   调试建议： Tom Lane <code class="email">&lt;<a class="email" href="mailto:tgl@sss.pgh.pa.us">tgl@sss.pgh.pa.us</a>&gt;</code>
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="passwordcheck.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="pgcrypto.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">F.23. passwordcheck </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> F.25. pgcrypto</td></tr></table></div></body></html>