<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>56.5. 外部数据包装器中的行锁定</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="fdw-planning.html" title="56.4. 外部数据包装器查询规划" /><link rel="next" href="tablesample-method.html" title="第 57 章 编写一种表采样方法" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">56.5. 外部数据包装器中的行锁定</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="fdw-planning.html" title="56.4. 外部数据包装器查询规划">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="fdwhandler.html" title="第 56 章 编写一个外部数据包装器">上一级</a></td><th width="60%" align="center">第 56 章 编写一个外部数据包装器</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="tablesample-method.html" title="第 57 章 编写一种表采样方法">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="FDW-ROW-LOCKING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">56.5. 外部数据包装器中的行锁定</h2></div></div></div><p>
     如果一个 FDW 的底层存储机制具有锁定行的概念来阻止对行的并发更新，通常值得 FDW 去执行行级锁定以尽可能接近在普通<span class="productname">PostgreSQL</span>表中所实际使用的语义。涉及这个问题有多种考虑。
    </p><p>
     要做出的一个关键决定是执行<em class="firstterm">早期锁定</em>还是<em class="firstterm">晚期锁定</em>。在早期锁定中，当一行被第一次从底层存储中检索到时，它会被锁定；而在晚期锁定中，只有当行需要被锁定时才锁定它（由于某些行可能被本地检查的限制或者连接条件抛弃，所以会出现不同）。早期锁定更加简单并且能避免额外地与远程存储交互，但是可能会导致一些不需要锁定的行也被锁定，最终造成并发性下降甚至意外的死锁。还有，只有在要被锁定的行可以在后期唯一地重新标识时才可以用晚期锁定。较好的行标识符应该能标识行的特定版本，就像<span class="productname">PostgreSQL</span> TID 那样。
    </p><p>
     默认情况下，<span class="productname">PostgreSQL</span>在与 FDW 交互时会忽略锁定考虑，但是 FDW 可以在没有核心代码显式支持的情况下执行早期锁定。<a class="xref" href="fdw-callbacks.html#FDW-CALLBACKS-ROW-LOCKING" title="56.2.5. 用于行锁定的 FDW 例程">第 56.2.5 节</a>中描述的 API 函数（在<span class="productname">PostgreSQL</span> 9.5 中加入）允许 FDW 按照意愿使用晚期锁定。
    </p><p>
     一个额外的考虑是在<code class="literal">READ COMMITTED</code>隔离模式中，<span class="productname">PostgreSQL</span>可能需要对某个目标元组的更新版本进行限制以及连接条件的重新检查。重新检查连接条件要求重新获得之前连接成目标元组的非目标行拷贝。在标准<span class="productname">PostgreSQL</span>表的情况下，这可以通过在连接投影出的列列表中包括非目标表的 TID 并且在需要时重新取得非目标行来做到。这种方法可以让连接数据集保持紧凑，但是它要求代价较低的重新取得元组的功能，还有 TID 要能够唯一地标识要被重新取得的行版本。因此，默认情况下用于外部表的方法是将整个外部表元组的拷贝包括在从连接投影出的列列表中。这不会对 FDW 有特殊的要求，但是会导致归并和哈希连接性能下降。要满足重新取得元组需求的 FDW 可以选择第一种方式。
    </p><p>
     对于在外部表上的<code class="command">UPDATE</code>或者<code class="command">DELETE</code>，推荐目标表上的<code class="literal">ForeignScan</code>操作在它取得的行上执行早期锁定（可能通过<code class="command">SELECT FOR UPDATE</code>的等效体）。通过在规划时比较一个表的 relid 和<code class="literal">root-&gt;parse-&gt;resultRelation</code>或在执行时使用<code class="function">ExecRelationIsTargetRelation()</code>，一个 FDW 可以检测该表是否为<code class="command">UPDATE</code>/<code class="command">DELETE</code>的目标。另一种可能性是在<code class="function">ExecForeignUpdate</code>或者<code class="function">ExecForeignDelete</code>回调中执行晚期锁定，但是对此没有特别的支持。
    </p><p>
     对于通过<code class="command">SELECT FOR UPDATE/SHARE</code>命令指定要被锁定的外部表，<code class="literal">ForeignScan</code>操作同样可以通过用<code class="command">SELECT FOR UPDATE/SHARE</code>的等效体取元组来执行早期锁定。要执行晚期锁定，请提供<a class="xref" href="fdw-callbacks.html#FDW-CALLBACKS-ROW-LOCKING" title="56.2.5. 用于行锁定的 FDW 例程">第 56.2.5 节</a>中定义的回调函数。在<code class="function">GetForeignRowMarkType</code>中，根据请求的锁长度来选择行标记选项<code class="literal">ROW_MARK_EXCLUSIVE</code>、<code class="literal">ROW_MARK_NOKEYEXCLUSIVE</code>、<code class="literal">ROW_MARK_SHARE</code>或者<code class="literal">ROW_MARK_KEYSHARE</code>（不管选择哪一种选项，核心代码都会做同样的事情）。在别的地方，可以在规划时用<code class="function">get_plan_rowmark</code>或者在执行时用<code class="function">ExecFindRowMark</code>来检测一个外部表是否被指定由这种类型的命令锁定。你必须不仅仅检测是否返回了一个非空的行标记结构，还要检测它的<code class="structfield">strength</code>域不是<code class="literal">LCS_NONE</code>。
    </p><p>
     最后，对于在<code class="command">UPDATE</code>、<code class="command">DELETE</code>或者<code class="command">SELECT FOR UPDATE/SHARE</code>命令中使用但是没有被指定要行锁定的外部表，你可以在看到锁长度<code class="literal">LCS_NONE</code>时通过使用<code class="function">GetForeignRowMarkType</code>选择选项<code class="literal">ROW_MARK_REFERENCE</code>来把默认选择覆盖为拷贝整个行。 这将导致用那个值作为<code class="structfield">markType</code>来调用<code class="function">RefetchForeignRow</code>。它应该接着重新取得该行而不获取任何新锁（如果你有一个<code class="function">GetForeignRowMarkType</code>函数，但是不想重新取未锁定的行，可为<code class="literal">LCS_NONE</code>选择选项<code class="literal">ROW_MARK_COPY</code>）。
    </p><p>
     更多信息可见<code class="filename">src/include/nodes/lockoptions.h</code>，以及<code class="filename">src/include/nodes/plannodes.h</code>中<code class="type">RowMarkType</code>和<code class="type">PlanRowMark</code>的注释，还有<code class="filename">src/include/nodes/execnodes.h</code>中<code class="type">ExecRowMark</code>的注释。
    </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="fdw-planning.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="fdwhandler.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="tablesample-method.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">56.4. 外部数据包装器查询规划 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 57 章 编写一种表采样方法</td></tr></table></div></body></html>