<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.33. postgres_fdw</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="pgvisibility.html" title="F.32. pg_visibility" /><link rel="next" href="seg.html" title="F.34. seg" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.33. postgres_fdw</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="pgvisibility.html" title="F.32. pg_visibility">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="附录 F. 额外提供的模块">上一级</a></td><th width="60%" align="center">附录 F. 额外提供的模块</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="seg.html" title="F.34. seg">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="POSTGRES-FDW"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.33. postgres_fdw</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="postgres-fdw.html#id-1.11.7.42.10">F.33.1. postgres_fdw 的 FDW 选项</a></span></dt><dt><span class="sect2"><a href="postgres-fdw.html#id-1.11.7.42.11">F.33.2. 连接管理</a></span></dt><dt><span class="sect2"><a href="postgres-fdw.html#id-1.11.7.42.12">F.33.3. 事务管理</a></span></dt><dt><span class="sect2"><a href="postgres-fdw.html#id-1.11.7.42.13">F.33.4. 远程查询优化</a></span></dt><dt><span class="sect2"><a href="postgres-fdw.html#id-1.11.7.42.14">F.33.5. 远程查询执行环境</a></span></dt><dt><span class="sect2"><a href="postgres-fdw.html#id-1.11.7.42.15">F.33.6. 跨版本兼容性</a></span></dt><dt><span class="sect2"><a href="postgres-fdw.html#id-1.11.7.42.16">F.33.7. 例子</a></span></dt><dt><span class="sect2"><a href="postgres-fdw.html#id-1.11.7.42.17">F.33.8. 作者</a></span></dt></dl></div><a id="id-1.11.7.42.2" class="indexterm"></a><p>
  <code class="filename">postgres_fdw</code>模块提供了外部数据包装器<code class="literal">postgres_fdw</code>，它可以被用来访问存储在外部<span class="productname">PostgreSQL</span>服务器中的数据。
 </p><p>
  这个模块提供的功能大体上覆盖了较老的<a class="xref" href="dblink.html" title="F.10. dblink">dblink</a>模块的功能。但是<code class="filename">postgres_fdw</code>提供了更透明且更兼容标准的语法来访问远程表，并且可以在很多情况下给出更好的性能。
 </p><p>
  要使用<code class="filename">postgres_fdw</code>来为远程访问做准备：
  </p><div class="orderedlist"><ol class="orderedlist compact" type="1"><li class="listitem"><p>
     使用<a class="xref" href="sql-createextension.html" title="CREATE EXTENSION"><span class="refentrytitle">CREATE EXTENSION</span></a>来安装<code class="filename">postgres_fdw</code>扩展。
    </p></li><li class="listitem"><p>
     使用<a class="xref" href="sql-createserver.html" title="CREATE SERVER"><span class="refentrytitle">CREATE SERVER</span></a>创建一个外部服务器对象，它用来表示你想连接的每一个远程数据库。指定除了<code class="literal">user</code>和<code class="literal">password</code>之外的连接信息作为该服务器对象的选项。
    </p></li><li class="listitem"><p>
     使用<a class="xref" href="sql-createusermapping.html" title="CREATE USER MAPPING"><span class="refentrytitle">CREATE USER MAPPING</span></a>创建一个用户映射，每一个用户映射都代表你想允许一个数据库用户访问一个外部服务器。指定远程用户名和口令作为用户映射的<code class="literal">user</code>和<code class="literal">password</code>选项。
    </p></li><li class="listitem"><p>
     为每一个你想访问的远程表使用<a class="xref" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE"><span class="refentrytitle">CREATE FOREIGN TABLE</span></a>或者<a class="xref" href="sql-importforeignschema.html" title="IMPORT FOREIGN SCHEMA"><span class="refentrytitle">IMPORT FOREIGN SCHEMA</span></a>创建一个外部表。外部表的列必须匹配被引用的远程表。但是，如果你在外部表对象的选项中指定了正确的远程名称，你可以使用不同于远程表的表名和/或列名。
    </p></li></ol></div><p>
 </p><p>
  现在你只需要从一个外部表<code class="command">SELECT</code>来访问存储在它的底层的远程表中的数据。你也可以使用<code class="command">INSERT</code>、<code class="command">UPDATE</code>或<code class="command">DELETE</code>修改远程表（当然，你在你的用户映射中已经指定的远程用户必须具有做这些事情的权限）。
 </p><p>
  注意当前<code class="filename">postgres_fdw</code>缺少对于带<code class="literal">ON CONFLICT DO UPDATE</code>子句的<code class="command">INSERT</code>语句的支持。不过，它支持<code class="literal">ON CONFLICT DO NOTHING</code>子句，已提供的唯一索引推断说明会被省略。
  另请注意<code class="filename">postgres_fdw</code>支持 <code class="command">UPDATE</code> 语句在分区表上执行的行移动调用，但是它目前不处理这样的情况：选择将移动行插入到的远程分区也是稍后将更新的<code class="command">UPDATE</code>目标分区。
 </p><p>
  我们通常推荐一个外部表的列被声明为与被引用的远程表列完全相同的数据类型和排序规则（如果可用）。尽管<code class="filename">postgres_fdw</code>目前已经能够容忍在需要时执行数据类型转换，但是当类型或排序规则不匹配时可能会发生奇怪的语义异常，因为远程服务器解释<code class="literal">WHERE</code>子句时可能会与本地服务器有所不同。
 </p><p>
  注意一个外部表可以被声明比底层的远程表较少的列，或者使用一种不同的列序。与远程表的列匹配是通过名字而不是位置进行的。
 </p><div class="sect2" id="id-1.11.7.42.10"><div class="titlepage"><div><div><h3 class="title">F.33.1. postgres_fdw 的 FDW 选项</h3></div></div></div><div class="sect3" id="id-1.11.7.42.10.2"><div class="titlepage"><div><div><h4 class="title">F.33.1.1. 连接选项</h4></div></div></div><p>
    一个使用<code class="filename">postgres_fdw</code>外部数据包装器的外部服务器可以使用和<span class="application">libpq</span>在连接字符串中能接受的选项，如<a class="xref" href="libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="33.1.2. 参数关键词">第 33.1.2 节</a>所述，不过不允许这些选项：

    </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
       <code class="literal">user</code>和<code class="literal">password</code>（应该在用户映射中指定这些）
      </p></li><li class="listitem"><p>
       <code class="literal">client_encoding</code>（这是自动从本地服务器编码设置）
      </p></li><li class="listitem"><p>
       <code class="literal">fallback_application_name</code>（总是设置为<code class="literal">postgres_fdw</code>）
      </p></li></ul></div><p>
   </p><p>
    只有超级用户可以在不经过口令认证的情况下连接到外部服务器，因此应总是为属于非超级用户的用户映射指定<code class="literal">password</code>选项。
   </p></div><div class="sect3" id="id-1.11.7.42.10.3"><div class="titlepage"><div><div><h4 class="title">F.33.1.2. 对象名称选项</h4></div></div></div><p>
    这些选项可以被用来控制使用在被发送到远程<span class="productname">PostgreSQL</span>服务器的 SQL 语句中使用的名称。当一个外部表被使用不同于底层远程表的名称创建时，就需要这些选项。
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">schema_name</code></span></dt><dd><p>
       这个选项给出用在远程服务器之上的外部表的模式名称，它可以为一个外部表指定。如果这个选项被忽略，该外部表的模式名称将被使用。
      </p></dd><dt><span class="term"><code class="literal">table_name</code></span></dt><dd><p>
       这个选项给出用在远程服务器上的外部表给出表名，它可以为一个外部表指定。如果这个选项被忽略，该外部表的名字将被使用。
      </p></dd><dt><span class="term"><code class="literal">column_name</code></span></dt><dd><p>
       这个选项给出用在远程服务器上列的列名，它可以为一个外部表的一个列指定。如果这个选项被忽略，该列的名字将被使用。
      </p></dd></dl></div></div><div class="sect3" id="id-1.11.7.42.10.4"><div class="titlepage"><div><div><h4 class="title">F.33.1.3. 代价估计选项</h4></div></div></div><p>
    <code class="filename">postgres_fdw</code>通过在远程服务器上执行查询来检索远程数据，因此理想的扫描一个外部表的估计代价应该是在远程服务器上完成它的花销，外加一些通信开销。得到这样一个估计的最可靠的方法是询问远程服务器并加上一些通信开销 — 但是对于简单查询，不值得为获得一个代价估计而额外使用一次远程查询。因此<code class="filename">postgres_fdw</code>提供了下列选项来控制如何完成代价估计：
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">use_remote_estimate</code></span></dt><dd><p>
       这个选项控制<code class="filename">postgres_fdw</code>是否发出<code class="command">EXPLAIN</code>命令来获得代价估计，它可以为一个外部表或一个外部服务器指定。一个外部表的设置会覆盖它的服务器的任何设置，但是只用于这个表。默认值是<code class="literal">false</code>。
      </p></dd><dt><span class="term"><code class="literal">fdw_startup_cost</code></span></dt><dd><p>
       这个选项是一个要被加到那个服务器上所有外部表扫描的估计启动代价的数字值。这表示建立一个连接、在远端解析和规查询的额外负荷等。默认值是<code class="literal">100</code>。
      </p></dd><dt><span class="term"><code class="literal">fdw_tuple_cost</code></span></dt><dd><p>
       这个选项是一个数字值，它被用作那个服务器上外部表扫描的每元组额外代价，它可以为一个外部服务器指定。这表示在服务器之间数据传输的额外负荷。你可以增加或减少这个数来反映到远程服务器更高或更低的网络延迟。默认值是<code class="literal">0.01</code>。
      </p></dd></dl></div><p>
    当<code class="literal">use_remote_estimate</code>为真时，<code class="filename">postgres_fdw</code>从远程服务器获得行计数和代价估计，然后在代价估计上加上<code class="literal">fdw_startup_cost</code>和<code class="literal">fdw_tuple_cost</code>。当<code class="literal">use_remote_estimate</code>为假时，<code class="filename">postgres_fdw</code>执行本地行计数和代价估计，并且接着在代价估计上加上<code class="literal">fdw_startup_cost</code> 和<code class="literal">fdw_tuple_cost</code>。这种本地估计不会很准确，除非有远程表统计数据的本地拷贝可用。在外部表上运行<a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a>是更新本地统计数据的方法，这将执行远程表的一次扫描并接着计算和存储统计数据，就好像表在本地一样。保留本地统计数据可能是一种有用的方法来减少一个远程表的预查询规划负荷 — 但是如果远程表被频繁更新，本地统计数据将很快就被废弃。
   </p></div><div class="sect3" id="id-1.11.7.42.10.5"><div class="titlepage"><div><div><h4 class="title">F.33.1.4. 远程执行选项</h4></div></div></div><p>
    默认情况下，只有使用了内建操作符和函数的<code class="literal">WHERE</code>子句才会被考虑在远程服务器上执行。涉及非内建函数的子句将会在取完行后在本地进行检查。如果这类函数在远程服务器上可用并且可以用来产生和本地执行时一样的结果，则可以通过将这种<code class="literal">WHERE</code>子句发送到远程执行来提高性能。可以用下面的选项控制这种行为：
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">extensions</code></span></dt><dd><p>
       这个选项是一个用逗号分隔的已安装的<span class="productname">PostgreSQL</span>扩展名称列表，这些扩展在本地和远程服务器上具有兼容的版本。属于一个该列表中扩展的 immutable 函数和操作符将被考虑转移到远程服务器上执行。这个选项只能为外部服务器指定，无法逐个表指定。
      </p><p>
       在使用<code class="literal">extensions</code>选项时，<span class="emphasis"><em>用户应该负责确保</em></span>列出的扩展在本地和远程服务器上都存在且保持一致。否则，远程查询可能失败或者行为异常。
      </p></dd><dt><span class="term"><code class="literal">fetch_size</code></span></dt><dd><p>
       这个选项指定在每次获取行的操作中<code class="filename">postgres_fdw</code>应该得到的行数。可以为一个外部表或者外部服务器指定这个选项。在表上指定的选项将会覆盖在服务器级别上指定的选项。默认值为<code class="literal">100</code>。
      </p></dd></dl></div></div><div class="sect3" id="id-1.11.7.42.10.6"><div class="titlepage"><div><div><h4 class="title">F.33.1.5. 可更新性选项</h4></div></div></div><p>
    默认情况下，所有使用<code class="filename">postgres_fdw</code>的外部表都被假定是可更新的。这可以使用下列选项覆盖：
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">updatable</code></span></dt><dd><p>
       这个选项控制<code class="filename">postgres_fdw</code>是否允许外部表被使用<code class="command">INSERT</code>、<code class="command">UPDATE</code>和<code class="command">DELETE</code>命令更新。它可以为一个外部表或一个外部服务器指定。一个表级选项会覆盖一个服务器级选项。默认值是<code class="literal">true</code>。
      </p><p>
       当然，如果远程表实际上并非可更新的，将产生一个错误。这个选项的使用主要是允许在不查询远程服务器的情况下在本地抛出错误。但是要注意<code class="literal">information_schema</code>视图会根据这个选项的设置报告一个<code class="filename">postgres_fdw</code>外部表是可更新的（或者不可更新），而不需要远程服务器的任何检查。
      </p></dd></dl></div></div><div class="sect3" id="id-1.11.7.42.10.7"><div class="titlepage"><div><div><h4 class="title">F.33.1.6. 导入选项</h4></div></div></div><p>
    <code class="filename">postgres_fdw</code>能使用<a class="xref" href="sql-importforeignschema.html" title="IMPORT FOREIGN SCHEMA"><span class="refentrytitle">IMPORT FOREIGN SCHEMA</span></a>导入外部表定义。这个命令会在本地服务器上创建外部表定义，这个定义能匹配存在于远程服务器上的表或者视图。如果要被导入的远程表有用户自定义数据类型的列，本地服务器上也必须具有相同名称的兼容类型。
   </p><p>
    导入行为可以用下列选项自定义（在<code class="command">IMPORT FOREIGN SCHEMA</code>命令中给出）：
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">import_collate</code></span></dt><dd><p>
       这个选项控制是否在从外部服务器导入的外部表定义中包括列的<code class="literal">COLLATE</code>选项。默认是<code class="literal">true</code>。如果远程服务器具有和本地服务器不同的排序规则名集合，可能需要关闭这个选项，在不同的操作系统上运行时很可能就是这样。
      </p></dd><dt><span class="term"><code class="literal">import_default</code></span></dt><dd><p>
       这个选项控制是否在从外部服务器导入的外部表定义中包括列的<code class="literal">DEFAULT</code>表达式。默认是<code class="literal">false</code>。如果启用这个选项，要当心在远程服务器和本地服务器上计算表达式的方式不同，<code class="function">nextval()</code>常会导致这类问题。如果导入的默认值表达式使用了一个本地不存在的函数或者操作符，<code class="command">IMPORT</code>将整个失败。
      </p></dd><dt><span class="term"><code class="literal">import_not_null</code></span></dt><dd><p>
       这个选项控制是否在从外部服务器导入的外部表定义中包括列的<code class="literal">NOT NULL</code>约束。默认是<code class="literal">true</code>。
      </p></dd></dl></div><p>
    注意除<code class="literal">NOT NULL</code>之外的约束将不会从远程表中导入。虽然<span class="productname">PostgreSQL</span>确实支持外部表上的<code class="literal">CHECK</code>约束，但不会自动导入它们，因为存在本地和远程服务器计算约束表达式方式不同的风险。<code class="literal">CHECK</code>约束中的任何这类不一致都可能导致查询优化中很难检测的错误。因此，如果你希望导入<code class="literal">CHECK</code>约束，你必须手工来做，并且你应该仔细地验证每一个这种约束的语义。有关处理外部表上<code class="literal">CHECK</code>约束的更多细节，请见<a class="xref" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE"><span class="refentrytitle">CREATE FOREIGN TABLE</span></a>。
   </p><p>
    自动排除作为其他表的分区的表或外部表。分区表被导入，除非它们是其他表的分区。
	由于所有数据都可以通过作为分区层次根的分区表来访问，
	所以这种方法应该允许访问所有数据而不创建额外的对象。
   </p></div></div><div class="sect2" id="id-1.11.7.42.11"><div class="titlepage"><div><div><h3 class="title">F.33.2. 连接管理</h3></div></div></div><p>
   <code class="filename">postgres_fdw</code>在第一个使用关联到外部服务器的外部表的查询期间建立一个到外部服务器的连接。这个连接会被保持，并被重用于同一个会话中的后续查询。但是，如果使用了多个用户实体（用户映射）来访问外部服务器，会为每一个用户映射建立一个连接。
  </p></div><div class="sect2" id="id-1.11.7.42.12"><div class="titlepage"><div><div><h3 class="title">F.33.3. 事务管理</h3></div></div></div><p>
   在一个引用外部服务器上任何远程表的查询期间，如果还没有根据当前的本地事务打开一个远程事务，<code class="filename">postgres_fdw</code>将在远程服务器上打开一个事务。当本地事务提交或中止时，远程事务也被提交或中止。保存点也相似地采用创建相应的远程保存点来管理。
  </p><p>
   当本地事务为<code class="literal">SERIALIZABLE</code>隔离级别时，远程事务使用<code class="literal">SERIALIZABLE</code>隔离级别；否则它使用<code class="literal">REPEATABLE READ</code>隔离级别。如果一个查询在远程服务器上执行多个表查询，这种选择保证它将为所有扫描得到快照一致的结果。一种后果是在单一事务中的后继查询将会看到来自远程服务器的相同数据，即便由于其他活动在远程服务器上发生了其他并发更新。如果本地事务使用<code class="literal">SERIALIZABLE</code>或<code class="literal">REPEATABLE READ</code>隔离级别，这种行为也是可以预期的，但是对于一个<code class="literal">READ COMMITTED</code>本地事务它是奇怪的。一个未来的<span class="productname">PostgreSQL</span>发布可能会修改这些规则。
  </p><p>
   请注意<code class="filename">postgres_fdw</code>当前不支持为两阶段提交准备远程事务。
  </p></div><div class="sect2" id="id-1.11.7.42.13"><div class="titlepage"><div><div><h3 class="title">F.33.4. 远程查询优化</h3></div></div></div><p>
   <code class="filename">postgres_fdw</code>尝试优化远程查询来减少从外部服务器传来的数据量。这可以通过把查询的<code class="literal">WHERE</code>子句发送给远程服务器执行来完成，并且还可以不检索当前查询不需要的表列。为了降低查询被误执行的风险，除非<code class="literal">WHERE</code>子句使用的数据类型、操作符和函数都是内建的或者属于列在该外部服务器的<code class="literal">extensions</code>选项中的一个扩展，将不会把<code class="literal">WHERE</code>子句发送到远程服务器。这些子句中的操作符合函数也必须是<code class="literal">IMMUTABLE</code>。对于<code class="command">UPDATE</code>或者<code class="command">DELETE</code>查询，
   如果没有不能发送给远程服务器的<code class="literal">WHERE</code>子句、
   没有查询的本地连接、目标表上没有本地的行级<code class="literal">BEFORE</code>或<code class="literal">AFTER</code>触发器或存储生成的列，
   并且没有来自父视图的<code class="literal">CHECK OPTION</code>约束，<code class="filename">postgres_fdw</code>会尝试通过将整个查询发送给远程服务器来优化查询的执行。在<code class="command">UPDATE</code>中，赋值给目标列的表达式只能使用内建数据类型、<code class="literal">IMMUTABLE</code>操作符或者<code class="literal">IMMUTABLE</code>操作符，这样能降低查询被误执行的风险。
  </p><p>
   当<code class="filename">postgres_fdw</code>碰到同一个外部服务器上的外部表之间的连接时，它会把整个连接发送给外部服务器，除非由于某些原因它认为逐个从每一个表取得行的效率更高或者涉及的表引用属于不同的用户映射。在发送<code class="literal">JOIN</code>子句时，它也会采取和上述<code class="literal">WHERE</code>子句相同的预防措施。
  </p><p>
   实际被发送到远程服务器执行的查询可以使用<code class="command">EXPLAIN VERBOSE</code>来检查。
  </p></div><div class="sect2" id="id-1.11.7.42.14"><div class="titlepage"><div><div><h3 class="title">F.33.5. 远程查询执行环境</h3></div></div></div><p>
   在<code class="filename">postgres_fdw</code>开启的远程会话中，<a class="xref" href="runtime-config-client.html#GUC-SEARCH-PATH">search_path</a>参数只被设置为<code class="literal">pg_catalog</code>，因此只有内建对象可以在无模式限定时可见。这对于<code class="filename">postgres_fdw</code>本身产生的查询来说不是问题，因为它总是会提供这样的限定。不过，这可能会对在远程服务器上通过触发器或者远程表上的规则执行的函数带来灾难。例如，如果一个远程表实际是一个视图，任何在该视图中使用的函数都将被在这个受限的搜索路径中执行。我们推荐在这类函数中用模式限定所有名称，或者为这类函数附着<code class="literal">SET search_path</code>选项（见<a class="xref" href="sql-createfunction.html" title="CREATE FUNCTION"><span class="refentrytitle">CREATE FUNCTION</span></a>）来建立它们所期望的搜索路径环境。
  </p><p>
   <code class="filename">postgres_fdw</code>同样为各种参数建立远程会话设置：
   </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
      <a class="xref" href="runtime-config-client.html#GUC-TIMEZONE">TimeZone</a>设置为<code class="literal">UTC</code>
     </p></li><li class="listitem"><p>
      <a class="xref" href="runtime-config-client.html#GUC-DATESTYLE">DateStyle</a>设置为<code class="literal">ISO</code>
     </p></li><li class="listitem"><p>
      <a class="xref" href="runtime-config-client.html#GUC-INTERVALSTYLE">IntervalStyle</a>设置为<code class="literal">postgres</code>
     </p></li><li class="listitem"><p>
      对于远程服务器9.0和更新版本，<a class="xref" href="runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS">extra_float_digits</a>
	  设置为<code class="literal">3</code>，并且针对更老版本设置为<code class="literal">2</code>
     </p></li></ul></div><p>
   这些不如<code class="varname">search_path</code>有那么多问题，但是如果需要也可以使用函数
   <code class="literal">SET</code>选项来处理。
  </p><p>
   我们<span class="emphasis"><em>不</em></span>推荐通过更改这些参数的会话级设置来推翻这种行为，这很可能会导致<code class="filename">postgres_fdw</code>故障。
  </p></div><div class="sect2" id="id-1.11.7.42.15"><div class="titlepage"><div><div><h3 class="title">F.33.6. 跨版本兼容性</h3></div></div></div><p>
   <code class="filename">postgres_fdw</code>能够与最老是<span class="productname">PostgreSQL</span> 8.3 的远程服务器一起使用。只读能力则最低可以在 8.1 中使用。但是一个限制是<code class="filename">postgres_fdw</code>通常假定不变的内建函数和操作符是安全的，如果它们出现在一个外部表的<code class="literal">WHERE</code>子句中，它们可以发送给远程服务器执行。因此，由于一个由于远程服务器的发布可能被发送给它来执行而被增加的内建函数，会导致<span class="quote">“<span class="quote">function does not exist</span>”</span>或一个类似的错误。这类错误可以通过重写查询来解决，例如通过嵌入在一个带<code class="literal">OFFSET 0</code>的子<code class="literal">SELECT</code>中引用的外部表作为一种优化墙，并且把出问题的函数或操作符放在子<code class="literal">SELECT</code>的外部。
  </p></div><div class="sect2" id="id-1.11.7.42.16"><div class="titlepage"><div><div><h3 class="title">F.33.7. 例子</h3></div></div></div><p>
   这里是一个用<code class="literal">postgres_fdw</code>创建外部表的例子。首先安装该扩展：
  </p><pre class="programlisting">
CREATE EXTENSION postgres_fdw;
</pre><p>
   然后使用<a class="xref" href="sql-createserver.html" title="CREATE SERVER"><span class="refentrytitle">CREATE SERVER</span></a>创建一个外部服务器。在这个例子中我们希望连接到一个位于主机<code class="literal">192.83.123.89</code>上并且监听<code class="literal">5432</code>端口的<span class="productname">PostgreSQL</span>服务器。在该远程服务器上要连接的数据库名为<code class="literal">foreign_db</code>：

</p><pre class="programlisting">
CREATE SERVER foreign_server
        FOREIGN DATA WRAPPER postgres_fdw
        OPTIONS (host '192.83.123.89', port '5432', dbname 'foreign_db');
</pre><p>
  </p><p>
   需要用<a class="xref" href="sql-createusermapping.html" title="CREATE USER MAPPING"><span class="refentrytitle">CREATE USER MAPPING</span></a>定义一个用户映射来标识在远程服务器上使用哪个角色：

</p><pre class="programlisting">
CREATE USER MAPPING FOR local_user
        SERVER foreign_server
        OPTIONS (user 'foreign_user', password 'password');
</pre><p>
  </p><p>
   现在就可以使用<a class="xref" href="sql-createforeigntable.html" title="CREATE FOREIGN TABLE"><span class="refentrytitle">CREATE FOREIGN TABLE</span></a>创建外部表了。在这个例子中我们希望访问远程服务器上名为<code class="structname">some_schema.some_table</code>的表。它的本地名称是<code class="structname">foreign_table</code>：

</p><pre class="programlisting">
CREATE FOREIGN TABLE foreign_table (
        id integer NOT NULL,
        data text
)
        SERVER foreign_server
        OPTIONS (schema_name 'some_schema', table_name 'some_table');
</pre><p>

   <code class="command">CREATE FOREIGN TABLE</code>中声明的列数据类型和其他性质必须要匹配实际的远程表。列名也必须匹配，不过也可以为个别列附上<code class="literal">column_name</code>选项以表示它们在远程服务器上对应哪个列。在很多情况中，要手工构造外部表定义，使用<a class="xref" href="sql-importforeignschema.html" title="IMPORT FOREIGN SCHEMA"><span class="refentrytitle">IMPORT FOREIGN SCHEMA</span></a>会更好。
  </p></div><div class="sect2" id="id-1.11.7.42.17"><div class="titlepage"><div><div><h3 class="title">F.33.8. 作者</h3></div></div></div><p>
   Shigeru Hanada <code class="email">&lt;<a class="email" href="mailto:shigeru.hanada@gmail.com">shigeru.hanada@gmail.com</a>&gt;</code>
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pgvisibility.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="seg.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">F.32. pg_visibility </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> F.34. seg</td></tr></table></div></body></html>