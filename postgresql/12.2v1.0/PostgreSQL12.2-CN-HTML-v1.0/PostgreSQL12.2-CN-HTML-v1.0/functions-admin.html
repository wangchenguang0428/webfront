<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9.26. 系统管理函数</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="functions-info.html" title="9.25. 系统信息函数和运算符" /><link rel="next" href="functions-trigger.html" title="9.27. 触发器函数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">9.26. 系统管理函数</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="functions-info.html" title="9.25. 系统信息函数和运算符">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="functions.html" title="第 9 章 函数和操作符">上一级</a></td><th width="60%" align="center">第 9 章 函数和操作符</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="functions-trigger.html" title="9.27. 触发器函数">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="FUNCTIONS-ADMIN"><div class="titlepage"><div><div><h2 class="title" style="clear: both">9.26. 系统管理函数</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="functions-admin.html#FUNCTIONS-ADMIN-SET">9.26.1. 配置设定函数</a></span></dt><dt><span class="sect2"><a href="functions-admin.html#FUNCTIONS-ADMIN-SIGNAL">9.26.2. 服务器信号函数</a></span></dt><dt><span class="sect2"><a href="functions-admin.html#FUNCTIONS-ADMIN-BACKUP">9.26.3. 备份控制函数</a></span></dt><dt><span class="sect2"><a href="functions-admin.html#FUNCTIONS-RECOVERY-CONTROL">9.26.4. 恢复控制函数</a></span></dt><dt><span class="sect2"><a href="functions-admin.html#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION">9.26.5. 快照同步函数</a></span></dt><dt><span class="sect2"><a href="functions-admin.html#FUNCTIONS-REPLICATION">9.26.6. 复制函数</a></span></dt><dt><span class="sect2"><a href="functions-admin.html#FUNCTIONS-ADMIN-DBOBJECT">9.26.7. 数据库对象管理函数</a></span></dt><dt><span class="sect2"><a href="functions-admin.html#FUNCTIONS-ADMIN-INDEX">9.26.8. 索引维护函数</a></span></dt><dt><span class="sect2"><a href="functions-admin.html#FUNCTIONS-ADMIN-GENFILE">9.26.9. 通用文件访问函数</a></span></dt><dt><span class="sect2"><a href="functions-admin.html#FUNCTIONS-ADVISORY-LOCKS">9.26.10. 咨询锁函数</a></span></dt></dl></div><p>
    这一节描述的函数被用来控制和监视一个<span class="productname">PostgreSQL</span>安装。
   </p><div class="sect2" id="FUNCTIONS-ADMIN-SET"><div class="titlepage"><div><div><h3 class="title">9.26.1. 配置设定函数</h3></div></div></div><p>
    <a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-SET-TABLE" title="表 9.82. 配置设定函数">表 9.82</a>展示了那些可以用于查询以及修改运行时配置参数的函数。
   </p><div class="table" id="FUNCTIONS-ADMIN-SET-TABLE"><p class="title"><strong>表 9.82. 配置设定函数</strong></p><div class="table-contents"><table class="table" summary="配置设定函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <a id="id-1.5.8.31.3.3.2.2.1.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">current_setting(<em class="parameter"><code>setting_name</code></em> [, <em class="parameter"><code>missing_ok</code></em> ])</code></code>
       </td><td><code class="type">text</code></td><td>获得设置的当前值</td></tr><tr><td>
        <a id="id-1.5.8.31.3.3.2.2.2.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">set_config(<em class="parameter"><code>setting_name</code></em>,
                             <em class="parameter"><code>new_value</code></em>,
                             <em class="parameter"><code>is_local</code></em>)</code></code>
       </td><td><code class="type">text</code></td><td>设置一个参数并返回新值</td></tr></tbody></table></div></div><br class="table-break" /><a id="id-1.5.8.31.3.4" class="indexterm"></a><a id="id-1.5.8.31.3.5" class="indexterm"></a><a id="id-1.5.8.31.3.6" class="indexterm"></a><p>
    <code class="function">current_setting</code>得到<em class="parameter"><code>setting_name</code></em>设置的当前值。它对应于<acronym class="acronym">SQL</acronym>命令<code class="command">SHOW</code>。一个例子：
</p><pre class="programlisting">
SELECT current_setting('datestyle');

 current_setting
-----------------
 ISO, MDY
(1 row)
</pre><p>

    如果没有名为<em class="parameter"><code>setting_name</code></em>的设置，除非提供<em class="parameter"><code>missing_ok</code></em>并且其值为<code class="literal">true</code>，<code class="function">current_setting</code>会抛出错误。
   </p><p>
    <code class="function">set_config</code>将参数<em class="parameter"><code>setting_name</code></em>设置为<em class="parameter"><code>new_value</code></em>。如果 <em class="parameter"><code>is_local</code></em>设置为<code class="literal">true</code>，那么新值将只应用于当前事务。 如果你希望新值应用于当前会话，那么应该使用<code class="literal">false</code>。 它等效于 SQL 命令 <code class="command">SET</code>。例如：
</p><pre class="programlisting">
SELECT set_config('log_statement_stats', 'off', false);

 set_config
------------
 off
(1 row)
</pre><p>
   </p></div><div class="sect2" id="FUNCTIONS-ADMIN-SIGNAL"><div class="titlepage"><div><div><h3 class="title">9.26.2. 服务器信号函数</h3></div></div></div><a id="id-1.5.8.31.4.2" class="indexterm"></a><a id="id-1.5.8.31.4.3" class="indexterm"></a><a id="id-1.5.8.31.4.4" class="indexterm"></a><a id="id-1.5.8.31.4.5" class="indexterm"></a><a id="id-1.5.8.31.4.6" class="indexterm"></a><p>
    在<a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-SIGNAL-TABLE" title="表 9.83. 服务器信号函数">表 9.83</a>中展示的函数向其它服务器进程发送控制信号。默认情况下这些函数只能被超级用户使用，但是如果需要，可以利用<code class="command">GRANT</code>把访问特权授予给其他用户。
   </p><div class="table" id="FUNCTIONS-ADMIN-SIGNAL-TABLE"><p class="title"><strong>表 9.83. 服务器信号函数</strong></p><div class="table-contents"><table class="table" summary="服务器信号函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <code class="literal"><code class="function">pg_cancel_backend(<em class="parameter"><code>pid</code></em> <code class="type">int</code>)</code></code>
        </td><td><code class="type">boolean</code></td><td>取消一个后端的当前查询。如果调用角色是被取消后端的拥有者角色的成员或者调用角色已经被授予<code class="literal">pg_signal_backend</code>，这也是允许的，不过只有超级用户才能取消超级用户的后端。
        </td></tr><tr><td>
        <code class="literal"><code class="function">pg_reload_conf()</code></code>
        </td><td><code class="type">boolean</code></td><td>导致服务器进程重载它们的配置文件</td></tr><tr><td>
        <code class="literal"><code class="function">pg_rotate_logfile()</code></code>
        </td><td><code class="type">boolean</code></td><td>切换服务器的日志文件</td></tr><tr><td>
        <code class="literal"><code class="function">pg_terminate_backend(<em class="parameter"><code>pid</code></em> <code class="type">int</code>)</code></code>
        </td><td><code class="type">boolean</code></td><td>中止一个后端。如果调用角色是被取消后端的拥有者角色的成员或者调用角色已经被授予<code class="literal">pg_signal_backend</code>，这也是允许的，不过只有超级用户才能取消超级用户的后端。
       </td></tr></tbody></table></div></div><br class="table-break" /><p>
    这些函数中的每一个都在成功时返回<code class="literal">true</code>，并且在失败时返回<code class="literal">false</code>。
   </p><p>
    <code class="function">pg_cancel_backend</code>和<code class="function">pg_terminate_backend</code>向由进程 ID 标识的后端进程发送信号（分别是<span class="systemitem">SIGINT</span>或<span class="systemitem">SIGTERM</span>）。一个活动后端的进程 ID可以从<code class="structname">pg_stat_activity</code>视图的<code class="structfield">pid</code>列中找到，或者通过在服务器上列出<code class="command">postgres</code>进程（在 Unix 上使用<span class="application">ps</span>或者在<span class="productname">Windows</span>上使用<span class="application">任务管理器</span>）得到。一个活动后端的角色可以在<code class="structname">pg_stat_activity</code>视图的<code class="structfield">usename</code>列中找到。
   </p><p>
    <code class="function">pg_reload_conf</code>给服务器发送一个<span class="systemitem">SIGHUP</span>信号， 导致所有服务器进程重载配置文件。
   </p><p>
    <code class="function">pg_rotate_logfile</code>给日志文件管理器发送信号，告诉它立即切换到一个新的输出文件。这个函数只有在内建日志收集器运行时才能工作，因为否则就不存在日志文件管理器子进程。
    subprocess.
   </p></div><div class="sect2" id="FUNCTIONS-ADMIN-BACKUP"><div class="titlepage"><div><div><h3 class="title">9.26.3. 备份控制函数</h3></div></div></div><a id="id-1.5.8.31.5.2" class="indexterm"></a><a id="id-1.5.8.31.5.3" class="indexterm"></a><a id="id-1.5.8.31.5.4" class="indexterm"></a><a id="id-1.5.8.31.5.5" class="indexterm"></a><a id="id-1.5.8.31.5.6" class="indexterm"></a><a id="id-1.5.8.31.5.7" class="indexterm"></a><a id="id-1.5.8.31.5.8" class="indexterm"></a><a id="id-1.5.8.31.5.9" class="indexterm"></a><a id="id-1.5.8.31.5.10" class="indexterm"></a><a id="id-1.5.8.31.5.11" class="indexterm"></a><a id="id-1.5.8.31.5.12" class="indexterm"></a><a id="id-1.5.8.31.5.13" class="indexterm"></a><a id="id-1.5.8.31.5.14" class="indexterm"></a><p>
    <a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE" title="表 9.84. 备份控制函数">表 9.84</a>中展示的函数可以辅助制作在线备份。这些函数不能在恢复期间执行（非排他性的<code class="function">pg_start_backup</code>，非排他性的<code class="function">pg_stop_backup</code>，<code class="function">pg_is_in_backup</code>、<code class="function">pg_backup_start_time</code>和<code class="function">pg_wal_lsn_diff</code>除外）。
   </p><div class="table" id="FUNCTIONS-ADMIN-BACKUP-TABLE"><p class="title"><strong>表 9.84. 备份控制函数</strong></p><div class="table-contents"><table class="table" summary="备份控制函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <code class="literal"><code class="function">pg_create_restore_point(<em class="parameter"><code>name</code></em> <code class="type">text</code>)</code></code>
        </td><td><code class="type">pg_lsn</code></td><td>为执行恢复创建一个命名点（默认只限于超级用户，但是可以授予其他用户 EXECUTE 特权来执行该函数）</td></tr><tr><td>
        <code class="literal"><code class="function">pg_current_wal_flush_lsn()</code></code>
        </td><td><code class="type">pg_lsn</code></td><td>得到当前的预写式日志刷写位置</td></tr><tr><td>
        <code class="literal"><code class="function">pg_current_wal_insert_lsn()</code></code>
        </td><td><code class="type">pg_lsn</code></td><td>获得当前预写式日志插入位置</td></tr><tr><td>
        <code class="literal"><code class="function">pg_current_wal_lsn()</code></code>
        </td><td><code class="type">pg_lsn</code></td><td>获得当前预写式日志写入位置</td></tr><tr><td>
        <code class="literal"><code class="function">pg_start_backup(<em class="parameter"><code>label</code></em> <code class="type">text</code> [<span class="optional">, <em class="parameter"><code>fast</code></em> <code class="type">boolean</code> [<span class="optional">, <em class="parameter"><code>exclusive</code></em> <code class="type">boolean</code> </span>]</span>])</code></code>
        </td><td><code class="type">pg_lsn</code></td><td>准备执行在线备份（默认只限于超级用户或者复制角色，但是可以授予其他用户 EXECUTE 特权来执行该函数）</td></tr><tr><td>
        <code class="literal"><code class="function">pg_stop_backup()</code></code>
        </td><td><code class="type">pg_lsn</code></td><td>完成执行排他的在线备份（默认只限于超级用户或者复制角色，但是可以授予其他用户 EXECUTE 特权来执行该函数）</td></tr><tr><td>
        <code class="literal"><code class="function">pg_stop_backup(<em class="parameter"><code>exclusive</code></em> <code class="type">boolean</code>)</code></code>
        </td><td><code class="type">setof record</code></td><td>结束执行排他或者非排他的在线备份 （默认只限于超级用户，但是可以授予其他用户 EXECUTE 特权来执行该函数）</td></tr><tr><td>
        <code class="literal"><code class="function">pg_is_in_backup()</code></code>
        </td><td><code class="type">bool</code></td><td>如果一个在线排他备份仍在进行中则为真。</td></tr><tr><td>
        <code class="literal"><code class="function">pg_backup_start_time()</code></code>
        </td><td><code class="type">timestamp with time zone</code></td><td>获得一个进行中的在线排他备份的开始时间。</td></tr><tr><td>
        <code class="literal"><code class="function">pg_switch_wal()</code></code>
        </td><td><code class="type">pg_lsn</code></td><td>强制切换到一个新的预写式日志文件（默认只限于超级用户，但是可以授予其他用户 EXECUTE 特权来执行该函数）</td></tr><tr><td>
        <code class="literal"><code class="function">pg_walfile_name(<em class="parameter"><code>lsn</code></em> <code class="type">text</code>)</code></code>
        </td><td><code class="type">pg_lsn</code></td><td>转换预写式日志位置字符串为文件名</td></tr><tr><td>
        <code class="literal"><code class="function">pg_walfile_name_offset(<em class="parameter"><code>lsn</code></em> <code class="type">text</code>)</code></code>
        </td><td><code class="type">pg_lsn</code>, <code class="type">integer</code></td><td>转换预写式日志位置字符串为文件名以及文件内的十进制字节偏移</td></tr><tr><td>
        <code class="literal"><code class="function">pg_wal_lsn_diff(<em class="parameter"><code>lsn</code></em> <code class="type">pg_lsn</code>, <em class="parameter"><code>lsn</code></em> <code class="type">pg_lsn</code>)</code></code>
       </td><td><code class="type">numeric</code></td><td>计算两个预写式日志位置间的差别</td></tr></tbody></table></div></div><br class="table-break" /><p>
    <code class="function">pg_start_backup</code>接受一个参数，这个参数可以是备份的任意用户定义的标签（通常这是备份转储文件将被存储的名字）。当被用在排他模式中时，该函数向数据库集簇的数据目录写入一个备份标签文件（<code class="filename">backup_label</code>）和一个表空间映射文件（<code class="filename">tablespace_map</code>，如果在<code class="filename">pg_tblspc/</code>目录中有任何链接），执行一个检查点，然后以文本方式返回备份的起始预写式日志位置。用户可以忽略这个结果值，但是为了可能需要的场合我们还是提供该值。 当在非排他模式中使用时，这些文件的内容会转而由<code class="function">pg_stop_backup</code>函数返回，并且应该由调用者写入到备份中去。
</p><pre class="programlisting">
postgres=# select pg_start_backup('label_goes_here');
 pg_start_backup
-----------------
 0/D4445B8
(1 row)
</pre><p>
    第二个参数是可选的，其类型为<code class="type">boolean</code>。如果为<code class="literal">true</code>，它指定尽快执行<code class="function">pg_start_backup</code>。这会强制一个立即执行的检查点，它会导致 I/O 操作的峰值，拖慢任何并发执行的查询。
   </p><p>
    在一次排他备份中，<code class="function">pg_stop_backup</code>会移除标签文件以及<code class="function">pg_start_backup</code>创建的<code class="filename">tablespace_map</code>文件（如果存在）。在一次非排他备份中，<code class="filename">backup_label</code>和<code class="filename">tablespace_map</code>的内容会包含在该函数返回的结果中，并且应该被写入到该备份的文件中（这些内容不在数据目录中）。有一个可选的<code class="type">boolean</code>类型的第二参数。如果为假，<code class="function">pg_stop_backup</code>将在备份完成后立即返回而不等待WAL被归档。这种行为仅对独立监控WAL归档的备份软件有用。否则，让备份一致所要求的WAL可能会丢失，进而让备份变得毫无用处。当这个参数被设置为真时，在启用归档的前提下<code class="function">pg_stop_backup</code>将等待WAL被归档，在后备服务器上，这意味只有<code class="varname">archive_mode = always</code>时才会等待。如果主服务器上的写活动很低，在主服务器上运行<code class="function">pg_switch_wal</code>以触发一次即刻的段切换会很有用。
   </p><p>
    当在主服务器上执行时，该函数还在预写式日志归档区里创建一个备份历史文件。这个历史文件包含给予<code class="function">pg_start_backup</code>的标签、备份的起始与终止预写式日志位置以及备份的起始和终止时间。返回值是备份的终止预写式日志位置（同样也可以被忽略）。在记录结束位置之后，当前预写式日志插入点被自动地推进到下一个预写式日志文件，这样结束的预写式日志文件可以立即被归档来结束备份。
   </p><p>
    <code class="function">pg_switch_wal</code>移动到下一个预写式日志文件，允许当前文件被归档（假定你正在使用连续归档）。返回值是在甘冈完成的预写式日志文件中结束预写式日志位置 + 1。如果从上一次预写式日志切换依赖没有预写式日志活动，<code class="function">pg_switch_wal</code>不会做任何事情并且返回当前正在使用的预写式日志文件的开始位置。
   </p><p>
    <code class="function">pg_create_restore_point</code>创建一个命名预写式日志记录，它可以被用作恢复目标，并且返回相应的预写式日志位置。这个给定的名字可以用于<a class="xref" href="runtime-config-wal.html#GUC-RECOVERY-TARGET-NAME">recovery_target_name</a>来指定恢复要进行到的点。避免使用同一个名称创建多个恢复点，因为恢复会停止在第一个匹配名称的恢复目标。
   </p><p>
    <code class="function">pg_current_wal_lsn</code>以上述函数所使用的相同格式显示当前预写式日志的写位置。类似地，<code class="function">pg_current_wal_insert_lsn</code>显示当前预写式日志插入点，而<code class="function">pg_current_wal_flush_lsn</code>显示当前预写式日志的刷写点。在任何情况下，插入点是预写式日志的<span class="quote">“<span class="quote">逻辑</span>”</span>终止点，而写入位置是已经实际从服务器内部缓冲区写出的日志的终止点，刷写位置则是被确保写入到持久存储中的日志的终止点。写入位置是可以从服务器外部检查的终止点，对那些关注归档部分完成预写式日志文件的人来说，这就是他们需要的位置。插入和刷写点主要是为了服务器调试目的而存在的。这些都是只读操作并且不需要超级用户权限。
   </p><p>
    你可以使用<code class="function">pg_walfile_name_offset</code>从任何上述函数的结果中抽取相应的预写式日志文件名称以及字节偏移。例如：
</p><pre class="programlisting">
postgres=# SELECT * FROM pg_walfile_name_offset(pg_stop_backup());
        file_name         | file_offset 
--------------------------+-------------
 00000001000000000000000D |     4039624
(1 row)
</pre><p>
    相似地，<code class="function">pg_walfile_name</code>只抽取预写式日志文件名。当给定的预写式日志位置正好在一个预写式日志文件的边界，这些函数都返回之前的预写式日志文件的名称。这对管理预写式日志归档行为通常是所希望的行为，因为前一个文件是当前需要被归档的最后一个文件。
   </p><p>
    <code class="function">pg_wal_lsn_diff</code>以字节数计算两个预写式日志位置之间的差别。它可以和<code class="structname">pg_stat_replication</code>或<a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE" title="表 9.84. 备份控制函数">表 9.84</a>中其他的函数一起使用来获得复制延迟。
   </p><p>
    关于正确使用这些函数的细节，请见<a class="xref" href="continuous-archiving.html" title="25.3. 连续归档和时间点恢复（PITR）">第 25.3 节</a>。
   </p></div><div class="sect2" id="FUNCTIONS-RECOVERY-CONTROL"><div class="titlepage"><div><div><h3 class="title">9.26.4. 恢复控制函数</h3></div></div></div><a id="id-1.5.8.31.6.2" class="indexterm"></a><a id="id-1.5.8.31.6.3" class="indexterm"></a><a id="id-1.5.8.31.6.4" class="indexterm"></a><a id="id-1.5.8.31.6.5" class="indexterm"></a><p>
    <a class="xref" href="functions-admin.html#FUNCTIONS-RECOVERY-INFO-TABLE" title="表 9.85. 恢复信息函数">表 9.85</a>中展示的函数提供有关后备机当前状态的信息。这些函数可以在恢复或普通运行过程中被执行。
   </p><div class="table" id="FUNCTIONS-RECOVERY-INFO-TABLE"><p class="title"><strong>表 9.85. 恢复信息函数</strong></p><div class="table-contents"><table class="table" summary="恢复信息函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <code class="literal"><code class="function">pg_is_in_recovery()</code></code>
        </td><td><code class="type">bool</code></td><td>如果恢复仍在进行中，为真。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_last_wal_receive_lsn()</code></code>
        </td><td><code class="type">pg_lsn</code></td><td>获得最后一个收到并由流复制同步到磁盘的预写式日志位置。当流复制在进行中时，这将单调增加。如果恢复已经完成，这将保持静止在恢复过程中收到并同步到磁盘的最后一个 WAL 记录。如果流复制被禁用，或者还没有被启动，该函数返回 NULL。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_last_wal_replay_lsn()</code></code>
        </td><td><code class="type">pg_lsn</code></td><td>获得恢复过程中被重放的最后一个预写式日志位置。当流复制在进行中时，这将单调增加。如果恢复已经完成，这将保持静止在恢复过程中被应用的最后一个 WAL 记录。如果服务器被正常启动而没有恢复，该函数返回 NULL。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_last_xact_replay_timestamp()</code></code>
        </td><td><code class="type">timestamp with time zone</code></td><td>获得恢复过程中被重放的最后一个事务的时间戳。这是在主机上产生的事务的提交或中止 WAL 记录的时间。如果在恢复过程中没有事务被重放，这个函数返回 NULL。否则，如果恢复仍在进行这将单调增加。如果恢复已经完成，则这个值会保持静止在恢复过程中最后一个被应用的事务。如果服务器被正常启动而没有恢复，该函数返回 NULL。
       </td></tr></tbody></table></div></div><br class="table-break" /><a id="id-1.5.8.31.6.8" class="indexterm"></a><a id="id-1.5.8.31.6.9" class="indexterm"></a><a id="id-1.5.8.31.6.10" class="indexterm"></a><a id="id-1.5.8.31.6.11" class="indexterm"></a><p>
    <a class="xref" href="functions-admin.html#FUNCTIONS-RECOVERY-CONTROL-TABLE" title="表 9.86. 恢复控制函数">表 9.86</a>中展示的函数空值恢复的进程。这些函数只能在恢复过程中被执行。
   </p><div class="table" id="FUNCTIONS-RECOVERY-CONTROL-TABLE"><p class="title"><strong>表 9.86. 恢复控制函数</strong></p><div class="table-contents"><table class="table" summary="恢复控制函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <code class="literal"><code class="function">pg_is_wal_replay_paused()</code></code>
        </td><td><code class="type">bool</code></td><td>如果恢复被暂停，为真。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_promote(<em class="parameter"><code>wait</code></em> <code class="type">boolean</code> DEFAULT true, <em class="parameter"><code>wait_seconds</code></em> <code class="type">integer</code> DEFAULT 60)</code></code>
        </td><td><code class="type">boolean</code></td><td>
        促进物理备用服务器。 当 <em class="parameter"><code>wait</code></em>设置为<code class="literal">true</code>（默认值）时，该函数将等待晋升完成或<em class="parameter"><code>wait_seconds</code></em>秒，如果晋升成功，则返回<code class="literal">true</code>，否则返回<code class="literal">false</code>。如果<em class="parameter"><code>wait</code></em>被设置为<code class="literal">false</code>，则会返回<code class="literal">true</code>。函数在发送后立即返回<code class="literal">true</code>。<code class="literal">SIGUSR1</code>给postmaster触发推广。此功能默认只限于超级用户，但其他用户 可以被授予EXECUTE来运行函数。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_wal_replay_pause()</code></code>
        </td><td><code class="type">void</code></td><td>立即暂停恢复（默认仅限于超级用户, 但是可以授予其他用户 EXECUTE 特权来执行该函数）。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_wal_replay_resume()</code></code>
        </td><td><code class="type">void</code></td><td>如果恢复被暂停，重启之（默认仅限于超级用户，但是可以授予其他用户 EXECUTE 特权来执行该函数）。
       </td></tr></tbody></table></div></div><br class="table-break" /><p>
    在恢复被暂停时，不会有进一步的数据库改变被应用。如果在热备模式，所有新的查询将看到数据库的同一个一致快照，并且在恢复被继续之前不会有更多查询冲突会产生。
   </p><p>
    如果流复制被禁用，暂停状态可以无限制地继续而不出问题。在流复制进行时，WAL 记录将继续被接收，最后将会填满可用的磁盘空间，取决于暂停的持续时间、WAL 的产生率和可用的磁盘空间。
   </p></div><div class="sect2" id="FUNCTIONS-SNAPSHOT-SYNCHRONIZATION"><div class="titlepage"><div><div><h3 class="title">9.26.5. 快照同步函数</h3></div></div></div><a id="id-1.5.8.31.7.2" class="indexterm"></a><p>
    <span class="productname">PostgreSQL</span>允许数据库会话同步它们的快照。一个<em class="firstterm">快照</em>决定对于正在使用该快照的事务哪些数据是可见的。当两个或者更多个会话需要看到数据库中的相同内容时，就需要同步快照。如果两个会话独立开始其事务，就总是有可能有某个第三事务在两个<code class="command">START TRANSACTION</code>命令的执行之间提交，这样其中一个会话就可以看到该事务的效果而另一个则看不到。
   </p><p>
    为了解决这个问题，<span class="productname">PostgreSQL</span>允许一个事务<em class="firstterm">导出</em>它正在使用的快照。只要导出的事务仍然保持打开，其他事务可以<em class="firstterm">导入</em>它的快照，并且因此可以保证它们可以看到和第一个事务看到的完全一样的数据库视图。但是注意这些事务中的任何一个对数据库所作的更改对其他事务仍然保持不可见，和未提交事务所作的修改一样。因此这些事务是针对以前存在的数据同步，而对由它们自己所作的更改则采取正常的动作。
   </p><p>
    如<a class="xref" href="functions-admin.html#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE" title="表 9.87. 快照同步函数">表 9.87</a>中所示，快照通过<code class="function">pg_export_snapshot</code>函数导出，并且通过<a class="xref" href="sql-set-transaction.html" title="SET TRANSACTION"><span class="refentrytitle">SET TRANSACTION</span></a>命令导入。
   </p><div class="table" id="FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE"><p class="title"><strong>表 9.87. 快照同步函数</strong></p><div class="table-contents"><table class="table" summary="快照同步函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <code class="literal"><code class="function">pg_export_snapshot()</code></code>
       </td><td><code class="type">text</code></td><td>保存当前快照并返回它的标识符</td></tr></tbody></table></div></div><br class="table-break" /><p>
    函数<code class="function">pg_export_snapshot</code>保存当前的快照并且返回一个<code class="type">text</code>串标识该快照。该字符串必须被传递（到数据库外）给希望导入快照的客户端。直到导出快照的事务的末尾，快照都可以被导入。如果需要，一个事务可以导出多于一个快照。注意这样做只在 <code class="literal">READ COMMITTED</code>事务中有用，因为在<code class="literal">REPEATABLE READ</code>和更高隔离级别中，事务在它们的生命期中都使用同一个快照。一旦一个事务已经导出了任何快照，它不能使用<a class="xref" href="sql-prepare-transaction.html" title="PREPARE TRANSACTION"><span class="refentrytitle">PREPARE TRANSACTION</span></a>。
   </p><p>
    关于如何使用一个已导出快照的细节请见<a class="xref" href="sql-set-transaction.html" title="SET TRANSACTION"><span class="refentrytitle">SET TRANSACTION</span></a>.
   </p></div><div class="sect2" id="FUNCTIONS-REPLICATION"><div class="titlepage"><div><div><h3 class="title">9.26.6. 复制函数</h3></div></div></div><p>
    <a class="xref" href="functions-admin.html#FUNCTIONS-REPLICATION-TABLE" title="表 9.88. 复制 SQL 函数">表 9.88</a>中展示的函数
    用于控制以及与复制特性交互。有关底层特性的信息请见
    <a class="xref" href="warm-standby.html#STREAMING-REPLICATION" title="26.2.5. 流复制">第 26.2.5 节</a>、
    <a class="xref" href="warm-standby.html#STREAMING-REPLICATION-SLOTS" title="26.2.6. 复制槽">第 26.2.6 节</a>以及
    <a class="xref" href="replication-origins.html" title="第 49 章 复制进度追踪">第 49 章</a>。复制原点函数的使用仅限于超级用户。 复制槽的函数只限于超级用户和拥有<code class="literal">REPLICATION</code>权限的用户。
   </p><p>
    很多这些函数在复制协议中都有等价的命令，见
    <a class="xref" href="protocol-replication.html" title="52.4. 流复制协议">第 52.4 节</a>。
   </p><p>
    <a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-BACKUP" title="9.26.3. 备份控制函数">第 9.26.3 节</a>、
    <a class="xref" href="functions-admin.html#FUNCTIONS-RECOVERY-CONTROL" title="9.26.4. 恢复控制函数">第 9.26.4 节</a>和
    <a class="xref" href="functions-admin.html#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION" title="9.26.5. 快照同步函数">第 9.26.5 节</a>
    中描述的函数也与复制相关。
   </p><div class="table" id="FUNCTIONS-REPLICATION-TABLE"><p class="title"><strong>表 9.88. 复制 <acronym class="acronym">SQL</acronym> 函数</strong></p><div class="table-contents"><table class="table" summary="复制 SQL 函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>函数</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.1.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_create_physical_replication_slot(<em class="parameter"><code>slot_name</code></em> <code class="type">name</code> [<span class="optional">, <em class="parameter"><code>immediately_reserve</code></em> <code class="type">boolean</code> </span>])</code></code>
       </td><td>
        (<em class="parameter"><code>slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>xlog_position</code></em> <code class="type">pg_lsn</code>)
       </td><td>
        创建一个新的名为<em class="parameter"><code>slot_name</code></em>的物理复制槽。第二个参数是可选的，当它为<code class="literal">true</code>时，立即为这个物理槽指定要被保留的<acronym class="acronym">LSN</acronym>。否则该<acronym class="acronym">LSN</acronym>会被保留在来自一个流复制客户端的第一个连接上。来自一个物理槽的流改变只可能出现在使用流复制协议时 — 见<a class="xref" href="protocol-replication.html" title="52.4. 流复制协议">第 52.4 节</a>。当可选的第三参数<em class="parameter"><code>temporary</code></em>被设置为真时，指定那个槽不会被持久地存储在磁盘上并且仅对当前会话的使用有意义。临时槽也会在发生任何错误时被释放。这个函数对应于复制协议命令<code class="literal">CREATE_REPLICATION_SLOT ... PHYSICAL</code>。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.2.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_drop_replication_slot(<em class="parameter"><code>slot_name</code></em> <code class="type">name</code>)</code></code>
       </td><td>
        <code class="type">void</code>
       </td><td>
        丢弃名为<em class="parameter"><code>slot_name</code></em>的物理或逻辑复制槽。
        和复制协议命令<code class="literal">DROP_REPLICATION_SLOT</code>相同。对于逻辑槽，在连接到在其中创建该槽的同一个数据库时，必须调用这个函数。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.3.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_create_logical_replication_slot(<em class="parameter"><code>slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>plugin</code></em> <code class="type">name</code>)</code></code>
       </td><td>
        (<em class="parameter"><code>slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>lsn</code></em> <code class="type">pg_lsn</code>)
       </td><td>
        使用输出插件<em class="parameter"><code>plugin</code></em>创建一个名为
        <em class="parameter"><code>slot_name</code></em>的新逻辑（解码）复制槽。当可选的第三参数<em class="parameter"><code>temporary</code></em>被设置为真时，指定那个槽不会被持久地存储在磁盘上并且仅对当前会话的使用有意义。临时槽也会在发生任何错误时被释放。对这个函数的调用与复制协议命令
        <code class="literal">CREATE_REPLICATION_SLOT ... LOGICAL</code>具有相同的效果。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.4.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_copy_physical_replication_slot(<em class="parameter"><code>src_slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>dst_slot_name</code></em> <code class="type">name</code> [<span class="optional">, <em class="parameter"><code>temporary</code></em> <code class="type">boolean</code></span>])</code></code>
       </td><td>
        (<em class="parameter"><code>slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>lsn</code></em> <code class="type">pg_lsn</code>)
       </td><td>
         将一个名为<em class="parameter"><code>src_slot_name</code></em>的现有物理复制槽复制到一个名为<em class="parameter"><code>dst_slot_name</code></em>的物理复制槽。被复制的物理槽开始从与源槽相同的<acronym class="acronym">LSN</acronym>开始保留WAL。<em class="parameter"><code>temporary</code></em>是可选的。如果省略了<em class="parameter"><code>temporary</code></em>，则使用与源槽相同的值。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.5.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_copy_logical_replication_slot(<em class="parameter"><code>src_slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>dst_slot_name</code></em> <code class="type">name</code> [<span class="optional">, <em class="parameter"><code>temporary</code></em> <code class="type">boolean</code> [<span class="optional">, <em class="parameter"><code>plugin</code></em> <code class="type">name</code></span>]</span>])</code></code>
       </td><td>
        (<em class="parameter"><code>slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>lsn</code></em> <code class="type">pg_lsn</code>)
       </td><td>
        复制一个名为<em class="parameter"><code>src_slot_name</code></em>的现有逻辑复制槽。到一个名为<em class="parameter"><code>dst_slot_name</code></em>的逻辑复制槽。同时改变输出插件和持久性。被复制的逻辑槽开始  来自与源逻辑槽相同的<acronym class="acronym">LSN</acronym>。这两个 <em class="parameter"><code>temporary</code></em>和<em class="parameter"><code>plugin</code></em>是可选的。如果省略了<em class="parameter"><code>temporary</code></em>或<em class="parameter"><code>plugin</code></em>。使用与源逻辑槽相同的值。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.6.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_logical_slot_get_changes(<em class="parameter"><code>slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>upto_lsn</code></em> <code class="type">pg_lsn</code>, <em class="parameter"><code>upto_nchanges</code></em> <code class="type">int</code>, VARIADIC <em class="parameter"><code>options</code></em> <code class="type">text[]</code>)</code></code>
       </td><td>
        (<em class="parameter"><code>lsn</code></em> <code class="type">pg_lsn</code>, <em class="parameter"><code>xid</code></em> <code class="type">xid</code>, <em class="parameter"><code>data</code></em> <code class="type">text</code>)
       </td><td>
        返回槽<em class="parameter"><code>slot_name</code></em>中的改变，从上一次已经被消费的点开始返回。
        如果<em class="parameter"><code>upto_lsn</code></em>和<em class="parameter"><code>upto_nchanges</code></em>为 NULL，逻辑解码将一
        直继续到 WAL 的末尾。如果<em class="parameter"><code>upto_lsn</code></em>为非 NULL，解码将只包括那些在指
        定 LSN 之前提交的事务。如果<em class="parameter"><code>upto_nchanges</code></em>为非 NULL，
        解码将在其产生的行数超过指定值后停止。不过要注意，
        被返回的实际行数可能更大，因为对这个限制的检查只会在增加了解码每个新的提交事务产生
        的行之后进行。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.7.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_logical_slot_peek_changes(<em class="parameter"><code>slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>upto_lsn</code></em> <code class="type">pg_lsn</code>, <em class="parameter"><code>upto_nchanges</code></em> <code class="type">int</code>, VARIADIC <em class="parameter"><code>options</code></em> <code class="type">text[]</code>)</code></code>
       </td><td>
        (<em class="parameter"><code>lsn</code></em> <code class="type">text</code>, <em class="parameter"><code>xid</code></em> <code class="type">xid</code>, <em class="parameter"><code>data</code></em> <code class="type">text</code>)
       </td><td>
        行为就像<code class="function">pg_logical_slot_get_changes()</code>函数，
        不过改变不会被消费， 即在未来的调用中还会返回这些改变。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.8.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_logical_slot_get_binary_changes(<em class="parameter"><code>slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>upto_lsn</code></em> <code class="type">pg_lsn</code>, <em class="parameter"><code>upto_nchanges</code></em> <code class="type">int</code>, VARIADIC <em class="parameter"><code>options</code></em> <code class="type">text[]</code>)</code></code>
       </td><td>
        (<em class="parameter"><code>lsn</code></em> <code class="type">pg_lsn</code>, <em class="parameter"><code>xid</code></em> <code class="type">xid</code>, <em class="parameter"><code>data</code></em> <code class="type">bytea</code>)
       </td><td>
        行为就像<code class="function">pg_logical_slot_get_changes()</code>函数，
        不过改变会以<code class="type">bytea</code>返回。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.9.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_logical_slot_peek_binary_changes(<em class="parameter"><code>slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>upto_lsn</code></em> <code class="type">pg_lsn</code>, <em class="parameter"><code>upto_nchanges</code></em> <code class="type">int</code>, VARIADIC <em class="parameter"><code>options</code></em> <code class="type">text[]</code>)</code></code>
       </td><td>
        (<em class="parameter"><code>lsn</code></em> <code class="type">pg_lsn</code>, <em class="parameter"><code>xid</code></em> <code class="type">xid</code>, <em class="parameter"><code>data</code></em> <code class="type">bytea</code>)
       </td><td>
        行为就像<code class="function">pg_logical_slot_get_changes()</code>函数，
        不过改变会以<code class="type">bytea</code>返回并且这些改变不会被消费，
        即在未来的调用中还会返回这些改变。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.10.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_replication_slot_advance(<em class="parameter"><code>slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>upto_lsn</code></em> <code class="type">pg_lsn</code>)</code></code>
       </td><td>
        (<em class="parameter"><code>slot_name</code></em> <code class="type">name</code>, <em class="parameter"><code>end_lsn</code></em> <code class="type">pg_lsn</code>)
        <code class="type">bool</code>
       </td><td>
        将复制槽的当前确认的位置提前到名为<em class="parameter"><code>slot_name</code></em>的复制槽的当前确认位置。该槽不会向后移动，也不会移动到当前插入位置之外。返回该槽的名称和它被推进到的真实位置。
        如果有任何推进，则在后续的检查点中写出更新后的槽的信息。如果发生崩溃，该槽位可能会返回到之前的位置。
       </td></tr><tr><td id="PG-REPLICATION-ORIGIN-CREATE">
        <a id="id-1.5.8.31.8.5.2.2.11.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_replication_origin_create(<em class="parameter"><code>node_name</code></em> <code class="type">text</code>)</code></code>
       </td><td>
        <code class="type">oid</code>
       </td><td>
        用给定的外部名称创建一个复制源，并且返回分配给它的内部 id。
       </td></tr><tr><td id="PG-REPLICATION-ORIGIN-DROP">
        <a id="id-1.5.8.31.8.5.2.2.12.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_replication_origin_drop(<em class="parameter"><code>node_name</code></em> <code class="type">text</code>)</code></code>
       </td><td>
        <code class="type">void</code>
       </td><td>
        删除一个之前创建的复制源，包括任何相关的重放进度。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.13.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_replication_origin_oid(<em class="parameter"><code>node_name</code></em> <code class="type">text</code>)</code></code>
       </td><td>
        <code class="type">oid</code>
       </td><td>
        用名称查找复制源并且返回内部 id。如果没有找到则抛出错误。
       </td></tr><tr><td id="PG-REPLICATION-ORIGIN-SESSION-SETUP">
        <a id="id-1.5.8.31.8.5.2.2.14.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_replication_origin_session_setup(<em class="parameter"><code>node_name</code></em> <code class="type">text</code>)</code></code>
       </td><td>
        <code class="type">void</code>
       </td><td>
        把当前会话标记为正在从给定的源进行重放，允许重放进度被跟踪。使用
        <code class="function">pg_replication_origin_session_reset</code>可以取消
        标记。只有之前没有源被配置时才能使用。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.15.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_replication_origin_session_reset()</code></code>
       </td><td>
        <code class="type">void</code>
       </td><td>
        取消<code class="function">pg_replication_origin_session_setup()</code>的效果。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.8.5.2.2.16.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_replication_origin_session_is_setup()</code></code>
       </td><td>
        <code class="type">bool</code>
       </td><td>
        当前会话中是否已经配置了一个复制源？
       </td></tr><tr><td id="PG-REPLICATION-ORIGIN-SESSION-PROGRESS">
        <a id="id-1.5.8.31.8.5.2.2.17.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_replication_origin_session_progress(<em class="parameter"><code>flush</code></em> <code class="type">bool</code>)</code></code>
       </td><td>
        <code class="type">pg_lsn</code>
       </td><td>
        返回当前会话中配置的复制源的重放位置。参数
        <em class="parameter"><code>flush</code></em>决定对应的本地事务是否被确保
        已经刷入磁盘。
       </td></tr><tr><td id="PG-REPLICATION-ORIGIN-XACT-SETUP">
        <a id="id-1.5.8.31.8.5.2.2.18.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_replication_origin_xact_setup(<em class="parameter"><code>origin_lsn</code></em> <code class="type">pg_lsn</code>, <em class="parameter"><code>origin_timestamp</code></em> <code class="type">timestamptz</code>)</code></code>
       </td><td>
        <code class="type">void</code>
       </td><td>
        标记当前事务为正在重放一个已经在给定的<acronym class="acronym">LSN</acronym>
        和时间戳提交的事务。只有当之前已经用
        <code class="function">pg_replication_origin_session_setup()</code>配置过
        一个复制源时才能被调用。
       </td></tr><tr><td id="PG-REPLICATION-ORIGIN-XACT-RESET">
        <a id="id-1.5.8.31.8.5.2.2.19.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_replication_origin_xact_reset()</code></code>
       </td><td>
        <code class="type">void</code>
       </td><td>
        取消<code class="function">pg_replication_origin_xact_setup()</code>的效果。
       </td></tr><tr><td id="PG-REPLICATION-ORIGIN-ADVANCE">
        <a id="id-1.5.8.31.8.5.2.2.20.1.1" class="indexterm"></a>
        <code class="literal">pg_replication_origin_advance<code class="function">(<em class="parameter"><code>node_name</code></em> <code class="type">text</code>, <em class="parameter"><code>pos</code></em> <code class="type">pg_lsn</code>)</code></code>
       </td><td>
        <code class="type">void</code>
       </td><td>
        把给定节点的复制进度设置为给定的位置。这主要用于配置更改或者类似
        操作之后设置初始位置或者新位置。注意这个函数的不当使用可能会导致
        不一致的复制数据。
       </td></tr><tr><td id="PG-REPLICATION-ORIGIN-PROGRESS">
        <a id="id-1.5.8.31.8.5.2.2.21.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_replication_origin_progress(<em class="parameter"><code>node_name</code></em> <code class="type">text</code>, <em class="parameter"><code>flush</code></em> <code class="type">bool</code>)</code></code>
       </td><td>
        <code class="type">pg_lsn</code>
       </td><td>
        返回给定复制元的重放位置。参数
        <em class="parameter"><code>flush</code></em>决定对应的本地事务是否被确保
        已经刷入磁盘。
       </td></tr><tr><td id="PG-LOGICAL-EMIT-MESSAGE-TEXT">
        <a id="id-1.5.8.31.8.5.2.2.22.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_logical_emit_message(<em class="parameter"><code>transactional</code></em> <code class="type">bool</code>, <em class="parameter"><code>prefix</code></em> <code class="type">text</code>, <em class="parameter"><code>content</code></em> <code class="type">text</code>)</code></code>
       </td><td>
        <code class="type">pg_lsn</code>
       </td><td>
        发出文本形式的逻辑解码消息。这可以被用来通过 WAL 向逻辑解码插件传递一般消息。参数<em class="parameter"><code>transactional</code></em>指定该消息是否应该是当前事务的一部分或者当逻辑解码读到该记录时该消息是否应该被立刻写入并且解码。<em class="parameter"><code>prefix</code></em>是逻辑解码插件用来识别它们感兴趣的消息的文本前缀。<em class="parameter"><code>content</code></em>是消息的文本。
       </td></tr><tr><td id="PG-LOGICAL-EMIT-MESSAGE-BYTEA">
        <code class="literal"><code class="function">pg_logical_emit_message(<em class="parameter"><code>transactional</code></em> <code class="type">bool</code>, <em class="parameter"><code>prefix</code></em> <code class="type">text</code>, <em class="parameter"><code>content</code></em> <code class="type">bytea</code>)</code></code>
       </td><td>
        <code class="type">pg_lsn</code>
       </td><td>
        发出二进制逻辑解码消息。这可以被用来通过WAL向逻辑解码插件传递一般性消息。参数<em class="parameter"><code>transactional</code></em>指定该消息是否应该成为当前事务的一部分或者是否应该在逻辑解码过程读到该记录时立刻进行写入和解码。参数<em class="parameter"><code>prefix</code></em>是一个逻辑解码插件使用的文本前缀，逻辑解码插件用它来识别感兴趣的消息。参数<em class="parameter"><code>content</code></em>是消息的二进制内容。
       </td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="FUNCTIONS-ADMIN-DBOBJECT"><div class="titlepage"><div><div><h3 class="title">9.26.7. 数据库对象管理函数</h3></div></div></div><p>
    <a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-DBSIZE" title="表 9.89. 数据库对象尺寸函数">表 9.89</a>中展示的函数计算数据库对象使用的磁盘空间。
   </p><a id="id-1.5.8.31.9.3" class="indexterm"></a><a id="id-1.5.8.31.9.4" class="indexterm"></a><a id="id-1.5.8.31.9.5" class="indexterm"></a><a id="id-1.5.8.31.9.6" class="indexterm"></a><a id="id-1.5.8.31.9.7" class="indexterm"></a><a id="id-1.5.8.31.9.8" class="indexterm"></a><a id="id-1.5.8.31.9.9" class="indexterm"></a><a id="id-1.5.8.31.9.10" class="indexterm"></a><a id="id-1.5.8.31.9.11" class="indexterm"></a><div class="table" id="FUNCTIONS-ADMIN-DBSIZE"><p class="title"><strong>表 9.89. 数据库对象尺寸函数</strong></p><div class="table-contents"><table class="table" summary="数据库对象尺寸函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">pg_column_size(<code class="type">any</code>)</code></code></td><td><code class="type">int</code></td><td>存储一个特定值（可能压缩过）所需的字节数</td></tr><tr><td>
        <code class="literal"><code class="function">pg_database_size(<code class="type">oid</code>)</code></code>
        </td><td><code class="type">bigint</code></td><td>指定 OID 的数据库使用的磁盘空间</td></tr><tr><td>
        <code class="literal"><code class="function">pg_database_size(<code class="type">name</code>)</code></code>
        </td><td><code class="type">bigint</code></td><td>指定名称的数据库使用的磁盘空间</td></tr><tr><td>
        <code class="literal"><code class="function">pg_indexes_size(<code class="type">regclass</code>)</code></code>
        </td><td><code class="type">bigint</code></td><td>
        附加到指定表的索引所占的总磁盘空间
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_relation_size(<em class="parameter"><code>relation</code></em> <code class="type">regclass</code>, <em class="parameter"><code>fork</code></em> <code class="type">text</code>)</code></code>
        </td><td><code class="type">bigint</code></td><td>
        指定表或索引的指定分叉（<code class="literal">'main'</code>、<code class="literal">'fsm'</code>、<code class="literal">'vm'</code>或<code class="literal">'init'</code>）使用的磁盘空间
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_relation_size(<em class="parameter"><code>relation</code></em> <code class="type">regclass</code>)</code></code>
        </td><td><code class="type">bigint</code></td><td>
        <code class="literal">pg_relation_size(..., 'main')的简写</code>
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_size_bytes(<code class="type">text</code>)</code></code>
        </td><td><code class="type">bigint</code></td><td>
         把人类可读格式的带有单位的尺寸转换成字节数
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_size_pretty(<code class="type">bigint</code>)</code></code>
        </td><td><code class="type">text</code></td><td>
         将表示成一个 64位整数的字节尺寸转换为带尺寸单位的人类可读格式
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_size_pretty(<code class="type">numeric</code>)</code></code>
        </td><td><code class="type">text</code></td><td>
         将表示成一个数字值的字节尺寸转换为带尺寸单位的人类可读格式
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_table_size(<code class="type">regclass</code>)</code></code>
        </td><td><code class="type">bigint</code></td><td>
        被指定表使用的磁盘空间，排除索引（但包括 TOAST、空闲空间映射和可见性映射）
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_tablespace_size(<code class="type">oid</code>)</code></code>
        </td><td><code class="type">bigint</code></td><td>指定 OID 的表空间使用的磁盘空间</td></tr><tr><td>
        <code class="literal"><code class="function">pg_tablespace_size(<code class="type">name</code>)</code></code>
        </td><td><code class="type">bigint</code></td><td>指定名称的表空间使用的磁盘空间</td></tr><tr><td>
        <code class="literal"><code class="function">pg_total_relation_size(<code class="type">regclass</code>)</code></code>
        </td><td><code class="type">bigint</code></td><td>
        指定表所用的总磁盘空间，包括所有的索引和<acronym class="acronym">TOAST</acronym>数据
       </td></tr></tbody></table></div></div><br class="table-break" /><p>
    <code class="function">pg_column_size</code>显示用于存储任意独立数据值的空间。
   </p><p>
    <code class="function">pg_total_relation_size</code>接受一个表或 TOAST 表的 OID 或名称，并返回该表所使用的总磁盘空间，包括所有相关的索引。这个函数等价于<code class="function">pg_table_size</code> <code class="literal">+</code> <code class="function">pg_indexes_size</code>。
   </p><p>
    <code class="function">pg_table_size</code>接受一个表的 OID 或名称，并返回该表所需的磁盘空间，但是排除索引（TOAST 空间、空闲空间映射和可见性映射包含在内）
   </p><p>
    <code class="function">pg_indexes_size</code>接受一个表的 OID 或名称，并返回附加到该表的所有索引所使用的全部磁盘空间。
   </p><p>
    <code class="function">pg_database_size</code>以及<code class="function">pg_tablespace_size</code>接受数据库或者表空间的OID或者名称，并且返回它们使用的磁盘空间。要使用<code class="function">pg_database_size</code>，用户必须具有指定数据库上的<code class="literal">CONNECT</code>权限（默认情况下已经被授予）或者是<code class="literal">pg_read_all_stats</code>角色的一个成员。要使用<code class="function">pg_tablespace_size</code>，用户必须具有指定表空间上的<code class="literal">CREATE</code>权限或者是<code class="literal">pg_read_all_stats</code>角色的一个成员，除非该表空间是当前数据库的默认表空间。
   </p><p>
    <code class="function">pg_relation_size</code>接受一个表、索引或 TOAST 表的 OID
    或者名称，并且返回那个关系的一个分叉所占的磁盘空间的字节尺寸（注意
    对于大部分目的，使用更高层的函数<code class="function">pg_total_relation_size</code>
    或者<code class="function">pg_table_size</code>会更方便，它们会合计所有分叉的尺寸）。
    如果只得到一个参数，它会返回该关系的主数据分叉的尺寸。提供第二个参数
    可以指定要检查哪个分叉：
    </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: disc; "><li class="listitem"><p>
       <code class="literal">'main'</code>返回该关系主数据分叉的尺寸。
      </p></li><li class="listitem"><p>
       <code class="literal">'fsm'</code>返回与该关系相关的空闲空间映射（见
       <a class="xref" href="storage-fsm.html" title="68.3. 空闲空间映射">第 68.3 节</a>）的尺寸。
      </p></li><li class="listitem"><p>
       <code class="literal">'vm'</code>返回与该关系相关的可见性映射（见
       <a class="xref" href="storage-vm.html" title="68.4. 可见性映射">第 68.4 节</a>）的尺寸。
      </p></li><li class="listitem"><p>
       <code class="literal">'init'</code>返回与该关系相关的初始化分叉（如
       果有）的尺寸。
      </p></li></ul></div><p>
   </p><p>
    <code class="function">pg_size_pretty</code>可以用于把其它函数之一的结果格式化成一种人类易读的格式，可以根据情况使用字节、kB、MB、GB 或者 TB。
   </p><p>
    <code class="function">pg_size_bytes</code>可以被用来从人类可读格式的字符串得到其中所表示的字节数。其输入可能带有的单位包括字节、kB、MB、GB 或者 TB，并且对输入进行解析时是区分大小写的。如果没有指定单位，会假定单位为字节。
   </p><div class="note"><h3 class="title">注意</h3><p>
     函数<code class="function">pg_size_pretty</code>和<code class="function">pg_size_bytes</code>所使用的单位 kB、MB、GB 和 TB 是用 2 的幂而不是 10 的幂来定义，因此 1kB 是 1024 字节，1MB 是 1024<sup>2</sup> = 1048576 字节，以此类推。
    </p></div><p>
    上述操作表和索引的函数接受一个<code class="type">regclass</code>参数，它是该表或索引在<code class="structname">pg_class</code>系统目录中的 OID。你不必手工去查找该 OID，因为<code class="type">regclass</code>数据类型的输入转换器会为你代劳。只写包围在单引号内的表名，这样它看起来像一个文字常量。为了与普通<acronym class="acronym">SQL</acronym>名称的处理相兼容，该字符串将被转换为小写形式，除非其中在表名周围包含双引号。
   </p><p>
    如果一个 OID 不表示一个已有的对象并且被作为参数传递给了上述函数，将会返回 NULL。
   </p><p>
    <a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-DBLOCATION" title="表 9.90. 数据库对象定位函数">表 9.90</a>中展示的函数帮助标识数据库对象相关的磁盘文件。
   </p><a id="id-1.5.8.31.9.25" class="indexterm"></a><a id="id-1.5.8.31.9.26" class="indexterm"></a><a id="id-1.5.8.31.9.27" class="indexterm"></a><div class="table" id="FUNCTIONS-ADMIN-DBLOCATION"><p class="title"><strong>表 9.90. 数据库对象定位函数</strong></p><div class="table-contents"><table class="table" summary="数据库对象定位函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <code class="literal"><code class="function">pg_relation_filenode(<em class="parameter"><code>relation</code></em> <code class="type">regclass</code>)</code></code>
        </td><td><code class="type">oid</code></td><td>
        指定关系的文件结点号
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_relation_filepath(<em class="parameter"><code>relation</code></em> <code class="type">regclass</code>)</code></code>
        </td><td><code class="type">text</code></td><td>
        指定关系的文件路径名
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_filenode_relation(<em class="parameter"><code>tablespace</code></em> <code class="type">oid</code>, <em class="parameter"><code>filenode</code></em> <code class="type">oid</code>)</code></code>
        </td><td><code class="type">regclass</code></td><td>
        查找与给定的表空间和文件节点相关的关系
       </td></tr></tbody></table></div></div><br class="table-break" /><p>
    <code class="function">pg_relation_filenode</code>接受一个表、索引、序列或 TOAST 表的 OID 或名称，返回当前分配给它的<span class="quote">“<span class="quote">filenode</span>”</span>号。文件结点是关系的文件名的基本组件（详见<a class="xref" href="storage-file-layout.html" title="68.1. 数据库文件布局">第 68.1 节</a>）。对于大多数表结果和<code class="structname">pg_class</code>.<code class="structfield">relfilenode</code>相同，但是对于某些系统目录<code class="structfield">relfilenode</code>为零，并且必须使用此函数获取正确的值。 如果传递一个没有存储的关系（如视图），此函数将返回 NULL。
   </p><p>
    <code class="function">pg_relation_filepath</code>与<code class="function">pg_relation_filenode</code>类似，但是它返回关系的整个文件路径名（相对于数据库集簇的数据目录<code class="varname">PGDATA</code>）。
   </p><p>
    <code class="function">pg_filenode_relation</code>是<code class="function">pg_relation_filenode</code>的反向函数。给定一个<span class="quote">“<span class="quote">tablespace</span>”</span> OID 以及一个 <span class="quote">“<span class="quote">filenode</span>”</span>，它会返回相关关系的 OID。对于一个在数据库的默认表空间中的表，该表空间可以指定为 0。
   </p><p>
    <a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-COLLATION" title="表 9.91. 排序规则管理函数">表 9.91</a>列出了用来管理排序规则的函数。
   </p><div class="table" id="FUNCTIONS-ADMIN-COLLATION"><p class="title"><strong>表 9.91. 排序规则管理函数</strong></p><div class="table-contents"><table class="table" summary="排序规则管理函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <a id="id-1.5.8.31.9.33.2.2.1.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_collation_actual_version(<code class="type">oid</code>)</code></code>
       </td><td><code class="type">text</code></td><td>返回来自操作系统的排序规则的实际版本</td></tr><tr><td>
        <a id="id-1.5.8.31.9.33.2.2.2.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_import_system_collations(<em class="parameter"><code>schema</code></em> <code class="type">regnamespace</code>)</code></code>
       </td><td><code class="type">integer</code></td><td>导入操作系统排序规则</td></tr></tbody></table></div></div><br class="table-break" /><p>
    <code class="function">pg_collation_actual_version</code>返回当前安装在操作系统中的该排序规则对象的实际版本。如果这个版本与<code class="literal">pg_collation.collversion</code>中的值不同，则依赖于该排序规则的对象可能需要被重建。还可以参考<a class="xref" href="sql-altercollation.html" title="ALTER COLLATION"><span class="refentrytitle">ALTER COLLATION</span></a>。
   </p><p>
    <code class="function">pg_import_system_collations</code>基于在操作系统中找到的所有locale在系统目录<code class="literal">pg_collation</code>中加入排序规则。这是<code class="command">initdb</code>会使用的函数，更多细节请参考<a class="xref" href="collation.html#COLLATION-MANAGING" title="23.2.2. 管理排序规则">第 23.2.2 节</a>。如果后来在操作系统上安装了额外的locale，可以再次运行这个函数加入新locale的排序规则。匹配<code class="literal">pg_collation</code>中现有项的locale将被跳过（但是这个函数不会移除以在操作系统中不再存在的locale为基础的排序规则对象）。<em class="parameter"><code>schema</code></em>参数通常是<code class="literal">pg_catalog</code>，但这不是一种要求，排序规则也可以被安装到其他的方案中。该函数返回其创建的新排序规则对象的数量。
   </p><div class="table" id="FUNCTIONS-INFO-PARTITION"><p class="title"><strong>表 9.92. 分区信息函数</strong></p><div class="table-contents"><table class="table" summary="分区信息函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <a id="id-1.5.8.31.9.36.2.2.1.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_partition_tree(<code class="type">regclass</code>)</code></code>
       </td><td><code class="type">setof record</code></td><td>
        列出一个分区树中的表或索引的相关信息。给定的分区表或分区索引，每张表有一行 分区。 提供的信息包括分区的名称，它的直系父级的名称，一个布尔值，表示该分区是否是一个叶子，以及一个整数，表示它在层次结构中的级别。level的值从<code class="literal">0</code>开始，表示输入表或索引作为分区树的根，<code class="literal">1</code>表示其分区，<code class="literal">2</code>表示其分区，以此类推。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.9.36.2.2.2.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_partition_ancestors(<code class="type">regclass</code>)</code></code>
       </td><td><code class="type">setof regclass</code></td><td>
        列出给定分区的祖先关系，包括分区本身。
       </td></tr><tr><td>
        <a id="id-1.5.8.31.9.36.2.2.3.1.1" class="indexterm"></a>
        <code class="literal"><code class="function">pg_partition_root(<code class="type">regclass</code>)</code></code>
       </td><td><code class="type">regclass</code></td><td>
        R返回给定关系所属的分区树的最上层父节点。
       </td></tr></tbody></table></div></div><br class="table-break" /><p>
    要检查<a class="xref" href="ddl-partitioning.html#DDL-PARTITIONING-DECLARATIVE-EXAMPLE" title="5.11.2.1. 例子">第 5.11.2.1 节</a>中描述的<code class="structname">measurement</code>表中的数据的总大小，可以使用下面的查询:
   </p><pre class="programlisting">
=# SELECT pg_size_pretty(sum(pg_relation_size(relid))) AS total_size
     FROM pg_partition_tree('measurement');
 total_size 
------------
 24 kB
(1 row)
</pre></div><div class="sect2" id="FUNCTIONS-ADMIN-INDEX"><div class="titlepage"><div><div><h3 class="title">9.26.8. 索引维护函数</h3></div></div></div><a id="id-1.5.8.31.10.2" class="indexterm"></a><a id="id-1.5.8.31.10.3" class="indexterm"></a><a id="id-1.5.8.31.10.4" class="indexterm"></a><a id="id-1.5.8.31.10.5" class="indexterm"></a><p>
    <a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-INDEX-TABLE" title="表 9.93. 索引维护函数">表 9.93</a>展示了可用于 索引维护任务的函数。这些函数不能在恢复期间执行。只有超级用户以及给定索引的拥有者才能是用这些函数。
   </p><div class="table" id="FUNCTIONS-ADMIN-INDEX-TABLE"><p class="title"><strong>表 9.93. 索引维护函数</strong></p><div class="table-contents"><table class="table" summary="索引维护函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <code class="literal"><code class="function">brin_summarize_new_values(<em class="parameter"><code>index</code></em> <code class="type">regclass</code>)</code></code>
       </td><td><code class="type">integer</code></td><td>对还没有建立概要的页面范围建立概要</td></tr><tr><td>
        <code class="literal"><code class="function">brin_summarize_range(<em class="parameter"><code>index</code></em> <code class="type">regclass</code>, <em class="parameter"><code>blockNumber</code></em> <code class="type">bigint</code>)</code></code>
       </td><td><code class="type">integer</code></td><td>如果还没有对覆盖给定块的页面范围建立概要，则对其建立概要</td></tr><tr><td>
        <code class="literal"><code class="function">brin_desummarize_range(<em class="parameter"><code>index</code></em> <code class="type">regclass</code>, <em class="parameter"><code>blockNumber</code></em> <code class="type">bigint</code>)</code></code>
       </td><td><code class="type">integer</code></td><td>如果覆盖给定块的页面范围已经建立有概要，则去掉概要</td></tr><tr><td>
        <code class="literal"><code class="function">gin_clean_pending_list(<em class="parameter"><code>index</code></em> <code class="type">regclass</code>)</code></code>
       </td><td><code class="type">bigint</code></td><td>把 GIN 待处理列表项移动到主索引结构中</td></tr></tbody></table></div></div><br class="table-break" /><p>
    <code class="function">brin_summarize_new_values</code>接收一个 BRIN 索引的 OID 或者名称作为参数并且检查该索引以找到基表中当前还没有被该索引汇总的页面范围。对任意一个这样的范围，它将通过扫描那些表页面创建一个新的摘要索引元组。它会返回被插入到该索引的新页面范围摘要的数量。<code class="function">brin_summarize_range</code>做同样的事情，不过它只对覆盖给定块号的范围建立概要。
   </p><p>
    <code class="function">gin_clean_pending_list</code>接受一个 GIN 索引的 OID 或者名字，并且通过把指定索引的待处理列表中的项批量移动到主 GIN 数据结构来清理该索引的待处理列表。它会返回从待处理列表中移除的页数。注意如果其参数是一个禁用<code class="literal">fastupdate</code>选项构建的 GIN 索引，那么不会做清理并且返回值为 0，因为该索引根本没有待处理列表。有关待处理列表和<code class="literal">fastupdate</code>选项的细节请见<a class="xref" href="gin-implementation.html#GIN-FAST-UPDATE" title="66.4.1. GIN 快速更新技术">第 66.4.1 节</a>和<a class="xref" href="gin-tips.html" title="66.5. GIN 提示和技巧">第 66.5 节</a>。
   </p></div><div class="sect2" id="FUNCTIONS-ADMIN-GENFILE"><div class="titlepage"><div><div><h3 class="title">9.26.9. 通用文件访问函数</h3></div></div></div><p>
    <a class="xref" href="functions-admin.html#FUNCTIONS-ADMIN-GENFILE-TABLE" title="表 9.94. 通用文件访问函数">表 9.94</a>中展示的函数提供了对数据库服务器所在机器上的文件的本地访问。只能访问数据库集簇目录以及<code class="varname">log_directory</code>中的文件，除非用户被授予了角色<code class="literal">pg_read_server_files</code>。 使用相对路径访问集簇目录里面的文件，以及匹配 <code class="varname">log_directory</code>配置设置的路径访问日志文件。
   </p><p>
    注意向用户授予<code class="function">pg_read_file()</code>或者相关函数上的EXECUTE特权，函数会允许他们读取服务器上该数据库能读取的任何文件并且这些读取动作会绕过所有的数据库内特权检查。这意味着，除了别的之外，具有这种访问的用户能够读取<code class="literal">pg_authid</code>表中包含着认证信息的内容，也能读取数据库中的任意文件。因此，授予对这些函数的访问应该要很仔细地考虑。
   </p><div class="table" id="FUNCTIONS-ADMIN-GENFILE-TABLE"><p class="title"><strong>表 9.94. 通用文件访问函数</strong></p><div class="table-contents"><table class="table" summary="通用文件访问函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <code class="literal"><code class="function">pg_ls_dir(<em class="parameter"><code>dirname</code></em> <code class="type">text</code> [, <em class="parameter"><code>missing_ok</code></em> <code class="type">boolean</code>, <em class="parameter"><code>include_dot_dirs</code></em> <code class="type">boolean</code>])</code></code>
       </td><td><code class="type">setof text</code></td><td>列出目录中的内容。默认仅限于超级用户使用，但是可以给其他用户授予EXECUTE让他们运行这个函数。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_ls_logdir()</code></code>
       </td><td><code class="type">setof record</code></td><td>
        列出日志目录中文件的名称、尺寸以及最后修改时间。访问被授予给<code class="literal">pg_monitor</code>角色的成员，并且可以被授予给其他非超级用户角色。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_ls_waldir()</code></code>
       </td><td><code class="type">setof record</code></td><td>
        列出WAL目录中文件的名称、尺寸以及最后修改时间。访问被授予给<code class="literal">pg_monitor</code>角色的成员，并且可以被授予给其他非超级用户角色。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_ls_archive_statusdir()</code></code>
       </td><td><code class="type">setof record</code></td><td>
        列出WAL存档状态目录中文件的名称、大小和最后一次修改时间。访问权限只授予<code class="literal">pg_monitor</code>角色的成员，也可以授予其他非超级用户角色。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_ls_tmpdir([<span class="optional"><em class="parameter"><code>tablespace</code></em> <code class="type">oid</code></span>])</code></code>
       </td><td><code class="type">setof record</code></td><td>
        为<em class="parameter"><code>tablespace</code></em>列出临时目录中文件的名称、大小和最后一次修改时间。 如果没有提供<em class="parameter"><code>tablespace</code></em>，则在临时目录中的
<code class="literal">pg_default</code>表空间被使用。 <code class="literal">pg_monitor</code>角色的成员可以访问，其他非超级用户角色也可以访问。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_read_file(<em class="parameter"><code>filename</code></em> <code class="type">text</code> [, <em class="parameter"><code>offset</code></em> <code class="type">bigint</code>, <em class="parameter"><code>length</code></em> <code class="type">bigint</code> [, <em class="parameter"><code>missing_ok</code></em> <code class="type">boolean</code>] ])</code></code>
       </td><td><code class="type">text</code></td><td>返回一个文本文件的内容。默认仅限于超级用户使用，但是可以给其他用户授予EXECUTE让他们运行这个函数。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_read_binary_file(<em class="parameter"><code>filename</code></em> <code class="type">text</code> [, <em class="parameter"><code>offset</code></em> <code class="type">bigint</code>, <em class="parameter"><code>length</code></em> <code class="type">bigint</code> [, <em class="parameter"><code>missing_ok</code></em> <code class="type">boolean</code>] ])</code></code>
       </td><td><code class="type">bytea</code></td><td>返回一个文件的内容。默认仅限于超级用户使用，但是可以给其他用户授予EXECUTE让他们运行这个函数。
       </td></tr><tr><td>
        <code class="literal"><code class="function">pg_stat_file(<em class="parameter"><code>filename</code></em> <code class="type">text</code>[, <em class="parameter"><code>missing_ok</code></em> <code class="type">boolean</code>])</code></code>
       </td><td><code class="type">record</code></td><td>返回关于一个文件的信息。默认仅限于超级用户使用，但是可以给其他用户授予EXECUTE让他们运行这个函数。
       </td></tr></tbody></table></div></div><br class="table-break" /><p>
    这些函数中的某些有一个可选的<em class="parameter"><code>missing_ok</code></em>参数，
    它指定文件或者目录不存在时的行为。如果为<code class="literal">true</code>，
    函数会返回 NULL （<code class="function">pg_ls_dir</code>除外，它返回一个空
    结果集）。如果为<code class="literal">false</code>，则发生一个错误。默认是
    <code class="literal">false</code>。
   </p><a id="id-1.5.8.31.11.6" class="indexterm"></a><p>
    <code class="function">pg_ls_dir</code>返回指定目录中所有文件（以及目录和其他特殊文件）
    的名称。<em class="parameter"><code>include_dot_dirs</code></em>指示结果集中是否包括
    <span class="quote">“<span class="quote">.</span>”</span>和<span class="quote">“<span class="quote">..</span>”</span>。默认是排除它们（<code class="literal">false</code>），但是
    当<em class="parameter"><code>missing_ok</code></em>为<code class="literal">true</code>时把它们包括在内是
    有用的，因为可以把一个空目录与一个不存在的目录区分开。
   </p><a id="id-1.5.8.31.11.8" class="indexterm"></a><p>
    <code class="function">pg_ls_logdir</code>返回日志目录中每个文件的名称、尺寸以及最后的修改时间（mtime）。默认情况下，只有超级用户以及<code class="literal">pg_monitor</code>角色的成员能够使用这个函数。可以使用<code class="command">GRANT</code>把访问授予给其他人。 
   </p><a id="id-1.5.8.31.11.10" class="indexterm"></a><p>
    <code class="function">pg_ls_waldir</code>返回预写式日志（WAL）目录中每个文件的名称、尺寸以及最后的修改时间（mtime）。默认情况下，只有超级用户以及<code class="literal">pg_monitor</code>角色的成员能够使用这个函数。可以使用<code class="command">GRANT</code>把访问授予给其他人。
   </p><a id="id-1.5.8.31.11.12" class="indexterm"></a><p>
    <code class="function">pg_ls_archive_statusdir</code>返回WAL归档状态目录<code class="filename">pg_wal/archive_status</code>中每个文件的名称、大小和最后一次修改时间（mtime）。默认情况下，只有超级用户和<code class="literal">pg_monitor</code>角色的成员才能使用此函数。可使用<code class="command">GRANT</code>授权其他用户访问。
    
   </p><a id="id-1.5.8.31.11.14" class="indexterm"></a><p>
    <code class="function">pg_ls_tmpdir</code>返回指定的<em class="parameter"><code>tablespace</code></em>临时文件目录中每个文件的名称、大小和最后一次修改时间（mtime）。 如果没有提供<em class="parameter"><code>tablespace</code></em>，则使用<code class="literal">pg_default</code>表空间。 默认情况下，只有超级用户和<code class="literal">pg_monitor</code>角色的成员才能使用这个函数。 可使用<code class="command">GRANT</code>授权其他用户访问。
   </p><a id="id-1.5.8.31.11.16" class="indexterm"></a><p>
    <code class="function">pg_read_file</code>返回一个文本文件的一部分，从给定的<em class="parameter"><code>offset</code></em>开始，返回最多<em class="parameter"><code>length</code></em>字节（如果先到达文件末尾则会稍短）。如果<em class="parameter"><code>offset</code></em>为负，它相对于文件的末尾。如果<em class="parameter"><code>offset</code></em>和<em class="parameter"><code>length</code></em>被忽略，整个文件都被返回。从文件中读的字节被使用服务器编码解释成一个字符串；如果它们在编码中不合法则抛出一个错误。
   </p><a id="id-1.5.8.31.11.18" class="indexterm"></a><p>
    <code class="function">pg_read_binary_file</code>与<code class="function">pg_read_file</code>相似，除了前者的结果是一个<code class="type">bytea</code>值；相应地，不会执行编码检查。通过与<code class="function">convert_from</code>函数结合，这个函数可以用来读取一个指定编码的文件：
</p><pre class="programlisting">
SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');
</pre><p>
   </p><a id="id-1.5.8.31.11.20" class="indexterm"></a><p>
    <code class="function">pg_stat_file</code>返回一个记录，其中包含文件尺寸、最后访问时间戳、最后修改时间戳、最后文件状态改变时间戳（只支持 Unix 平台）、文件创建时间戳（只支持 Windows）和一个<code class="type">boolean</code>指示它是否为目录。通常的用法包括：
</p><pre class="programlisting">
SELECT * FROM pg_stat_file('filename');
SELECT (pg_stat_file('filename')).modification;
</pre><p>
   </p></div><div class="sect2" id="FUNCTIONS-ADVISORY-LOCKS"><div class="titlepage"><div><div><h3 class="title">9.26.10. 咨询锁函数</h3></div></div></div><p>
    <a class="xref" href="functions-admin.html#FUNCTIONS-ADVISORY-LOCKS-TABLE" title="表 9.95. 咨询锁函数">表 9.95</a>中展示的函数管理咨询锁。有关正确使用这些函数的细节请参考<a class="xref" href="explicit-locking.html#ADVISORY-LOCKS" title="13.3.5. 咨询锁">第 13.3.5 节</a>。
   </p><div class="table" id="FUNCTIONS-ADVISORY-LOCKS-TABLE"><p class="title"><strong>表 9.95. 咨询锁函数</strong></p><div class="table-contents"><table class="table" summary="咨询锁函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>
        <code class="literal"><code class="function">pg_advisory_lock(<em class="parameter"><code>key</code></em> <code class="type">bigint</code>)</code></code>
       </td><td><code class="type">void</code></td><td>获得排他会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_advisory_lock(<em class="parameter"><code>key1</code></em> <code class="type">int</code>, <em class="parameter"><code>key2</code></em> <code class="type">int</code>)</code></code>
       </td><td><code class="type">void</code></td><td>获得排他会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_advisory_lock_shared(<em class="parameter"><code>key</code></em> <code class="type">bigint</code>)</code></code>
       </td><td><code class="type">void</code></td><td>获得共享会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_advisory_lock_shared(<em class="parameter"><code>key1</code></em> <code class="type">int</code>, <em class="parameter"><code>key2</code></em> <code class="type">int</code>)</code></code>
       </td><td><code class="type">void</code></td><td>获得共享会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_advisory_unlock(<em class="parameter"><code>key</code></em> <code class="type">bigint</code>)</code></code>
       </td><td><code class="type">boolean</code></td><td>释放一个排他会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_advisory_unlock(<em class="parameter"><code>key1</code></em> <code class="type">int</code>, <em class="parameter"><code>key2</code></em> <code class="type">int</code>)</code></code>
       </td><td><code class="type">boolean</code></td><td>释放一个排他会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_advisory_unlock_all()</code></code>
       </td><td><code class="type">void</code></td><td>释放当前会话持有的所有会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_advisory_unlock_shared(<em class="parameter"><code>key</code></em> <code class="type">bigint</code>)</code></code>
       </td><td><code class="type">boolean</code></td><td>释放一个共享会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_advisory_unlock_shared(<em class="parameter"><code>key1</code></em> <code class="type">int</code>, <em class="parameter"><code>key2</code></em> <code class="type">int</code>)</code></code>
       </td><td><code class="type">boolean</code></td><td>释放一个共享会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_advisory_xact_lock(<em class="parameter"><code>key</code></em> <code class="type">bigint</code>)</code></code>
       </td><td><code class="type">void</code></td><td>获得排他事务级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_advisory_xact_lock(<em class="parameter"><code>key1</code></em> <code class="type">int</code>, <em class="parameter"><code>key2</code></em> <code class="type">int</code>)</code></code>
       </td><td><code class="type">void</code></td><td>获得排他事务级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_advisory_xact_lock_shared(<em class="parameter"><code>key</code></em> <code class="type">bigint</code>)</code></code>
       </td><td><code class="type">void</code></td><td>获得共享事务级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_advisory_xact_lock_shared(<em class="parameter"><code>key1</code></em> <code class="type">int</code>, <em class="parameter"><code>key2</code></em> <code class="type">int</code>)</code></code>
       </td><td><code class="type">void</code></td><td>获得共享事务级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_try_advisory_lock(<em class="parameter"><code>key</code></em> <code class="type">bigint</code>)</code></code>
       </td><td><code class="type">boolean</code></td><td>如果可能，获得排他会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_try_advisory_lock(<em class="parameter"><code>key1</code></em> <code class="type">int</code>, <em class="parameter"><code>key2</code></em> <code class="type">int</code>)</code></code>
       </td><td><code class="type">boolean</code></td><td>如果可能，获得排他会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_try_advisory_lock_shared(<em class="parameter"><code>key</code></em> <code class="type">bigint</code>)</code></code>
       </td><td><code class="type">boolean</code></td><td>如果可能，获得共享会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_try_advisory_lock_shared(<em class="parameter"><code>key1</code></em> <code class="type">int</code>, <em class="parameter"><code>key2</code></em> <code class="type">int</code>)</code></code>
       </td><td><code class="type">boolean</code></td><td>如果可能，获得共享会话级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_try_advisory_xact_lock(<em class="parameter"><code>key</code></em> <code class="type">bigint</code>)</code></code>
       </td><td><code class="type">boolean</code></td><td>如果可能，获得排他事务级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_try_advisory_xact_lock(<em class="parameter"><code>key1</code></em> <code class="type">int</code>, <em class="parameter"><code>key2</code></em> <code class="type">int</code>)</code></code>
       </td><td><code class="type">boolean</code></td><td>如果可能，获得排他事务级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_try_advisory_xact_lock_shared(<em class="parameter"><code>key</code></em> <code class="type">bigint</code>)</code></code>
       </td><td><code class="type">boolean</code></td><td>如果可能，获得共享事务级别咨询锁</td></tr><tr><td>
        <code class="literal"><code class="function">pg_try_advisory_xact_lock_shared(<em class="parameter"><code>key1</code></em> <code class="type">int</code>, <em class="parameter"><code>key2</code></em> <code class="type">int</code>)</code></code>
       </td><td><code class="type">boolean</code></td><td>如果可能，获得共享事务级别咨询锁</td></tr></tbody></table></div></div><br class="table-break" /><a id="id-1.5.8.31.12.4" class="indexterm"></a><p>
    <code class="function">pg_advisory_lock</code>锁住一个应用定义的资源，可以使用一个单一64位键值或两个32位键值标识（注意这些两个键空间不重叠）。如果另一个会话已经在同一个资源标识符上持有了一个锁，这个函数将等待直到该资源变成可用。该锁是排他的。多个锁请求会入栈，因此如果同一个资源被锁住三次，则它必须被解锁三次来被释放给其他会话使用。
   </p><a id="id-1.5.8.31.12.6" class="indexterm"></a><p>
    <code class="function">pg_advisory_lock_shared</code>的工作和<code class="function">pg_advisory_lock</code>相同，不过该锁可以与其他请求共享锁的会话共享。只有想要排他的锁请求会被排除。
   </p><a id="id-1.5.8.31.12.8" class="indexterm"></a><p>
    <code class="function">pg_try_advisory_lock</code>与<code class="function">pg_advisory_lock</code>相似，不过该函数将不会等待锁变为可用。它要么立刻获得锁并返回<code class="literal">true</code>，要么不能立即获得锁并返回<code class="literal">false</code>。
   </p><a id="id-1.5.8.31.12.10" class="indexterm"></a><p>
    <code class="function">pg_try_advisory_lock_shared</code>的工作和<code class="function">pg_try_advisory_lock</code>相同，不过它尝试获得一个共享锁而不是一个排他锁。
   </p><a id="id-1.5.8.31.12.12" class="indexterm"></a><p>
    <code class="function">pg_advisory_unlock</code>将会释放之前获得的排他会话级别咨询锁。如果锁被成功释放，它返回<code class="literal">true</code>。如果锁没有被持有，它将返回<code class="literal">false</code>并且额外由服务器报告一个 SQL 警告。
   </p><a id="id-1.5.8.31.12.14" class="indexterm"></a><p>
    <code class="function">pg_advisory_unlock_shared</code>的工作和<code class="function">pg_advisory_unlock</code>相同，除了它释放一个共享的会话级别咨询锁。
   </p><a id="id-1.5.8.31.12.16" class="indexterm"></a><p>
    <code class="function">pg_advisory_unlock_all</code>将释放当前会话所持有的所有会话级别咨询锁（这个函数隐式地在会话末尾被调用，即使客户端已经不雅地断开）。
   </p><a id="id-1.5.8.31.12.18" class="indexterm"></a><p>
    <code class="function">pg_advisory_xact_lock</code>的工作和<code class="function">pg_advisory_lock</code>相同，不过锁是在当前事务的末尾被自动释放的并且不能被显式释放。
   </p><a id="id-1.5.8.31.12.20" class="indexterm"></a><p>
    <code class="function">pg_advisory_xact_lock_shared</code>的工作和<code class="function">pg_advisory_lock_shared</code>相同，除了锁是在当前事务的末尾自动被释放的并且不能被显式释放。
   </p><a id="id-1.5.8.31.12.22" class="indexterm"></a><p>
    <code class="function">pg_try_advisory_xact_lock</code>的工作和<code class="function">pg_try_advisory_lock</code>相同，不过锁（若果获得）是在当前事务的末尾被自动释放的并且不能被显式释放。
   </p><a id="id-1.5.8.31.12.24" class="indexterm"></a><p>
    <code class="function">pg_try_advisory_xact_lock_shared</code>的工作和<code class="function">pg_try_advisory_lock_shared</code>相同，不过锁（若果获得）是在当前事务的末尾被自动释放的并且不能被显式释放。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="functions-info.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="functions.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="functions-trigger.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">9.25. 系统信息函数和运算符 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 9.27. 触发器函数</td></tr></table></div></body></html>