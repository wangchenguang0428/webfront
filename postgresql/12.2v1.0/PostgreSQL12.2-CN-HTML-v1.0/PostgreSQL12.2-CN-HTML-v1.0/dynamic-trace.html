<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>27.5. 动态追踪</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="progress-reporting.html" title="27.4. 进度报告" /><link rel="next" href="diskusage.html" title="第 28 章 监控磁盘使用" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">27.5. 动态追踪</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="progress-reporting.html" title="27.4. 进度报告">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="monitoring.html" title="第 27 章 监控数据库活动">上一级</a></td><th width="60%" align="center">第 27 章 监控数据库活动</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="diskusage.html" title="第 28 章 监控磁盘使用">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="DYNAMIC-TRACE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">27.5. 动态追踪</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="dynamic-trace.html#COMPILING-FOR-TRACE">27.5.1. 动态追踪的编译</a></span></dt><dt><span class="sect2"><a href="dynamic-trace.html#TRACE-POINTS">27.5.2. 内建探针</a></span></dt><dt><span class="sect2"><a href="dynamic-trace.html#USING-TRACE-POINTS">27.5.3. 使用探针</a></span></dt><dt><span class="sect2"><a href="dynamic-trace.html#DEFINING-TRACE-POINTS">27.5.4. 定义新探针</a></span></dt></dl></div><a id="id-1.6.14.10.2" class="indexterm"></a><p>
   <span class="productname">PostgreSQL</span>提供了功能来支持数据库服务器的动态追踪。这样就允许在代码中的特 定点上调用外部工具来追踪执行过程。
  </p><p>
   一些探针或追踪点已经被插入在源代码中。这些探针的目的是被数据库开发者和管理员使用。默认情况下，探针不被编译到<span class="productname">PostgreSQL</span>中；用户需要显式地告诉配置脚本使得探针可用。
  </p><p>
   目前，在写本文当时<a class="ulink" href="https://en.wikipedia.org/wiki/DTrace" target="_top">DTrace</a>已被支持，它在 Solaris、macOS、FreeBSD、NetBSD 和 Oracle Linux 上可用。Linux 的<a class="ulink" href="http://sourceware.org/systemtap/" target="_top">SystemTap</a>项目提供了一种可用的 DTrace 等价物。支持其他动态追踪工具在理论上可以通过改变<code class="filename">src/include/utils/probes.h</code>中的宏定义实现。
  </p><div class="sect2" id="COMPILING-FOR-TRACE"><div class="titlepage"><div><div><h3 class="title">27.5.1. 动态追踪的编译</h3></div></div></div><p>
   默认情况下，探针是不可用的，因此你将需要显式地告诉配置脚本让探针在<span class="productname">PostgreSQL</span>中可用。要包括 DTrace 支持，在配置时指定<code class="option">--enable-dtrace</code>。更多信息请见<a class="xref" href="install-procedure.html" title="16.4. 安装过程">第 16.4 节</a>。
  </p></div><div class="sect2" id="TRACE-POINTS"><div class="titlepage"><div><div><h3 class="title">27.5.2. 内建探针</h3></div></div></div><p>
   如<a class="xref" href="dynamic-trace.html#DTRACE-PROBE-POINT-TABLE" title="表 27.28. 内建 DTrace 探针">表 27.28</a>所示，源代码中提供了一些标准探针。<a class="xref" href="dynamic-trace.html#TYPEDEFS-TABLE" title="表 27.29. 定义用在探针参数中的类型">表 27.29</a>显式了在探针中使用的类型。当然，可以增加更多探针来增强<span class="productname">PostgreSQL</span>的可观测性。
  </p><div class="table" id="DTRACE-PROBE-POINT-TABLE"><p class="title"><strong>表 27.28. 内建 DTrace 探针</strong></p><div class="table-contents"><table class="table" summary="内建 DTrace 探针" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal">transaction-start</code></td><td><code class="literal">(LocalTransactionId)</code></td><td>在一个新事务开始时触发的探针。arg0 是事务 ID。</td></tr><tr><td><code class="literal">transaction-commit</code></td><td><code class="literal">(LocalTransactionId)</code></td><td>在一个事务成功完成时触发的探针。arg0 是事务 ID。</td></tr><tr><td><code class="literal">transaction-abort</code></td><td><code class="literal">(LocalTransactionId)</code></td><td>当一个事务失败完成时触发的探针。arg0 是事务 ID。</td></tr><tr><td><code class="literal">query-start</code></td><td><code class="literal">(const char *)</code></td><td>当一个查询的处理被开始时触发的探针。arg0 是查询字符串。</td></tr><tr><td><code class="literal">query-done</code></td><td><code class="literal">(const char *)</code></td><td>当一个查询的处理完成时触发的探针。arg0 是查询字符串。</td></tr><tr><td><code class="literal">query-parse-start</code></td><td><code class="literal">(const char *)</code></td><td>当一个查询的解析被开始时触发的探针。arg0 是查询字符串。</td></tr><tr><td><code class="literal">query-parse-done</code></td><td><code class="literal">(const char *)</code></td><td>当一个查询的解析完成时触发的探针。arg0 是查询字符串。</td></tr><tr><td><code class="literal">query-rewrite-start</code></td><td><code class="literal">(const char *)</code></td><td>当一个查询的重写被开始时触发的探针。arg0 是查询字符串。</td></tr><tr><td><code class="literal">query-rewrite-done</code></td><td><code class="literal">(const char *)</code></td><td>当一个查询的重写完成时触发的探针。arg0 是查询字符串。</td></tr><tr><td><code class="literal">query-plan-start</code></td><td><code class="literal">()</code></td><td>当一个查询的规划被开始时触发的探针。</td></tr><tr><td><code class="literal">query-plan-done</code></td><td><code class="literal">()</code></td><td>当一个查询的规划完成时触发的探针。</td></tr><tr><td><code class="literal">query-execute-start</code></td><td><code class="literal">()</code></td><td>当一个查询的执行被开始时触发的探针。</td></tr><tr><td><code class="literal">query-execute-done</code></td><td><code class="literal">()</code></td><td>当一个查询的执行完成时触发的探针。</td></tr><tr><td><code class="literal">statement-status</code></td><td><code class="literal">(const char *)</code></td><td>任何时候当服务器进程更新它的<code class="structname">pg_stat_activity</code>.<code class="structfield">status</code>时触发的探针。arg0 是新的状态字符串。</td></tr><tr><td><code class="literal">checkpoint-start</code></td><td><code class="literal">(int)</code></td><td>当一个检查点被开始时触发的探针。arg0 保持逐位标志来区分不同的检查点类型，例如关闭（shutdown）、立即（immediate）或强制（force）。</td></tr><tr><td><code class="literal">checkpoint-done</code></td><td><code class="literal">(int, int, int, int, int)</code></td><td>当一个检查点完成时触发的探针（检查点处理过程中序列中列出的下一个触发的探针）。arg0 是要写的缓冲区数量。arg1 是缓冲区的总数。arg2、arg3 和 arg4 分别包含了增加、删除和循环回收的 WAL 文件的数量。</td></tr><tr><td><code class="literal">clog-checkpoint-start</code></td><td><code class="literal">(bool)</code></td><td>当一个检查点的 CLOG 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</td></tr><tr><td><code class="literal">clog-checkpoint-done</code></td><td><code class="literal">(bool)</code></td><td>当一个检查点的 CLOG 部分完成时触发的探针。arg0 的含义与<code class="literal">clog-checkpoint-start</code>中相同。</td></tr><tr><td><code class="literal">subtrans-checkpoint-start</code></td><td><code class="literal">(bool)</code></td><td>当一个检查点的 SUBTRANS 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</td></tr><tr><td><code class="literal">subtrans-checkpoint-done</code></td><td><code class="literal">(bool)</code></td><td>当一个检查点的 SUBTRANS 部分完成时触发的探针。arg0 的含义与<code class="literal">subtrans-checkpoint-start</code>中相同。</td></tr><tr><td><code class="literal">multixact-checkpoint-start</code></td><td><code class="literal">(bool)</code></td><td>当一个检查点的 MultiXact 部分被开始时触发的探针。arg0 为真表示正常检查点，为假表示关闭检查点。</td></tr><tr><td><code class="literal">multixact-checkpoint-done</code></td><td><code class="literal">(bool)</code></td><td>当一个检查点的 MultiXact 部分完成时触发的探针。arg0 的含义与<code class="literal">multixact-checkpoint-start</code>中相同。</td></tr><tr><td><code class="literal">buffer-checkpoint-start</code></td><td><code class="literal">(int)</code></td><td>当一个检查点的写缓冲区部分被开始时触发的探针。arg0 保持逐位标志来区分不同的检查点类型，例如关闭（shutdown）、立即（immediate）或强制（force）。</td></tr><tr><td><code class="literal">buffer-sync-start</code></td><td><code class="literal">(int, int)</code></td><td>当我们在检查点期间开始写脏缓冲区时（在标识哪些缓冲区必须被写之后）触发的探针。arg0 是缓冲区总数，arg1 是当前为脏并且需要被写的缓冲区数量。</td></tr><tr><td><code class="literal">buffer-sync-written</code></td><td><code class="literal">(int)</code></td><td>在检查点期间当每个缓冲区被写完之后触发的探针。arg0 是缓冲区的 ID。</td></tr><tr><td><code class="literal">buffer-sync-done</code></td><td><code class="literal">(int, int, int)</code></td><td>当所有脏缓冲区被写之后触发的探针。arg0 是缓冲区总数。arg1 是检查点进程实际写的缓冲区数量。arg2 是期望写的数目（<code class="literal">buffer-sync-start</code>的 arg1）；arg1 和 arg2 的任何的不同反映在该检查点期间有其他进程刷写了缓冲区。</td></tr><tr><td><code class="literal">buffer-checkpoint-sync-start</code></td><td><code class="literal">()</code></td><td>在脏缓冲区被写入到内核之后并且在开始发出 fsync 请求之前触发的探针。</td></tr><tr><td><code class="literal">buffer-checkpoint-done</code></td><td><code class="literal">()</code></td><td>当同步缓冲区到磁盘完成时触发的探针。</td></tr><tr><td><code class="literal">twophase-checkpoint-start</code></td><td><code class="literal">()</code></td><td>当一个检查点的两阶段部分被开始时触发的探针。</td></tr><tr><td><code class="literal">twophase-checkpoint-done</code></td><td><code class="literal">()</code></td><td>当一个检查点的两阶段部分完成时触发的探针。</td></tr><tr><td><code class="literal">buffer-read-start</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</code></td><td>当一次缓冲区读被开始时触发的探针。arg0 和 arg1 包含该页的分叉号和块号（如果这是一次关系扩展请求，arg1 为 -1）。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 <code class="symbol">InvalidBackendId</code>（-1）。表示真，对共享缓冲区表示假。 arg6 为真表示一次关系扩展请求，为假表示正常读。</td></tr><tr><td><code class="literal">buffer-read-done</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</code></td><td>当一次缓冲区读完成时触发的探测器。arg0 和 arg1 包含该页的分叉号和块号（如果这是一次关系扩展请求，arg1 现在包含新增加块的块号）。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是 <code class="symbol">InvalidBackendId</code>（-1）。表示真，对共享缓冲区表示假。 arg6 为真表示一次关系扩展请求，为假表示正常读。arg7 为真表示在池中找到该缓冲区，为假表示没有找到。</td></tr><tr><td><code class="literal">buffer-flush-start</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid)</code></td><td>在发出对一个共享缓冲区的任意写请求之前触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。</td></tr><tr><td><code class="literal">buffer-flush-done</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid)</code></td><td>当一个写请求完成时触发的探针（注意这只反映传递数据给内核的时间，它通常并没有实际地被写入到磁盘）。参数和<code class="literal">buffer-flush-start</code>的相同。</td></tr><tr><td><code class="literal">buffer-write-dirty-start</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid)</code></td><td>当一个服务器进程开始写一个脏缓冲区时触发的探针（如果这经常发生，表示<a class="xref" href="runtime-config-resource.html#GUC-SHARED-BUFFERS">shared_buffers</a>太小，或需要调整后台写入器的控制参数）。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。</td></tr><tr><td><code class="literal">buffer-write-dirty-done</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid)</code></td><td>当一次脏缓冲区写完成时触发的探针。参数与<code class="literal">buffer-write-dirty-start</code>相同。</td></tr><tr><td><code class="literal">wal-buffer-write-dirty-start</code></td><td><code class="literal">()</code></td><td>当一个服务器进程因为没有可用 WAL 缓冲区空间开始写一个脏 WAL 缓冲区时触发的探针（如果这经常发生，表示<a class="xref" href="runtime-config-wal.html#GUC-WAL-BUFFERS">wal_buffers</a>太小）。</td></tr><tr><td><code class="literal">wal-buffer-write-dirty-done</code></td><td><code class="literal">()</code></td><td>当一次脏 WAL 缓冲区完成时触发的探针。</td></tr><tr><td><code class="literal">wal-insert</code></td><td><code class="literal">(unsigned char, unsigned char)</code></td><td>当一个 WAL 记录被插入时触发的探针。arg0 是该记录的资源管理者（rmid）。arg1 包含 info 标志。</td></tr><tr><td><code class="literal">wal-switch</code></td><td><code class="literal">()</code></td><td>当请求一次 WAL 段切换时触发的探针。</td></tr><tr><td><code class="literal">smgr-md-read-start</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</code></td><td>当开始从一个关系读取一块时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是<code class="symbol">InvalidBackendId</code>（-1）。</td></tr><tr><td><code class="literal">smgr-md-read-done</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</code></td><td>当一次块读取完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是<code class="symbol">InvalidBackendId</code>（-1）。arg6 是实际读取的字节数，而 arg7 是请求读取的字节数（如果两者不同就意味着麻烦）。</td></tr><tr><td><code class="literal">smgr-md-write-start</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</code></td><td>当开始向一个关系中写入一个块时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3 和 arg4 包含表空间、数据库和关系 OID 用以识别该关系。对一个本地缓冲区，arg5 是创建临时关系的后端的 ID；对于一个共享缓冲区，arg5 是<code class="symbol">InvalidBackendId</code>（-1）。</td></tr><tr><td><code class="literal">smgr-md-write-done</code></td><td><code class="literal">(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</code></td><td>当一个块写操作完成时触发的探针。arg0 和 arg1 包含该页的分叉号和块号。arg2、arg3和arg4 包含表空间、数据库和关系 OID来标识该关系。对于一个本地缓冲区，arg5 是创建临时关系的后端 ID；对于一个共享缓冲区，arg5 是<code class="symbol">InvalidBackendId</code>（-1）。arg6 是实际写的字节数，而 arg7 是要求写的字节数（如果这两者不同，则意味着麻烦）。</td></tr><tr><td><code class="literal">sort-start</code></td><td><code class="literal">(int, bool, int, int, bool, int)</code></td><td>当一次排序操作开始时触发的探针。arg0 指示是堆排序、索引排序或数据排序。arg1 为真表示唯一值强制。arg2 是键列的数目。arg3 是允许使用的工作内存数（以千字节计）。如果要求随机访问排序结果，那么 arg4 为真。arg5为<code class="literal">0</code>时表示串行，为<code class="literal">1</code>时表示并行工作者，为<code class="literal">2</code>时表示并行领袖。</td></tr><tr><td><code class="literal">sort-done</code></td><td><code class="literal">(bool, long)</code></td><td>当一次排序完成时触发的探针。arg0 为真表示外排序，为假表示内排序。arg1 是用于一次外排序的磁盘块的数目，或用于一次内排序的以千字节计的内存。</td></tr><tr><td><code class="literal">lwlock-acquire</code></td><td><code class="literal">(char *, LWLockMode)</code></td><td>当成功获得一个 LWLock 时触发的探针。
      arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</td></tr><tr><td><code class="literal">lwlock-release</code></td><td><code class="literal">(char *)</code></td><td>当一个 LWLock 被释放时（但是注意还没有唤醒任何一个被释放的等待者）触发的探针。
     arg0 是该 LWLock 所在的切片（Tranche）。</td></tr><tr><td><code class="literal">lwlock-wait-start</code></td><td><code class="literal">(char *, LWLockMode)</code></td><td>当一个 LWLock不是当即可用并且一个服务器进程因此开始等待该锁变为可用时触发的探针。
     arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 请求的锁模式，是排他或共享。</td></tr><tr><td><code class="literal">lwlock-wait-done</code></td><td><code class="literal">(char *, LWLockMode)</code></td><td>当一个进程从对一个 LWLock 的等待中被释放时（它实际还没有得到该锁）时触发的探针。arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</td></tr><tr><td><code class="literal">lwlock-condacquire</code></td><td><code class="literal">(char *, LWLockMode)</code></td><td>当调用者指定无需等待而成功获得一个 LWLock 时触发的探针。arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</td></tr><tr><td><code class="literal">lwlock-condacquire-fail</code></td><td><code class="literal">(char *, LWLockMode)</code></td><td>当调用者指定无需等待而没有成功获得一个 LWLock 时触发的探针。arg0 是该 LWLock 所在的切片（Tranche）。
      arg1 所请求的锁模式，是排他或共享。</td></tr><tr><td><code class="literal">lock-wait-start</code></td><td><code class="literal">(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</code></td><td>当一个重量级锁（lmgr锁）的请求由于锁不可用开始等待时触发的探针。arg0 到 arg3 是标识被锁定对象的标签域。arg4 指示被锁对象的类型。arg5 表示被请求的锁类型。</td></tr><tr><td><code class="literal">lock-wait-done</code></td><td><code class="literal">(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</code></td><td>当一个重量级锁（lmgr 锁）的请求结束等待时（即已经得到锁）触发的探针。参数与<code class="literal">lock-wait-start</code>一样。</td></tr><tr><td><code class="literal">deadlock-found</code></td><td><code class="literal">()</code></td><td>当死锁检测器发现死锁时触发的探针。</td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="TYPEDEFS-TABLE"><p class="title"><strong>表 27.29. 定义用在探针参数中的类型</strong></p><div class="table-contents"><table class="table" summary="定义用在探针参数中的类型" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>类型</th><th>定义</th></tr></thead><tbody><tr><td><code class="type">LocalTransactionId</code></td><td><code class="type">unsigned int</code></td></tr><tr><td><code class="type">LWLockMode</code></td><td><code class="type">int</code></td></tr><tr><td><code class="type">LOCKMODE</code></td><td><code class="type">int</code></td></tr><tr><td><code class="type">BlockNumber</code></td><td><code class="type">unsigned int</code></td></tr><tr><td><code class="type">oid</code></td><td><code class="type">unsigned int</code></td></tr><tr><td><code class="type">ForkNumber</code></td><td><code class="type">int</code></td></tr><tr><td><code class="type">bool</code></td><td><code class="type">char</code></td></tr></tbody></table></div></div><br class="table-break" /></div><div class="sect2" id="USING-TRACE-POINTS"><div class="titlepage"><div><div><h3 class="title">27.5.3. 使用探针</h3></div></div></div><p>
   下面的例子展示了一个分析系统中事务计数的 DTrace 脚本，可以用来代替一次性能测试之前和之后的<code class="structname">pg_stat_database</code>快照：
</p><pre class="programlisting">
#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self-&gt;ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self-&gt;ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self-&gt;ts);
      self-&gt;ts=0;
}
</pre><p>
   当被执行时，该例子 D 脚本给出这样的输出：
</p><pre class="screen">
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</pre><p>
  </p><div class="note"><h3 class="title">注意</h3><p>
    SystemTap 为追踪脚本使用一个不同于 DTrace 的标记，但是底层的探针是兼容的。值得注意的是，在这样写的时候，SystemTap 脚本必须使用双下划线代替连字符来引用探针名。在未来的 SystemTap 发行中这很可能会被修复。
   </p></div><p>
   你应该记住，DTrace 脚本需要细心地编写和调试，否则被收集的追踪信息可能会毫无意义。在大部分发现问题的情况中，它就是发生问题的部件，而不是底层系统。当讨论使用动态追踪发现的信息时，一定要封闭使用的脚本来允许这些以便被检查和讨论。
  </p></div><div class="sect2" id="DEFINING-TRACE-POINTS"><div class="titlepage"><div><div><h3 class="title">27.5.4. 定义新探针</h3></div></div></div><p>
   开发者可以在代码中任意位置定义新的探针，当然这要重新编译之后才能生效。下面是插入新探针的步骤：
  </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
     决定探针名称以及探针可用的数据
    </p></li><li class="step"><p>
     把该探针定义加入到<code class="filename">src/backend/utils/probes.d</code>
    </p></li><li class="step"><p>
     如果<code class="filename">pg_trace.h</code>还不存在于包含该探针点的模块中，包括它，并且在源代码中期望的位置插入<code class="literal">TRACE_POSTGRESQL</code>探针宏
    </p></li><li class="step"><p>
     重新编译并验证新探针是可用的
    </p></li></ol></div><p><strong>例子：. </strong>
    这里是一个如何增加一个探针来用事务 ID 追踪所有新事务的例子。
   </p><div class="procedure"><ol class="procedure" type="1"><li class="step"><p>
     决定探针将被命名为<code class="literal">transaction-start</code>并且需要一个<code class="type">LocalTransactionId</code>类型的参数
    </p></li><li class="step"><p>
     将该探针定义加入到<code class="filename">src/backend/utils/probes.d</code>：
</p><pre class="programlisting">
probe transaction__start(LocalTransactionId);
</pre><p>
     注意探针名字中双下划线的使用。在一个使用探针的 DTrace 脚本中，双下划线需要被替换为一个连字符，因此 ，对用户而言<code class="literal">transaction-start</code>是文档名。
    </p></li><li class="step"><p>
     在编译时，<code class="literal">transaction__start</code>被转换成一个宏调用<code class="literal">TRACE_POSTGRESQL_TRANSACTION_START</code>（注意这里是单下划线），可以通过包括头文件<code class="filename">pg_trace.h</code>获得。将宏调用加入到源代码中的合适位置。在这种情况下，看起来类似：

</p><pre class="programlisting">
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</pre><p>
    </p></li><li class="step"><p>
     在重新编译和运行新的二进制文件之后，通过运行下面的 DTrace 命令来检查新增的探针是否可用。你应该看到类似下面的输出：
</p><pre class="screen">
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</pre><p>
    </p></li></ol></div><p>
   向C代码中添加追踪宏时，有一些事情需要注意：

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      需要小心的是，为探针参数指定的数据类型要匹配宏中使用的变量的数据类型，否则会发生编译错误。
     </p></li><li class="listitem"><p>
      在大多数平台上，如果用<code class="option">--enable-dtrace</code>编译了<span class="productname">PostgreSQL</span>，无论何时当控制经过一个追踪宏时，都会评估该宏的参数，<span class="emphasis"><em>即使没有进行追踪也会这样做</em></span>。通常不需要担心你是否只在报告一些局部变量的值。但要注意将开销大的函数调用放置在这些参数中。如果你需要这样做，考虑通过检查追踪是否真的被启用来保护该宏：

</p><pre class="programlisting">
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</pre><p>

      每个追踪宏有一个对应的<code class="literal">ENABLED</code>宏。
     </p></li></ul></div><p>

  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="progress-reporting.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="monitoring.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="diskusage.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">27.4. 进度报告 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 28 章 监控磁盘使用</td></tr></table></div></body></html>