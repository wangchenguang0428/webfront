<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>29.2. 预写式日志（WAL）</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="wal-reliability.html" title="29.1. 可靠性" /><link rel="next" href="wal-async-commit.html" title="29.3. 异步提交" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">29.2. 预写式日志（<acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">WAL</acronym>）</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="wal-reliability.html" title="29.1. 可靠性">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="wal.html" title="第 29 章 可靠性和预写式日志">上一级</a></td><th width="60%" align="center">第 29 章 可靠性和预写式日志</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="wal-async-commit.html" title="29.3. 异步提交">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="WAL-INTRO"><div class="titlepage"><div><div><h2 class="title" style="clear: both">29.2. 预写式日志（<acronym class="acronym">WAL</acronym>）</h2></div></div></div><a id="id-1.6.16.4.2" class="indexterm"></a><a id="id-1.6.16.4.3" class="indexterm"></a><p>
    <em class="firstterm">预写式日志</em>（<acronym class="acronym">WAL</acronym>）是保证数据完整性的一种标准方法。对其详尽的描述几乎可以在所有（如果不是全部）有关事务处理的书中找到。简单来说，<acronym class="acronym">WAL</acronym>的中心概念是数据文件（存储着表和索引）的修改必须在这些动作被日志记录之后才被写入，即在描述这些改变的日志记录被刷到持久存储以后。如果我们遵循这种过程，我们不需要在每个事务提交时刷写数据页面到磁盘，因为我们知道在发生崩溃时可以使用日志来恢复数据库：任何还没有被应用到数据页面的改变可以根据其日志记录重做（这是前滚恢复，也被称为REDO）。
   </p><div class="tip"><h3 class="title">提示</h3><p>
     因为<acronym class="acronym">WAL</acronym>在崩溃后恢复数据库文件内容，不需要日志化文件系统作为数据文件或WAL文件的可靠存储。实际上，日志会降低性能，特别是如果日志导致文件系统<span class="emphasis"><em>数据</em></span>被刷写到磁盘。幸运地是，日志期间的数据刷写常常可以在文件系统挂载选项中被禁用，例如在Linux ext3文件系统中可以使用<code class="literal">data=writeback</code>。在崩溃后日志化文件系统确实可以提高启动速度。
    </p></div><p>
    使用<acronym class="acronym">WAL</acronym>可以显著降低磁盘的写次数，因为只有日志文件需要被刷出到磁盘以保证事务被提交，而被事务改变的每一个数据文件则不必被刷出。日志文件被按照顺序写入，因此同步日志的代价要远低于刷写数据页面的代价。在处理很多影响数据存储不同部分的小事务的服务器上这一点尤其明显。此外，当服务器在处理很多小的并行事务时，日志文件的一个<code class="function">fsync</code>可以提交很多事务。
   </p><p>
    <acronym class="acronym">WAL</acronym>也使得在线备份和时间点恢复能被支持，如<a class="xref" href="continuous-archiving.html" title="25.3. 连续归档和时间点恢复（PITR）">第 25.3 节</a>所述。通过归档WAL数据，我们可以支持回转到被可用WAL数据覆盖的任何时间：我们简单地安装数据库的一个较早的物理备份，并且重放WAL日志一直到所期望的时间。另外，该物理备份不需要是数据库状态的一个一致的快照 — 如果它的制作经过了一段时间，则重放这一段时间的WAL日志将会修复任何内部不一致性。
   </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="wal-reliability.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="wal.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="wal-async-commit.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">29.1. 可靠性 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 29.3. 异步提交</td></tr></table></div></body></html>