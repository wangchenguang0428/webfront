<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>40.1. 查询树</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="rules.html" title="第 40 章 规则系统" /><link rel="next" href="rules-views.html" title="40.2. 视图和规则系统" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">40.1. 查询树</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="rules.html" title="第 40 章 规则系统">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="rules.html" title="第 40 章 规则系统">上一级</a></td><th width="60%" align="center">第 40 章 规则系统</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="rules-views.html" title="40.2. 视图和规则系统">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="QUERYTREE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">40.1. 查询树</h2></div></div></div><a id="id-1.8.6.6.2" class="indexterm"></a><p>
    要了解规则系统是如何工作的，必须要知道它什么时候被调用以及它的输入和结果是什么。
</p><p>
    规则系统位于解析器和规划器之间。它采用解析器的输出（即一个查询树）和用户定义的重写规则（也是查询树，不过带有一些额外信息），并且常见零个或者更多个查询树作为结果。因此它的输入和输出总是那些规划器自身就能产生的东西，并且因此它看到的任何东西都可以被表示成一个<acronym class="acronym">SQL</acronym>语句。
</p><p>
    那么什么是一个查询树？它是一个<acronym class="acronym">SQL</acronym>语句的一种内部表示，其中用于创建它的每一个单独的部分都被独立存储。如果你设置了配置参数<code class="varname">debug_print_parse</code>、<code class="varname">debug_print_rewritten</code>或<code class="varname">debug_print_plan</code>，这些查询树可以被显示在服务器日志中。规则动作也被做为查询树存储在系统目录<code class="structname">pg_rewrite</code>中。它们没有被格式化为日志输出的形式，但是它们包含完全相同的信息。
</p><p>
    阅读一棵未加工的查询树需要要一些经验。但是由于查询树的<acronym class="acronym">SQL</acronym>表示形式足以用来理解规则系统，本章将不会教授如何阅读查询树。
</p><p>
    在阅读本章中查询树的<acronym class="acronym">SQL</acronym>表现形式时，读者需要能够知道语句被分解成了哪些部分并且能在查询树结构中标识它们。一棵查询树的部分有：

</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
        命令类型
    </span></dt><dd><p>
        这是一个简单的值来说明是哪一种命令（<code class="command">SELECT</code>、<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>）产生了该查询树。
    </p></dd><dt><span class="term">
        范围表
        <a id="id-1.8.6.6.7.2.2.1.1" class="indexterm"></a>
    </span></dt><dd><p>
        范围表是被使用在该查询中的关系的列表。在一个<code class="command">SELECT</code>语句中，范围表是在关键词<code class="literal">FROM</code>后面给出的关系。
    </p><p>
        每一个范围表项标识一个表或视图，并且说明在该查询的其他部分要以哪个名称调用它。在查询树中，范围表项被使用编号而不是名称来引用，因此在一个<acronym class="acronym">SQL</acronym>语句中出现重复的名字也没有关系。在规则的范围表被合并以后可能会发生这种情况。本章中的例子将不会有这种情况。
    </p></dd><dt><span class="term">
        结果关系
    </span></dt><dd><p>
        这是一个指向范围表的索引，它标识了该查询的结果应该去哪个关系。
    </p><p>
        <code class="command">SELECT</code>查询没有结果关系（特殊情况<code class="command">SELECT INTO</code>几乎等于<code class="command">CREATE TABLE</code>后面跟上<code class="literal">INSERT ... SELECT</code>，并且不在这里单独讨论）。
    </p><p>
        对于<code class="command">INSERT</code>、<code class="command">UPDATE</code>和<code class="command">DELETE</code>命令，结果关系是修改要进行的表（或视图！）。
    </p></dd><dt><span class="term">
        目标列表
        <a id="id-1.8.6.6.7.2.4.1.1" class="indexterm"></a>
    </span></dt><dd><p>
        目标列表是一个表达式的列表，它定义了查询的结果。在一个<code class="command">SELECT</code>的情况下，这些表达式会构建出该查询最终的输出。它们对应于关键字<code class="command">SELECT</code>和<code class="command">FROM</code>之间的表达式（<code class="literal">*</code>是一个关系所有列名的缩写。解析器会把它扩展成独立的列，因此规则系统永远见不到它）。
    </p><p>
        <code class="command">DELETE</code>命令不需要一个目标列表，因为它们不产生任何结果。相反，规划器会向空的目标列表中加入一个特殊的<acronym class="acronym">CTID</acronym>项来允许执行器找到要被删除的行（当结果关系是一个普通表时才加入<acronym class="acronym">CTID</acronym>。如果结果关系是一个视图，则会被规则系统加入一个整行变量，如<a class="xref" href="rules-views.html#RULES-VIEWS-UPDATE" title="40.2.4. 更新一个视图">第 40.2.4 节</a>所述）。
    </p><p>
        对于<code class="command">INSERT</code>命令，目标列表描述了将要进入到结果关系中的新行。它由<code class="literal">VALUES</code>子句中的表达式或来自<code class="literal">INSERT ... SELECT</code>中<code class="command">SELECT</code>子句的表达式构成。重写处理的第一步会为那些没有被原始命令赋值但有默认值的列增加目标列项。任何剩余的列（既没有给定值也没有默认值）将被规划器用一个常量空值表达式填充。
    </p><p>
        对于<code class="command">UPDATE</code>命令，目标列表描述要替换旧行的新行。在规则系统中，它只包含来自命令的<code class="literal">SET column = expression</code>部分的表达式。规划器将处理缺失的列，做法是为它们插入表达式，这种表达式会把旧行的值复制到新行。正如<code class="command">DELETE</code>一样，会增加一个<acronym class="acronym">CTID</acronym>或整行变量，这样执行器能够标识要被更新的旧行。
    </p><p>
        目标列表中的每一个项所包含的表达式可以是一个常量值、一个指向范围表中关系的列的变量、一个参数或一个由函数调用、常量、变量、操作符等构成的表达式树。
    </p></dd><dt><span class="term">
        条件
    </span></dt><dd><p>
        查询的条件是一个表达式，它很像包含在目标列表项中的表达式。这个表达式的结果值是一个布尔值，它说明对最终结果行的操作（<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>或<code class="command">SELECT</code>）是否应该被执行。它对应于一个<acronym class="acronym">SQL</acronym>语句的<code class="literal">WHERE</code>子句。
    </p></dd><dt><span class="term">
        连接树
    </span></dt><dd><p>
        查询的连接树展示了<code class="literal">FROM</code>子句的结构。对于一个<code class="literal">SELECT ... FROM a, b, c</code>这样的简单查询，连接树就是<code class="literal">FROM</code>项的一个列表，因为我们被允许以任何顺序连接它们。但是当<code class="literal">JOIN</code>表达式（特别是外连接）被使用时，我们必须按照连接显示的顺序来连接。在这种情况下，连接树展示了<code class="literal">JOIN</code>表达式的结构。与特定<code class="literal">JOIN</code>子句（来自<code class="literal">ON</code>或<code class="literal">USING</code>）相关的限制被存储为附加到那些连接树节点的条件表达式。我们发现把顶层<code class="literal">WHERE</code>表达式存储为附加到顶层连接树项的一个条件也很方便。这样实际上连接树表达了一个<code class="command">SELECT</code>的<code class="literal">FROM</code>和<code class="literal">WHERE</code>子句。
    </p></dd><dt><span class="term">
        其他
    </span></dt><dd><p>
        查询树的其他部分（如<code class="literal">ORDER BY</code>子句）在这里并不受到关注。规则系统在应用规则时会替换这里的某些项，但是这些与规则系统的基础没有什么关系。
    </p></dd></dl></div><p>
</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="rules.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="rules.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="rules-views.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">第 40 章 规则系统 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 40.2. 视图和规则系统</td></tr></table></div></body></html>