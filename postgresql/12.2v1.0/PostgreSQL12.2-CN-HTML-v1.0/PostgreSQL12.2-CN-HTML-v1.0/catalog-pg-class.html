<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>51.11. pg_class</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="catalog-pg-cast.html" title="51.10. pg_cast" /><link rel="next" href="catalog-pg-collation.html" title="51.12. pg_collation" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">51.11. <code xmlns="http://www.w3.org/1999/xhtml" class="structname">pg_class</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="catalog-pg-cast.html" title="51.10. pg_cast">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="catalogs.html" title="第 51 章 系统目录">上一级</a></td><th width="60%" align="center">第 51 章 系统目录</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="catalog-pg-collation.html" title="51.12. pg_collation">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="CATALOG-PG-CLASS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">51.11. <code class="structname">pg_class</code></h2></div></div></div><a id="id-1.10.4.13.2" class="indexterm"></a><p>
   目录<code class="structname">pg_class</code>记录表和几乎所有具有列或者像表的东西。这包括索引（但还要参见<code class="structname">pg_index</code>）、序列（但还要参见<code class="structname">pg_sequence</code>）、视图、物化视图、组合类型和TOAST表，参见<code class="structfield">relkind</code>。下面，当我们提及所有这些类型的对象时我们使用<span class="quote">“<span class="quote">关系</span>”</span>。并非所有列对于所有关系类型都有意义。
  </p><div class="table" id="id-1.10.4.13.4"><p class="title"><strong>表 51.11. <code class="structname">pg_class</code>的列</strong></p><div class="table-contents"><table class="table" summary="pg_class的列" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>类型</th><th>引用</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">oid</code></td><td><code class="type">oid</code></td><td> </td><td>行标识符</td></tr><tr><td><code class="structfield">relname</code></td><td><code class="type">name</code></td><td> </td><td>表、索引、视图等的名字</td></tr><tr><td><code class="structfield">relnamespace</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-namespace.html" title="51.32. pg_namespace"><code class="structname">pg_namespace</code></a>.oid</code></td><td>
       包含该关系的名字空间的OID
      </td></tr><tr><td><code class="structfield">reltype</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-type.html" title="51.63. pg_type"><code class="structname">pg_type</code></a>.oid</code></td><td>
       可能存在的表行类型所对应数据类型的OID（对索引为0，索引没有<code class="structname">pg_type</code>项）
      </td></tr><tr><td><code class="structfield">reloftype</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-type.html" title="51.63. pg_type"><code class="structname">pg_type</code></a>.oid</code></td><td>
       对于有类型的表，为底层组合类型的OID，对于其他所有关系为0
      </td></tr><tr><td><code class="structfield">relowner</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-authid.html" title="51.8. pg_authid"><code class="structname">pg_authid</code></a>.oid</code></td><td>关系的拥有者</td></tr><tr><td><code class="structfield">relam</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-am.html" title="51.3. pg_am"><code class="structname">pg_am</code></a>.oid</code></td><td>如果这是一个表或者索引，表示索引使用的访问方法（堆、B树、哈希等）</td></tr><tr><td><code class="structfield">relfilenode</code></td><td><code class="type">oid</code></td><td> </td><td>该关系的磁盘文件的名字，0表示这是一个<span class="quote">“<span class="quote">映射</span>”</span>关系，其磁盘文件名取决于低层状态</td></tr><tr><td><code class="structfield">reltablespace</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-tablespace.html" title="51.55. pg_tablespace"><code class="structname">pg_tablespace</code></a>.oid</code></td><td>
       该关系所存储的表空间。如果为0，使用数据库的默认表空间。（如果关系无磁盘文件时无意义）
      </td></tr><tr><td><code class="structfield">relpages</code></td><td><code class="type">int4</code></td><td> </td><td>
       该表磁盘表示的尺寸，以页面计（页面尺寸为<code class="symbol">BLCKSZ</code>）。这只是一个由规划器使用的估计值。它被<code class="command">VACUUM</code>、<code class="command">ANALYZE</code>以及一些DDL命令（如<code class="command">CREATE INDEX</code>）所更新。
      </td></tr><tr><td><code class="structfield">reltuples</code></td><td><code class="type">float4</code></td><td> </td><td>
       表中的存活行数。这只是一个由规划器使用的估计值。它被<code class="command">VACUUM</code>、<code class="command">ANALYZE</code>以及一些DDL命令（如<code class="command">CREATE INDEX</code>）所更新。
      </td></tr><tr><td><code class="structfield">relallvisible</code></td><td><code class="type">int4</code></td><td> </td><td>
       在表的可见性映射表中被标记为全可见的页数。这只是一个由规划器使用的估计值。它被<code class="command">VACUUM</code>、<code class="command">ANALYZE</code>以及一些DDL命令（如<code class="command">CREATE INDEX</code>）所更新。
      </td></tr><tr><td><code class="structfield">reltoastrelid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-class.html" title="51.11. pg_class"><code class="structname">pg_class</code></a>.oid</code></td><td>
       与该表相关联的TOAST表的OID，如果没有则为0。TOAST表将大属性<span class="quote">“<span class="quote">线外</span>”</span>存储在一个二级表中。
      </td></tr><tr><td><code class="structfield">relhasindex</code></td><td><code class="type">bool</code></td><td> </td><td>
       如果这是一个表并且其上建有（或最近建有）索引则为真
      </td></tr><tr><td><code class="structfield">relisshared</code></td><td><code class="type">bool</code></td><td> </td><td>
       如果该表在集簇中的所有数据库间共享则为真。只有某些系统目录（如<code class="structname">pg_database</code>）是共享的。
      </td></tr><tr><td><code class="structfield">relpersistence</code></td><td><code class="type">char</code></td><td> </td><td>
       <code class="literal">p</code> = 永久表，<code class="literal">u</code> = 无日志表，
       <code class="literal">t</code> = 临时表
      </td></tr><tr><td><code class="structfield">relkind</code></td><td><code class="type">char</code></td><td> </td><td>
       <code class="literal">r</code> = 普通表，
       <code class="literal">i</code> = 索引，
       <code class="literal">S</code> = 序列，
       <code class="literal">t</code> = TOAST表，
       <code class="literal">v</code> = 视图，
       <code class="literal">m</code> = 物化视图，
       <code class="literal">c</code> = 组合类型，
       <code class="literal">f</code> = 外部表，
       <code class="literal">p</code> = 分区表，
       <code class="literal">I</code> = 分区索引
      </td></tr><tr><td><code class="structfield">relnatts</code></td><td><code class="type">int2</code></td><td> </td><td>
       关系中用户列的数目（系统列不计算在内）。在<code class="structname">pg_attribute</code>中必须有这么多对应的项。另请参阅<code class="literal">pg_attribute.attnum</code>。
      </td></tr><tr><td><code class="structfield">relchecks</code></td><td><code class="type">int2</code></td><td> </td><td>
       表上<code class="literal">CHECK</code>约束的数目，参见<a class="link" href="catalog-pg-constraint.html" title="51.13. pg_constraint"><code class="structname">pg_constraint</code></a>目录
      </td></tr><tr><td><code class="structfield">relhasrules</code></td><td><code class="type">bool</code></td><td> </td><td>
       如果表有（或曾有）规则则为真，参见
       <a class="link" href="catalog-pg-rewrite.html" title="51.44. pg_rewrite"><code class="structname">pg_rewrite</code></a>目录
      </td></tr><tr><td><code class="structfield">relhastriggers</code></td><td><code class="type">bool</code></td><td> </td><td>
       如果表有（或曾有）触发器则为真，参见
       <a class="link" href="catalog-pg-trigger.html" title="51.57. pg_trigger"><code class="structname">pg_trigger</code></a>目录
      </td></tr><tr><td><code class="structfield">relhassubclass</code></td><td><code class="type">bool</code></td><td> </td><td>
      如果表或者索引有（或曾有）任何继承子女则为真
      </td></tr><tr><td><code class="structfield">relrowsecurity</code></td><td><code class="type">bool</code></td><td> </td><td>
       如果表上启用了行级安全性则为真，参见
       <a class="link" href="catalog-pg-policy.html" title="51.38. pg_policy"><code class="structname">pg_policy</code></a>目录
      </td></tr><tr><td><code class="structfield">relforcerowsecurity</code></td><td><code class="type">bool</code></td><td> </td><td>
       如果行级安全性（启用时）也适用于表拥有者则为真，参见
       <a class="link" href="catalog-pg-policy.html" title="51.38. pg_policy"><code class="structname">pg_policy</code></a>目录
      </td></tr><tr><td><code class="structfield">relispopulated</code></td><td><code class="type">bool</code></td><td> </td><td>如果表已被填充则为真（对于所有关系该列都为真，但对于某些物化视图却不是）</td></tr><tr><td><code class="structfield">relreplident</code></td><td><code class="type">char</code></td><td> </td><td>
       用来为行形成<span class="quote">“<span class="quote">replica identity</span>”</span>的列：
       <code class="literal">d</code> = 默认 (主键，如果存在),
       <code class="literal">n</code> = 无,
       <code class="literal">f</code> = 所有列
       <code class="literal">i</code> = 索引的<code class="structfield">indisreplident</code>被设置或者为默认
      </td></tr><tr><td><code class="structfield">relispartition</code></td><td><code class="type">bool</code></td><td> </td><td>如果表或索引是一个分区，则为真</td></tr><tr><td><code class="structfield">relrewrite</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-class.html" title="51.11. pg_class"><code class="structname">pg_class</code></a>.oid</code></td><td>
       对于在要求表重写的DDL操作期间被写入的新关系，这个域包含原始关系的OID，否则为0。那种状态仅在内部可见，对于一个用户可见的关系这个域应该从不包含不是0的值。
      </td></tr><tr><td><code class="structfield">relfrozenxid</code></td><td><code class="type">xid</code></td><td> </td><td>
       在此之前的所有事务ID在表中已经被替换为一个永久的（<span class="quote">“<span class="quote">冻结的</span>”</span>) 事务ID。这用于跟踪表是否需要被清理，以便阻止事务ID回卷或者允许<code class="literal">pg_xact</code>被收缩。如果该关系不是一个表则为0（<code class="symbol">InvalidTransactionId</code>）。
      </td></tr><tr><td><code class="structfield">relminmxid</code></td><td><code class="type">xid</code></td><td> </td><td>
       在此之前的多事务ID在表中已经被替换为一个事务ID。这被用于跟踪表是否需要被清理，以阻止
       多事务ID回卷或者允许<code class="literal">pg_multixact</code>被收缩。如果关系不是一个表则
       为0（<code class="symbol">InvalidMultiXactId</code>）。
      </td></tr><tr><td><code class="structfield">relacl</code></td><td><code class="type">aclitem[]</code></td><td> </td><td>
       访问权限，更多信息参见<a class="xref" href="ddl-priv.html" title="5.7. 权限">第 5.7 节</a>
      </td></tr><tr><td><code class="structfield">reloptions</code></td><td><code class="type">text[]</code></td><td> </td><td>
       访问方法相关的选项，以<span class="quote">“<span class="quote">keyword=value</span>”</span>字符串形式
      </td></tr><tr><td><code class="structfield">relpartbound</code></td><td><code class="type">pg_node_tree</code></td><td> </td><td>
       如果表示一个分区（见<code class="structfield">relispartition</code>），分区边界的内部表达
      </td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_class</code>中的一些逻辑标志被以一种懒惰的方式维护：在正确状态时它们被保证为真，但是当条件不再为真时它们并不会被立刻重置为假。例如，<code class="structfield">relhasindex</code>由<code class="command">CREATE INDEX</code>设置，但它从不会被<code class="command">DROP INDEX</code>清除。作为替代，<code class="command">VACUUM</code>会在找到无索引表后清除其<code class="structfield">relhasindex</code>。这种安排避免了竞争条件并且提高了并发性。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="catalog-pg-cast.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="catalogs.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="catalog-pg-collation.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">51.10. <code class="structname">pg_cast</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 51.12. <code class="structname">pg_collation</code></td></tr></table></div></body></html>