<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.9. 只用索引的扫描和覆盖索引</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="indexes-partial.html" title="11.8. 部分索引" /><link rel="next" href="indexes-opclass.html" title="11.10. 操作符类和操作符族" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.9. 只用索引的扫描和覆盖索引</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-partial.html" title="11.8. 部分索引">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="第 11 章 索引">上一级</a></td><th width="60%" align="center">第 11 章 索引</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-opclass.html" title="11.10. 操作符类和操作符族">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="INDEXES-INDEX-ONLY-SCANS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.9. 只用索引的扫描和覆盖索引</h2></div></div></div><a id="id-1.5.10.12.2" class="indexterm"></a><a id="id-1.5.10.12.3" class="indexterm"></a><a id="id-1.5.10.12.4" class="indexterm"></a><a id="id-1.5.10.12.5" class="indexterm"></a><p>
<span class="productname">PostgreSQL</span>中的所有索引是<em class="firstterm">二级</em>索引,这意味着每个索引都是与表的主数据区（在<span class="productname">PostgreSQL</span>术语称为表的<em class="firstterm">堆</em>中）分开存储。这意味着在普通索引扫描中，每行检索都需要从索引和堆中取数据。 此外，虽然匹配给定的可索引<code class="literal">WHERE</code>条件的索引条目通常在一起靠近存储，但它们引用的表行可能在堆中的任何地方。 因此索引扫描的堆访问部分涉及到对堆的大量随机访问，这可能很慢，特别是在传统旋转媒介上。如 <a class="xref" href="indexes-bitmap-scans.html" title="11.5. 组合多个索引">第 11.5 节</a>
中所述，位图扫描尝试通过按排序的顺序进行堆访问来减少成本，但这远远不够）。
  </p><p>
   为了解决这种性能问题，<span class="productname">PostgreSQL</span>支持<em class="firstterm">只用索引的扫描</em>，这类扫描可以仅用一个索引来回答查询而不产生任何堆访问。其基本思想是直接从每一个索引项中直接返回值，而不是去参考相关的堆项。在使用这种方法时有两个根本的限制：

   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
      索引类型必须支持只用索引的扫描。B-树索引总是支持只用索引的扫描。GiST 和 SP-GiST 索引只对某些操作符类支持只用索引的扫描。其他索引类型不支持这种扫描。底层的要求是索引必须在物理上存储或者可以重构出每一个索引项对应的原始数据值。GIN 索引是一个不支持只用索引的扫描的反例，因为它的每一个索引项通常只包含原始数据值的一部分。
     </p></li><li class="listitem"><p>
      查询必须只引用存储在该索引中的列。例如，给定的索引建立在表的列<code class="literal">x</code>和<code class="literal">y</code>上，而该表还有一个列<code class="literal">z</code>，这些查询可以使用只用索引的扫描：
</p><pre class="programlisting">
SELECT x, y FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND y &lt; 42;
</pre><p>
      但是这些查询不能使用只用索引的查询：
</p><pre class="programlisting">
SELECT x, z FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND z &lt; 42;
</pre><p>
      （如下面所讨论的，表达式索引和部分索引会让这条规则更加复杂）。
     </p></li></ol></div><p>
  </p><p>
   如果符合这两个根本要求，那么该查询所要求的所有数据值都可以从索引得到，因此才可能使用只用索引的扫描。但是对<span class="productname">PostgreSQL</span>中的任何表扫描还有一个额外的要求：必须验证每一个检索到的行对该查询的 MVCC 快照是<span class="quote">“<span class="quote">可见的</span>”</span>，如<a class="xref" href="mvcc.html" title="第 13 章 并发控制">第 13 章</a>中讨论的那样。可见性信息并不存储在索引项中，只存储在堆项中。因此，乍一看似乎每一次行检索无论如何都会要求一次堆访问。如果表行最近被修改过，确实是这样。但是，对于很少更改的数据有一种方法可以解决这个问题。<span class="productname">PostgreSQL</span>为表堆中的每一个页面跟踪是否其中所有的行的年龄都足够大，以至于对所有当前以及未来的事务都可见。这个信息存储在该表的<em class="firstterm">可见性映射</em>的一个位中。在找到一个候选索引项后，只用索引的扫描会检查对应堆页面的可见性映射位。如果该位被设置，那么这一行就是可见的并且该数据库可以直接被返回。如果该位没有被设置，那么就必须访问堆项以确定这一行是否可见，这种情况下相对于标准索引扫描就没有性能优势。即便是在成功的情况下，这种方法也是把对堆的访问换成了对可见性映射的访问。不过由于可见性映射比它所描述的堆要小四个数量级，所以访问可见性映射所需的物理 I/O 要少很多。在大部分情况下，可见性映射总是会被保留在内存中的缓冲中。
  </p><p>
   总之，虽然当两个根本要求满足时可以使用只用索引的扫描，但是只有该表的堆页面中有很大一部分的“所有都可见”映射位被设置时这种索引才有优势。不过，有很大一部分行不被更改的表是很常见的，这也让这一类扫描在实际中非常有用。
  </p><p>
   <a id="id-1.5.10.12.10.1" class="indexterm"></a>
     为了有效利用仅索引扫描功能，您可以选择创建一个<em class="firstterm">覆盖索引</em>，它是一个特别设计的索引，包含经常运行的特殊类型查询所需要的列。由于查询通常需要检索的列不仅仅是他们搜索的列，<span class="productname">PostgreSQL</span>允许您创建索引,这个索引中有些列只是<span class="quote">“<span class="quote">负荷</span>”</span>而不是搜索键的一部分。这可以通过添加<code class="literal">INCLUDE</code>来完成子句来列出了额外的列。 例如，如果您通常可以运行这样的查询：
</p><pre class="programlisting">
SELECT y FROM tab WHERE x = 'key';
</pre><p>
   加快此类查询的传统方法是仅在<code class="literal">x</code>上的索引。但是，一个索引定义为
</p><pre class="programlisting">
CREATE INDEX tab_x_y ON tab(x) INCLUDE (y);
</pre><p>
  可以将这些查询作为仅索引扫描处理，因为<code class="literal">y</code>可以从索引中获取而不需要访问堆。
  </p><p>
  因为列<code class="literal">y</code>不是搜索键的一部分，它不必是索引可以处理的数据类型；它只存储在索引中，不由索引机解释。另外，如果索引是唯一的索引，则
</p><pre class="programlisting">
CREATE UNIQUE INDEX tab_x_y ON tab(x) INCLUDE (y);
</pre><p>
  唯一性条件仅适用于<code class="literal">x </code>列，而不是<code class="literal">x</code>和<code class="literal">y</code>的组合。（如果使用和在索引中设置的类似语法，一个<code class="literal">INCLUDE</code>子句可以写在<code class="literal">UNIQUE</code>和<code class="literal">PRIMARY KEY</code>约束中。）
 </p><p>
  保守地将非键负载列添加到索引是明智的，尤其是宽列。 如果索引元组超过索引类型允许的最大大小，数据插入将失败。在任何情况下，非键列都将复制索引表中的数据并放大了索引的大小，从而有可能减慢搜索速度。请记住，除非一个表足够慢以至于仅索引扫描可能不必访问堆，否则没有什么理由在一个索引中包含负载列。无论如何，如果必须访问堆元组，从堆里获取列的值并不会带来更高的开销。其他限制是表达式不被作为包含的来支持。只有B树和GiST索引当前支持包含的列。
  </p><p>
   在<span class="productname"> PostgreSQL</span>有<code class="literal">INCLUDE</code>特性之前，人们有时会通过写负载列作为普通索引列来制作覆盖索引。它这样写：
   </p><pre class="programlisting">
      CREATE INDEX tab_x_y ON tab(x, y);
   </pre><p>
   即使他们无意将<code class="literal">y</code>用作<code class="literal">WHER</code>子句的一部分，只要额外的列是尾列就可以很好的工作。 让它们成为前导字段是不明智的，原因在<a class="xref" href="indexes-multicolumn.html" title="11.3. 多列索引">第 11.3 节</a>中有说明。但是，此方法不支持您希望索引在键列上实施唯一性。 
  </p><p>
   <em class="firstterm">Suffix truncation</em>总是从B-Tree的上层移除非键列。作为有效负载列，它们从不用于指导索引扫描。
   当键列的其余前缀恰好足以描述最低B-Tree级别上的元组时，截断过程还会删除一个或多个尾随的键列。
   实际中，不使用<code class="literal">INCLUDE</code>子句覆盖索引通常会避免存储在上层有效负载的列。
   然而，显式地将有效负载列定义为非键列<span class="emphasis"><em>reliably</em></span>使上层元组保持较小。
  </p><p>
   原则上，只用索引的扫描可以被用于表达式索引。例如，给定一个<code class="literal">f(x)</code>上的索引（<code class="literal">x</code>是一个表列），可以把
</p><pre class="programlisting">
SELECT f(x) FROM tab WHERE f(x) &lt; 1;
</pre><p>
   作为只用索引的扫描执行，如果<code class="literal">f()</code>是一个计算代价昂贵的函数，这会非常有吸引力。不过，<span class="productname">PostgreSQL</span>的规划器当前面对这类情况时并不是很聪明。只有在索引中有查询所需要的所有<span class="emphasis"><em>列</em></span>时，规划器才会考虑用只用索引的扫描来执行一个查询。在这个例子中，除了在<code class="literal">f(x)</code>环境中之外，查询的其他部分不需要<code class="literal">x</code>，但是规划器并不能意识到这一点，因此它会得出不能使用只用索引的扫描的结论。如果只用索引的扫描足够有价值，有一种解决方法是把该索引定义在<code class="literal">(f(x), x)</code>上，其中第二个列实际上并不会被使用，它只是用来说服规划器可以使用只用索引的扫描而已。如果目标是避免重复计算<code class="literal">f(x)</code>，一个额外的警示是规划器不一定会把不在可索引<code class="literal">WHERE</code>子句中对<code class="literal">f(x)</code>的使用匹配到索引列。通常在上述那种简单查询中一切正常，但是涉及到连接的查询中就不行了。这些不足将在未来的<span class="productname">PostgreSQL</span>版本中修正。
  </p><p>
   部分索引也和只用索引的扫描之间有着有趣的关系。考虑<a class="xref" href="indexes-partial.html#INDEXES-PARTIAL-EX3" title="例 11.3. 建立一个部分唯一索引">例 11.3</a>中所展示的部分索引：
</p><pre class="programlisting">
CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;
</pre><p>
   原则上，我们可以在这个索引上使用只用索引的扫描来满足查询
</p><pre class="programlisting">
SELECT target FROM tests WHERE subject = 'some-subject' AND success;
</pre><p>
   但是有一个问题：<code class="literal">WHERE</code>子句引用的是不能作为索引结果列的<code class="literal">success</code>。尽管如此，还是可以使用只用索引的扫描，因为在运行时计划不需要重新检查<code class="literal">WHERE</code>子句的那个部分：在该索引中找到的所有项必定具有<code class="literal">success = true</code>，因此在计划中检查这个部分的需要并不明显。<span class="productname">PostgreSQL</span> 9.6 和以后的版本将会识别这种情况，并且允许生成只用索引的扫描，但是旧版本无法这样做。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-partial.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-opclass.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">11.8. 部分索引 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 11.10. 操作符类和操作符族</td></tr></table></div></body></html>