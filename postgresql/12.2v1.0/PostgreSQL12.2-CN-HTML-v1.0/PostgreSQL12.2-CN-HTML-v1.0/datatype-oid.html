<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.19. 对象标识符类型</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="domains.html" title="8.18. 域类型" /><link rel="next" href="datatype-pg-lsn.html" title="8.20. pg_lsn 类型" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.19. 对象标识符类型</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="domains.html" title="8.18. 域类型">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="第 8 章 数据类型">上一级</a></td><th width="60%" align="center">第 8 章 数据类型</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="datatype-pg-lsn.html" title="8.20. pg_lsn 类型">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="DATATYPE-OID"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.19. 对象标识符类型</h2></div></div></div><a id="id-1.5.7.27.2" class="indexterm"></a><a id="id-1.5.7.27.3" class="indexterm"></a><a id="id-1.5.7.27.4" class="indexterm"></a><a id="id-1.5.7.27.5" class="indexterm"></a><a id="id-1.5.7.27.6" class="indexterm"></a><a id="id-1.5.7.27.7" class="indexterm"></a><a id="id-1.5.7.27.8" class="indexterm"></a><a id="id-1.5.7.27.9" class="indexterm"></a><a id="id-1.5.7.27.10" class="indexterm"></a><a id="id-1.5.7.27.11" class="indexterm"></a><a id="id-1.5.7.27.12" class="indexterm"></a><a id="id-1.5.7.27.13" class="indexterm"></a><a id="id-1.5.7.27.14" class="indexterm"></a><p>
    对象标识符（OID）被<span class="productname">PostgreSQL</span>用来在内部作为多个系统表的主键。
    类型<code class="type">oid</code>表示一个对象标识符。
    也有多个<code class="type">oid</code>的别名类型：<code class="type">regproc</code>,<code class="type">regprocedure</code>, <code class="type">regoper</code>, <code class="type">regoperator</code>,<code class="type">regclass</code>, <code class="type">regtype</code>, <code class="type">regrole</code>,<code class="type">regnamespace</code>, <code class="type">regconfig</code>, 和<code class="type">regdictionary</code>。
    <a class="xref" href="datatype-oid.html#DATATYPE-OID-TABLE" title="表 8.26. 对象标识符类型">表 8.26</a>显示了一个概览。
   </p><p>
    <code class="type">oid</code>类型目前被实现为一个无符号4字节整数。
	因此，在大型数据库中它并不足以提供数据库范围内的唯一性，甚至在一些大型的表中也无法提供表范围内的唯一性。
   </p><p>
    <code class="type">oid</code>类型本身除了比较之外只有很少的操作。不过，它可以被造型成整数，并且接着可以使用标准的整数操作符进行操纵（这样做时要注意有符号和无符号之间可能出现的混乱）。
   </p><p>
    OID的别名类型除了特定的输入和输出例程之外没有别的操作。这些例程可以接受并显示系统对象的符号名，而不是类型<code class="type">oid</code>使用的原始数字值。别名类型使查找对象的OID值变得简单。例如，要检查与一个表<code class="literal">mytable</code>有关的<code class="structname">pg_attribute</code>行，你可以写：
</p><pre class="programlisting">
SELECT * FROM pg_attribute WHERE attrelid = 'mytable'::regclass;
</pre><p>
    而不是：
</p><pre class="programlisting">
SELECT * FROM pg_attribute
  WHERE attrelid = (SELECT oid FROM pg_class WHERE relname = 'mytable');
</pre><p>
    虽然从它本身看起来并没有那么糟，它仍然被过度简化了。如果有多个名为<code class="literal">mytable</code>的表存在于不同的模式中，就可能需要一个更复杂的子选择来选择右边的OID。<code class="type">regclass</code>输入转换器会根据模式路径设置处理表查找，并且因此它会自动地完成这种<span class="quote">“<span class="quote">右边的事情</span>”</span>。类似地，对于一个数字OID的符号化显示可以很方便地通过将表OID造型成<code class="type">regclass</code>来实现。
   </p><div class="table" id="DATATYPE-OID-TABLE"><p class="title"><strong>表 8.26. 对象标识符类型</strong></p><div class="table-contents"><table class="table" summary="对象标识符类型" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>名字</th><th>引用</th><th>描述</th><th>值示例</th></tr></thead><tbody><tr><td><code class="type">oid</code></td><td>任意</td><td>数字形式的对象标识符</td><td><code class="literal">564182</code></td></tr><tr><td><code class="type">regproc</code></td><td><code class="structname">pg_proc</code></td><td>函数名字</td><td><code class="literal">sum</code></td></tr><tr><td><code class="type">regprocedure</code></td><td><code class="structname">pg_proc</code></td><td>带参数类型的函数</td><td><code class="literal">sum(int4)</code></td></tr><tr><td><code class="type">regoper</code></td><td><code class="structname">pg_operator</code></td><td>操作符名字</td><td><code class="literal">+</code></td></tr><tr><td><code class="type">regoperator</code></td><td><code class="structname">pg_operator</code></td><td>带参数类型的操作符</td><td><code class="literal">*(integer,integer)</code> or <code class="literal">-(NONE,integer)</code></td></tr><tr><td><code class="type">regclass</code></td><td><code class="structname">pg_class</code></td><td>关系名字</td><td><code class="literal">pg_type</code></td></tr><tr><td><code class="type">regtype</code></td><td><code class="structname">pg_type</code></td><td>数据类型名字</td><td><code class="literal">integer</code></td></tr><tr><td><code class="type">regrole</code></td><td><code class="structname">pg_authid</code></td><td>角色名</td><td><code class="literal">smithee</code></td></tr><tr><td><code class="type">regnamespace</code></td><td><code class="structname">pg_namespace</code></td><td>名字空间名称</td><td><code class="literal">pg_catalog</code></td></tr><tr><td><code class="type">regconfig</code></td><td><code class="structname">pg_ts_config</code></td><td>文本搜索配置</td><td><code class="literal">english</code></td></tr><tr><td><code class="type">regdictionary</code></td><td><code class="structname">pg_ts_dict</code></td><td>文本搜索字典</td><td><code class="literal">simple</code></td></tr></tbody></table></div></div><br class="table-break" /><p>
    所有用于由名字空间组织的对象的 OID 别名类型都接受模式限定的名字，如果没有被限定的对象在当前搜索路径中无法找到时，将会在输出时显示模式限定的名字。<code class="type">regproc</code>和<code class="type">regoper</code>别名类型将只接受唯一的（非重载的）输入名字，因此它们的使用是受限的；对于大多数使用，<code class="type">regprocedure</code>或<code class="type">regoperator</code>更合适。对于<code class="type">regoperator</code>，通过使用<code class="literal">NONE</code>来替代未使用的操作数可以标识一元操作符。
   </p><p>
    大部分 OID 别名类型的一个附加性质是依赖性的创建。如果这些类型之一的一个常量出现在一个存储的表达式（如一个列默认值表达式或视图）中，它会在被引用的对象上创建一个依赖。例如，如果一个列有一个默认值表达式<code class="literal">nextval('my_seq'::regclass)</code>，<span class="productname">PostgreSQL</span>会理解该默认值表达式是依赖于序列<code class="literal">my_seq</code>的，在删除该默认值表达式之前系统将不允许删除该序列。<code class="type">regrole</code>是这个性质的唯一例外。这种类型的常量不允许出现在这类表达式中。
   </p><div class="note"><h3 class="title">注意</h3><p>
    OID 别名类型不完全遵循事务隔离规则。规划器也把它们当做简单常量，
    这可能会导致次优的规划。
   </p></div><p>
    另一种系统中使用的标识符类型是<code class="type">xid</code>，或者称为事务（简写为<abbr class="abbrev">xact</abbr>）标识符。这是系统列<code class="structfield">xmin</code>和<code class="structfield">xmax</code>使用的数据类型。事务标识符是32位量。
   </p><p>
    系统使用的第三种标识符类型是<code class="type">cid</code>，或者称为命令标识符。这是系统列<code class="structfield">cmin</code>和<code class="structfield">cmax</code>使用的数据类型。命令标识符也是32位量。
   </p><p>
    系统使用的最后一种标识符类型是<code class="type">tid</code>，或者称为元组标识符（行标识符）。这是系统列<code class="structfield">ctid</code>使用的数据类型。一个元组ID是一个（块号，块内元组索引）对，它标识了行在它的表中的物理位置。
   </p><p>
    （这些系统列在<a class="xref" href="ddl-system-columns.html" title="5.5. 系统列">第 5.5 节</a>中有进一步的解释）。
   </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="domains.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="datatype-pg-lsn.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">8.18. 域类型 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 8.20. <acronym class="acronym">pg_lsn 类型</acronym></td></tr></table></div></body></html>