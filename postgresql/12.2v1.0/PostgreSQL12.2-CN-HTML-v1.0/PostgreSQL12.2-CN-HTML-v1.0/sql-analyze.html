<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>ANALYZE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-alterview.html" title="ALTER VIEW" /><link rel="next" href="sql-begin.html" title="BEGIN" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">ANALYZE</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-alterview.html" title="ALTER VIEW">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQL 命令">上一级</a></td><th width="60%" align="center">SQL 命令</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-begin.html" title="BEGIN">下一页</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-ANALYZE"><div class="titlepage"></div><a id="id-1.9.3.46.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">ANALYZE</span></h2><p>ANALYZE — 收集有关一个数据库的统计信息</p></div><div class="refsynopsisdiv"><h2>大纲</h2><pre class="synopsis">
ANALYZE [ ( <em class="replaceable"><code>option</code></em> [, ...] ) ] [ <em class="replaceable"><code>table_and_columns</code></em> [, ...] ]
ANALYZE [ VERBOSE ] [ <em class="replaceable"><code>table_and_columns</code></em> [, ...] ]

<span class="phrase">其中<em class="replaceable"><code>option</code></em>可以是：</span>

    VERBOSE [ <em class="replaceable"><code>boolean</code></em> ]
    SKIP_LOCKED [ <em class="replaceable"><code>boolean</code></em> ]

<span class="phrase"><em class="replaceable"><code>table_and_columns</code></em>是：</span>

    <em class="replaceable"><code>table_name</code></em> [ ( <em class="replaceable"><code>column_name</code></em> [, ...] ) ]
</pre></div><div class="refsect1" id="id-1.9.3.46.5"><h2>描述</h2><p>
   <code class="command">ANALYZE</code>收集一个数据库中的表的内容的统计信息，并且将结果存储在<a class="link" href="catalog-pg-statistic.html" title="51.50. pg_statistic"><code class="structname">pg_statistic</code></a>系统目录中。接下来，查询规划器会使用这些统计信息来帮助确定查询最有效的执行计划。
  </p><p>
   如果没有<em class="replaceable"><code>table_and_columns</code></em>列表，则<code class="command">ANALYZE</code>处理当前用户有权分析的当前数据库中的每个表和物化视图。使用列表，<code class="command">ANALYZE</code>仅处理那些表。还可以给出表的列名列表，在这种情况下，仅收集这些列的统计信息。
  </p><p>
   当选项列表用括号括起来时，选项可以按任何顺序来写。 带括号的语法是在<span class="productname">PostgreSQL</span> 11中添加的；不带括号的语法已弃用。
  </p></div><div class="refsect1" id="id-1.9.3.46.6"><h2>参数</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">VERBOSE</code></span></dt><dd><p>
      允许显示进度消息。
     </p></dd><dt><span class="term"><code class="literal">SKIP_LOCKED</code></span></dt><dd><p>
      规定<code class="command">ANALYZE</code>在开始处理一个关系时不应等待任何冲突的锁被释放:如果关系不能无需等待立即锁定，则跳过该关系。 
      请注意即使采用此选项，<code class="command">ANALYZE</code>在打开关系的索引或从分区、表继承子级和某些类型的外表获取样本行时仍可能阻塞。 
      此外，当<code class="command">ANALYZE</code>通常处理指定分区表的所有分区时，如果分区表上有一个冲突的锁，这个选项将导致<code class="command">ANALYZE</code>跳过所有分区表。
     </p></dd><dt><span class="term"><em class="replaceable"><code>boolean</code></em></span></dt><dd><p>
      规定所选的选项打开或关闭。
      您可以写<code class="literal">TRUE</code>、<code class="literal">ON</code>或<code class="literal">1</code>以启用该选项，或者是<code class="literal">FALSE</code>、<code class="literal">OFF</code>或<code class="literal">0</code>来禁用它。
      <em class="replaceable"><code>boolean</code></em> 值可以被省略，在假定为<code class="literal">TRUE</code>的情况下。
     </p></dd><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>
      要分析的一个指定表的名称（可以是模式限定的）。如果省略，则分析当前数据库中的所有常规表、分区表和物化视图（但不包含外部表）。 如果指定的表是分区表，则整个分区表的继承统计信息和各个分区的统计信息都将更新。
     </p></dd><dt><span class="term"><em class="replaceable"><code>column_name</code></em></span></dt><dd><p>
      要分析的一个指定列的名称。默认是所有列。
     </p></dd></dl></div></div><div class="refsect1" id="id-1.9.3.46.7"><h2>输出</h2><p>
    当指定了<code class="literal">VERBOSE</code>时，<code class="command">ANALYZE</code>会发出进度消息来指示当前正在处理哪个表。还会打印有关那些表的多种统计信息。
   </p></div><div class="refsect1" id="id-1.9.3.46.8"><h2>注解</h2><p>
   要分析表，通常必须是该表的所有者或超级用户。不过，数据库所有者可以分析数据库中的所有表，共享目录除外。
   （对共享目录的限制意味着真正的数据库范围的<code class="command">ANALYZE</code>只能由超级用户执行。）
   <code class="command">ANALYZE</code>将跳过调用用户没有分析权限的任何表。
  </p><p>
   只有被显式选中时才会分析外部表。并非所有外部数据包装器都支持<code class="command">ANALYZE</code>。如果表的包装器不支持<code class="command">ANALYZE</code>，该命令会打印一个警告并且什么也不做。
  </p><p>
   在默认的<span class="productname">PostgreSQL</span>配置中，自动清理守护进程（见<a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="24.1.6. 自动清理后台进程">第 24.1.6 节</a>）会在表第一次载入数据或者用常规操作改变时负责表的自动分析。当启用自动清理时，定期运行<code class="command">ANALYZE</code>是个好主意，或者可以在表内容做了大的修改后运行<code class="command">ANALYZE</code>。准确的统计信息将帮助规划器选择最合适的查询计划，从而提升查询处理的速度。主读数据库的一般策略是在一天中使用量最低时运行一次<a class="xref" href="sql-vacuum.html" title="VACUUM"><span class="refentrytitle">VACUUM</span></a>和<code class="command">ANALYZE</code>（如果有大量的更新动作则是不够的）。
  </p><p>
   <code class="command">ANALYZE</code>只要求目标表上的一个读锁，因此它可以和表上的其他动作并行。
  </p><p>
   <code class="command">ANALYZE</code>收集的统计信息通畅包括每列中最常见值的列表以及展示每列中近似数据分布的一个直方图。如果<code class="command">ANALYZE</code>认为这些东西无趣（例如在一个唯一键列中，没有共同值）或者该列的数据类型不支持合适的操作符，以上工作都会被省略。在<a class="xref" href="maintenance.html" title="第 24 章 日常数据库维护工作">第 24 章</a>中有与统计信息相关的更多信息。
  </p><p>
   对于大型的表，<code class="command">ANALYZE</code>会对表内容做随机采样而不是检查每一行。这允许在很少的时间内完成对大型表的分析。不过要注意，这些统计信息只是近似值，并且即使实际表内容没有改变，每次运行<code class="command">ANALYZE</code>时统计信息都会有微小地改变。这可能会导致<a class="xref" href="sql-explain.html" title="EXPLAIN"><span class="refentrytitle">EXPLAIN</span></a>显示的规划器估算代价有小的改变。在很少的情况下，这会非决定性地导致规划器的查询计划选择在<code class="command">ANALYZE</code>运行后改变。为了避免这种情况，可以按照下文所述提高<code class="command">ANALYZE</code>所收集的统计信息量。
  </p><p>
   通过调整<a class="xref" href="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET">default_statistics_target</a>配置变量可以控制分析量，对每个列可以用<code class="command">ALTER TABLE ... ALTER COLUMN ... SET STATISTICS</code>设置每列的统计信息目标（见<a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>）。目标值会设置最常用值列表中的最大项数以及直方图中的最大容器数。默认目标值是 100，可以把它调大或者调小在规划器估计值精度和<code class="command">ANALYZE</code>花费的时间以及<code class="literal">pg_statistic</code>所占空间之间做出平衡。特别地，将统计信息目标设置为零会禁用该列的统计信息收集。在查询的<code class="literal">WHERE</code>、<code class="literal">GROUP BY</code>或者<code class="literal">ORDER BY</code>子句中从不出现的列上这样做会有所帮助，因为规划器用不上这些列上的统计信息。
  </p><p>
   被分析的列中最大的统计信息目标决定了为准备统计信息要采样的表行数。增加该目标会导致做<code class="command">ANALYZE</code>所需的时间和空间成比例增加。
  </p><p>
   <code class="command">ANALYZE</code>所估算的值之一是出现在每个列中的可区分值。因为只会检查行的一个子集，即便使用最大的统计信息目标，这种估计有时也可能很不精确。如果这种不精确导致不好的查询计划，可以手工确定一个更精确的值并且用<code class="command">ALTER TABLE ... ALTER COLUMN ... SET (n_distinct = ...)</code>设置该值（见<a class="xref" href="sql-altertable.html" title="ALTER TABLE"><span class="refentrytitle">ALTER TABLE</span></a>）。
  </p><p>
    如果被分析的表有一个或者更多子女，<code class="command">ANALYZE</code>将会收集两次统计信息：一次只对父表的行收集，第二次则在父表及其所有子女表的行上收集。在规划需要遍历整个继承树的查询时需要第二个统计信息集。不过，在决定是否触发表上的自动分析时，自动清理后台进程将只考虑父表本身上的插入和更新。如果该表很少被插入或者更新，只有手工运行<code class="command">ANALYZE</code>时才会把继承统计信息更新到最新。
  </p><p>
    如果任何子表是外部表并且其外部数据包装器不支持<code class="command">ANALYZE</code>，在收集继承统计信息时会忽略那些子表。
  </p><p>
    如果被分析的表不完全为空，<code class="command">ANALYZE</code>将不会为该表记录新统计信息。任何现有统计信息将会被保留。
  </p></div><div class="refsect1" id="id-1.9.3.46.9"><h2>兼容性</h2><p>
   SQL 标准中没有<code class="command">ANALYZE</code>语句。
  </p></div><div class="refsect1" id="id-1.9.3.46.10"><h2>另见</h2><span class="simplelist"><a class="xref" href="sql-vacuum.html" title="VACUUM"><span class="refentrytitle">VACUUM</span></a>, <a class="xref" href="app-vacuumdb.html" title="vacuumdb"><span class="refentrytitle"><span class="application">vacuumdb</span></span></a>, <a class="xref" href="runtime-config-resource.html#RUNTIME-CONFIG-RESOURCE-VACUUM-COST" title="19.4.4. 基于代价的清理延迟">第 19.4.4 节</a>, <a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="24.1.6. 自动清理后台进程">第 24.1.6 节</a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-alterview.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-begin.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">ALTER VIEW </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> BEGIN</td></tr></table></div></body></html>