<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>psql</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="app-pgrestore.html" title="pg_restore" /><link rel="next" href="app-reindexdb.html" title="reindexdb" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center"><span xmlns="http://www.w3.org/1999/xhtml" class="application">psql</span></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="app-pgrestore.html" title="pg_restore">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="reference-client.html" title="PostgreSQL 客户端应用">上一级</a></td><th width="60%" align="center">PostgreSQL 客户端应用</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="app-reindexdb.html" title="reindexdb">下一页</a></td></tr></table><hr></hr></div><div class="refentry" id="APP-PSQL"><div class="titlepage"></div><a id="id-1.9.4.18.1" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle"><span class="application">psql</span></span></h2><p><span class="application">psql</span> — 
      <span class="productname">PostgreSQL</span>的交互式终端
    </p></div><div class="refsynopsisdiv"><h2>大纲</h2><div class="cmdsynopsis"><p id="id-1.9.4.18.4.1"><code class="command">psql</code> [<em class="replaceable"><code>option</code></em>...] [<em class="replaceable"><code>dbname</code></em>
    [<em class="replaceable"><code>username</code></em>]]</p></div></div><div class="refsect1" id="id-1.9.4.18.5"><h2>描述</h2><p>
     <span class="application">psql</span>是一个<span class="productname">PostgreSQL</span>的基于终端的前端。它让你能交互式地键入查询，把它们发送给<span class="productname">PostgreSQL</span>，并且查看查询结果。或者，输入可以来自于一个文件或者命令行参数。此外，<span class="application">psql</span>还提供一些元命令和多种类似 shell 的特性来为编写脚本和自动化多种任务提供便利。
    </p></div><div class="refsect1" id="R1-APP-PSQL-3"><h2>选项</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="option">-a</code><br /></span><span class="term"><code class="option">--echo-all</code></span></dt><dd><p>
      把所有非空输入行按照它们被读入的形式打印到标准输出（不适用于交互式行读取）。这等效于把变量<code class="varname">ECHO</code>设置为
      <code class="literal">all</code>。
      </p></dd><dt><span class="term"><code class="option">-A</code><br /></span><span class="term"><code class="option">--no-align</code></span></dt><dd><p>
      切换到非对齐输出模式（默认输出模式是<code class="literal">对齐</code>的）。这等效于<code class="command">\pset format unaligned</code>。
      </p></dd><dt><span class="term"><code class="option">-b</code><br /></span><span class="term"><code class="option">--echo-errors</code></span></dt><dd><p>
      把失败的 SQL 命令打印到标准错误输出。这等效于把变量<code class="varname">ECHO</code>设置为<code class="literal">errors</code>。
      </p></dd><dt><span class="term"><code class="option">-c <em class="replaceable"><code>command</code></em></code><br /></span><span class="term"><code class="option">--command=<em class="replaceable"><code>command</code></em></code></span></dt><dd><p>
      指定<span class="application">psql</span>执行一个给定的命令字符串<em class="replaceable"><code>command</code></em>。这个选项可以重复多次并且以任何顺序与<code class="option">-f</code>选项组合在一起。当<code class="option">-c</code>或者<code class="option">-f</code>被指定时，<span class="application">psql</span>不会从标准输入读取命令，直到它处理完序列中所有的<code class="option">-c</code>和<code class="option">-f</code>选项之后终止。
      </p><p>
       <em class="replaceable"><code>command</code></em>必须是一个服务器完全可解析的命令字符串（即不包含<span class="application">psql</span>相关的特性）或者单个反斜线命令。因此不能在一个<code class="option">-c</code>选项中混合<acronym class="acronym">SQL</acronym>和<span class="application">psql</span>元命令。要那样做，可以使用多个<code class="option">-c</code>选项或者把字符串用管道输送到<span class="application">psql</span>中，例如：
</p><pre class="programlisting">
psql -c '\x' -c 'SELECT * FROM foo;'
</pre><p>
       或者
</p><pre class="programlisting">
echo '\x \\ SELECT * FROM foo;' | psql
</pre><p>
       （<code class="literal">\\</code>是分隔符元命令）。
      </p><p>
       每一个被传递给<code class="option">-c</code>的<acronym class="acronym">SQL</acronym>命令字符串会被当做一个单独的请求发送给服务器。因此，即便该字符串包括多个<acronym class="acronym">SQL</acronym>命令，服务器也会把它当做一个事务来执行，除非在该字符串中有显式的<code class="command">BEGIN</code>/<code class="command">COMMIT</code>命令把它划分成多个事务（服务器如何处理多查询字符串的更多细节请参考<a class="xref" href="protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT" title="52.2.2.1. 一个简单查询中的多条语句">第 52.2.2.1 节</a>）。此外，<span class="application">psql</span>只会打印出该字符串中最后一个<acronym class="acronym">SQL</acronym>命令的结果。这和从文件中读取同一字符串或者把同一字符串传给<span class="application">psql</span>的标准输出时的行为不同，因为那两种情况下<span class="application">psql</span>会独立地发送每一个<acronym class="acronym">SQL</acronym>命令。
      </p><p>
       由于这种行为，把多于一个SQL命令放在<code class="option">-c</code>字符串中通常会得到意料之外的结果。最好使用多个<code class="option">-c</code>命令或者把多个命令输送给<span class="application">psql</span>的标准输入，按照上文所说的使用<span class="application">echo</span>或者通过一个 shell，例如：
</p><pre class="programlisting">
psql &lt;&lt;EOF
\x
SELECT * FROM foo;
EOF
</pre><p>
      </p></dd><dt><span class="term"><code class="option">--csv</code></span></dt><dd><p>
      切换到<acronym class="acronym">CSV</acronym>（逗号分隔值）输出模式。 这相当于<code class="command">\pset format csv</code>。
      </p></dd><dt><span class="term"><code class="option">-d <em class="replaceable"><code>dbname</code></em></code><br /></span><span class="term"><code class="option">--dbname=<em class="replaceable"><code>dbname</code></em></code></span></dt><dd><p>
       指定要连接的数据库的名称。这等效于指定<em class="replaceable"><code>dbname</code></em>为命令行上的第一个非选项参数。
      </p><p>
       如果这个参数包含一个<code class="symbol">=</code>符号或者以一个合法的<acronym class="acronym">URI</acronym>前缀（<code class="literal">postgresql://</code>或者<code class="literal">postgres://</code>）开始，它会被当作一个<em class="parameter"><code>conninfo</code></em>字符串。详见<a class="xref" href="libpq-connect.html#LIBPQ-CONNSTRING" title="33.1.1. 连接字符串">第 33.1.1 节</a>。
      </p></dd><dt><span class="term"><code class="option">-e</code><br /></span><span class="term"><code class="option">--echo-queries</code></span></dt><dd><p>
      也把发送到服务器的所有 SQL 命令复制到标准输出。这等效于把变量<code class="varname">ECHO</code>设置为<code class="literal">queries</code>。
      </p></dd><dt><span class="term"><code class="option">-E</code><br /></span><span class="term"><code class="option">--echo-hidden</code></span></dt><dd><p>
      回显<code class="command">\d</code>以及其他反斜线命令生成的实际查询。可以用它来学习<span class="application">psql</span>的内部操作。这等效于把变量<code class="varname">ECHO_HIDDEN</code>设置为<code class="literal">on</code>。
      </p></dd><dt><span class="term"><code class="option">-f <em class="replaceable"><code>filename</code></em></code><br /></span><span class="term"><code class="option">--file=<em class="replaceable"><code>filename</code></em></code></span></dt><dd><p>
       从文件<em class="replaceable"><code>filename</code></em>而不是标准输入中读取命令。这个选项可以被重复多次，也可以以任意顺序与<code class="option">-c</code>选项组合。当<code class="option">-c</code>或者<code class="option">-f</code>被指定时，<span class="application">psql</span>不会从标准输入读取命令，直到它处理完序列中所有的<code class="option">-c</code>和<code class="option">-f</code>选项之后终止。除此以外，这个选项很大程度上等价于元命令<code class="command">\i</code>。
      </p><p>
       如果<em class="replaceable"><code>filename</code></em>是<code class="literal">-</code>（连字符），那么会读取标准输入直到遇见一个 EOF 指示或者<code class="command">\q</code>元命令。这种方式可以用把自多个文件的输入组合成一种交互式输入。不过注意在这种情况下不会使用 Readline（很像指定了<code class="option">-n</code>的情况）。
      </p><p>
      使用这个选项与<code class="literal">psql &lt; <em class="replaceable"><code>filename</code></em></code>有细微的不同。通常，两种形式都可以做到我们所期望的，但是使用<code class="literal">-f</code>启用了一些好的特性，例如带有行号的错误消息。使用这个选项还有一丝机会可以降低启动开销。在另一方面，使用 shell输入重定向的变体（理论上）保证会得到与手工输入时相同的输出。
      </p></dd><dt><span class="term"><code class="option">-F <em class="replaceable"><code>separator</code></em></code><br /></span><span class="term"><code class="option">--field-separator=<em class="replaceable"><code>separator</code></em></code></span></dt><dd><p>
      使用<em class="replaceable"><code>separator</code></em>作为非对齐输出的域分隔符。这等效于<code class="command">\pset fieldsep</code>或者<code class="command">\f</code>。
      </p></dd><dt><span class="term"><code class="option">-h <em class="replaceable"><code>hostname</code></em></code><br /></span><span class="term"><code class="option">--host=<em class="replaceable"><code>hostname</code></em></code></span></dt><dd><p>
      指定运行服务器的机器的主机名。如果这个值由一个斜线开始，它会被用作 Unix 域套接字的目录。
      </p></dd><dt><span class="term"><code class="option">-H</code><br /></span><span class="term"><code class="option">--html</code></span></dt><dd><p>
      切换到<acronym class="acronym">HTML</acronym>输出模式。这等效于<code class="command">\pset format html</code>或者<code class="command">\H</code>命令。
      </p></dd><dt><span class="term"><code class="option">-l</code><br /></span><span class="term"><code class="option">--list</code></span></dt><dd><p>
      列出所有可用的数据库，然后退出。其他非连接选项会被忽略。这与元命令<code class="command">\list</code>类似。
      </p><p>
      在使用这个选项时，<span class="application">psql</span>将连接到数据库<code class="literal">postgres</code>，除非在命令行上提及一个不同的数据（选项<code class="option">-d</code>或非选项参数，可能是通过一个服务项，但不能通过一个环境变量）。
      </p></dd><dt><span class="term"><code class="option">-L <em class="replaceable"><code>filename</code></em></code><br /></span><span class="term"><code class="option">--log-file=<em class="replaceable"><code>filename</code></em></code></span></dt><dd><p>
       除了把所有查询输出写到普通输出目标之外，还写到文件<em class="replaceable"><code>filename</code></em>中。
      </p></dd><dt><span class="term"><code class="option">-n</code><br /></span><span class="term"><code class="option">--no-readline</code></span></dt><dd><p>
       不使用<span class="application">Readline</span>做行编辑并且不使用命令历史。在剪切和粘贴时，关掉 Tab 展开会有所帮助。
      </p></dd><dt><span class="term"><code class="option">-o <em class="replaceable"><code>filename</code></em></code><br /></span><span class="term"><code class="option">--output=<em class="replaceable"><code>filename</code></em></code></span></dt><dd><p>
      把所有查询输出放到文件<em class="replaceable"><code>filename</code></em>中。这等效于命令<code class="command">\o</code>。
      </p></dd><dt><span class="term"><code class="option">-p <em class="replaceable"><code>port</code></em></code><br /></span><span class="term"><code class="option">--port=<em class="replaceable"><code>port</code></em></code></span></dt><dd><p>
      指定服务器用于监听连接的 TCP 端口或者本地 Unix 域套接字文件扩展。默认是<code class="envar">PGPORT</code>环境变量的值，如果没有设置，则默认为编译时指定的端口号（通常是5432）。
      </p></dd><dt><span class="term"><code class="option">-P <em class="replaceable"><code>assignment</code></em></code><br /></span><span class="term"><code class="option">--pset=<em class="replaceable"><code>assignment</code></em></code></span></dt><dd><p>
      以<code class="command">\pset</code>的形式指定打印选项。注意，这里你必须用一个等号而不是空格来分隔名称和值。例如，要设置输出格式为<span class="application">LaTeX</span>，应该写成<code class="literal">-P format=latex</code>。
      </p></dd><dt><span class="term"><code class="option">-q</code><br /></span><span class="term"><code class="option">--quiet</code></span></dt><dd><p>
      指定<span class="application">psql</span>应该安静地工作。默认情况下，它会打印出欢迎消息以及多种输出。如果使用了这个选项，以上那些就都不会输出。在使用<code class="option">-c</code>选项时，配合这个选项很有用。这等效于设置变量<code class="varname">QUIET</code>为<code class="literal">on</code>。
      </p></dd><dt><span class="term"><code class="option">-R <em class="replaceable"><code>separator</code></em></code><br /></span><span class="term"><code class="option">--record-separator=<em class="replaceable"><code>separator</code></em></code></span></dt><dd><p>
      把<em class="replaceable"><code>separator</code></em>用作非对齐输出的记录分隔符。这等效于<code class="command">\pset recordsep</code>命令。
      </p></dd><dt><span class="term"><code class="option">-s</code><br /></span><span class="term"><code class="option">--single-step</code></span></dt><dd><p>
      运行在单步模式中。这意味着在每个命令被发送给服务器之前都会提示用户一个可以取消执行的选项。使用这个选项可以调试脚本。
      </p></dd><dt><span class="term"><code class="option">-S</code><br /></span><span class="term"><code class="option">--single-line</code></span></dt><dd><p>
      运行在单行模式中，其中新行会终止一个 SQL 命令，就像分号的作用一样。
      </p><div class="note"><h3 class="title">注意</h3><p>
      这种模式被提供给那些坚持使用它的用户，但是并不一定要使用它。特别地，如果在一行中混合了<acronym class="acronym">SQL</acronym>和元命令，那对于没有经的用户来说，它们的执行顺序可能不总是那么清晰。
      </p></div></dd><dt><span class="term"><code class="option">-t</code><br /></span><span class="term"><code class="option">--tuples-only</code></span></dt><dd><p>
      关闭打印列名和结果行计数页脚等。这等效于<code class="command">\t</code>或者<code class="command">\pset tuples_only</code>命令。
      </p></dd><dt><span class="term"><code class="option">-T <em class="replaceable"><code>table_options</code></em></code><br /></span><span class="term"><code class="option">--table-attr=<em class="replaceable"><code>table_options</code></em></code></span></dt><dd><p>
      指定要替换<acronym class="acronym">HTML</acronym> <code class="sgmltag-element">table</code>标签的选项。详见<code class="command">\pset tableattr</code>。
      </p></dd><dt><span class="term"><code class="option">-U <em class="replaceable"><code>username</code></em></code><br /></span><span class="term"><code class="option">--username=<em class="replaceable"><code>username</code></em></code></span></dt><dd><p>
      作为用户<em class="replaceable"><code>username</code></em>而不是默认用户连接到数据库（当然，你必须具有这样做的权限）。
      </p></dd><dt><span class="term"><code class="option">-v <em class="replaceable"><code>assignment</code></em></code><br /></span><span class="term"><code class="option">--set=<em class="replaceable"><code>assignment</code></em></code><br /></span><span class="term"><code class="option">--variable=<em class="replaceable"><code>assignment</code></em></code></span></dt><dd><p>
      执行一次变量赋值，和<code class="command">\set</code>元命令相似。注意你必须在命令行上用等号分隔名字和值（如果有）。要重置一个变量，去掉等号就行。要把一个变量置为空值，使用等号但是去掉值。这些赋值在命令行处理期间被完成，因此反映连接状态的变量将在稍后被覆盖。
      </p></dd><dt><span class="term"><code class="option">-V</code><br /></span><span class="term"><code class="option">--version</code></span></dt><dd><p>
      打印<span class="application">psql</span>版本并且退出。
      </p></dd><dt><span class="term"><code class="option">-w</code><br /></span><span class="term"><code class="option">--no-password</code></span></dt><dd><p>
       从不发出一个口令提示。如果服务器要求口令认证并且没有其他方式提供口令（例如一个<code class="filename">.pgpass</code>文件），那儿连接尝试将失败。这个选项对于批处理任务和脚本有用，因为在其中没有一个用户来输入口令。
      </p><p>
       注意这个选项将对整个会话保持设置，并且因此它会影响元命令<code class="command">\connect</code>的使用，就像初始的连接尝试那样。
      </p></dd><dt><span class="term"><code class="option">-W</code><br /></span><span class="term"><code class="option">--password</code></span></dt><dd><p>
       强制<span class="application">psql</span>在连接到一个数据库之前提示要求一个口令。
      </p><p>
       这个选项不是必不可少的，因为如果服务器要求口令认证，<span class="application">psql</span>将自动提示要求一个口令。但是，<span class="application">psql</span>将浪费一次连接尝试来发现服务器想要一个口令。在某些情况下值得用<code class="option">-W</code>来避免额外的连接尝试。
      </p><p>
       注意这个选项将对整个会话保持设置，并且因此它会影响元命令<code class="command">\connect</code>的使用，就像初始的连接尝试那样。
      </p></dd><dt><span class="term"><code class="option">-x</code><br /></span><span class="term"><code class="option">--expanded</code></span></dt><dd><p>
      打开扩展表格式模式。这等效于<code class="command">\x</code>或者<code class="command">\pset expanded</code>命令。
      </p></dd><dt><span class="term"><code class="option">-X,</code><br /></span><span class="term"><code class="option">--no-psqlrc</code></span></dt><dd><p>
      不读取启动文件（要么是系统范围的<code class="filename">psqlrc</code>文件，要么是用户的<code class="filename">~/.psqlrc</code>文件）。
      </p></dd><dt><span class="term"><code class="option">-z</code><br /></span><span class="term"><code class="option">--field-separator-zero</code></span></dt><dd><p>
      设置非对齐输出的域分隔符为零字节。这等效于<code class="command">\pset fieldsep_zero</code>。
      </p></dd><dt><span class="term"><code class="option">-0</code><br /></span><span class="term"><code class="option">--record-separator-zero</code></span></dt><dd><p>
      设置非对齐输出的记录分隔符为零字节。例如，这对与<code class="literal">xargs -0</code>配合有关。这等效于<code class="command">\pset recordsep_zero</code>。
      </p></dd><dt><span class="term"><code class="option">-1</code><br /></span><span class="term"><code class="option">--single-transaction</code></span></dt><dd><p>
        这个选项只能被用于与一个或者多个<code class="option">-c</code>以及/或者<code class="option">-f</code>选项组合。它会让<span class="application">psql</span>在第一个上述选项之前发出一条<code class="command">BEGIN</code>命令并且在最后一个上述选项之后发出一条<code class="command">COMMIT</code>命令，这样就把所有的命令都包裹在一个事务中。这个选项可以保证要么所有的命令都成功地完成，要么不应用任何更改。
       </p><p>
        如果命令本身包含<code class="command">BEGIN</code>、<code class="command">COMMIT</code>或者<code class="command">ROLLBACK</code>，这个选项将不会得到想要的效果。还有，如果当个命令不能在一个事务块中执行，指定这个选项将导致整个事务失败。
       </p></dd><dt><span class="term"><code class="option">-?</code><br /></span><span class="term"><code class="option">--help[=<em class="replaceable"><code>topic</code></em>]</code></span></dt><dd><p>
      显示有关<span class="application">psql</span>的帮助并且退出。可选的<em class="replaceable"><code>topic</code></em>参数（默认为<code class="literal">options</code>）选择要解释哪一部分的<span class="application">psql</span>：<code class="literal">commands</code>描述<span class="application">psql</span>的反斜线命令；<code class="literal">options</code>描述可以被传递给<span class="application">psql</span>的命令行选项；而<code class="literal">variables</code>则显示有关<span class="application">psql</span>配置变量的帮助。
      </p></dd></dl></div></div><div class="refsect1" id="id-1.9.4.18.7"><h2>退出状态</h2><p>
   如果<span class="application">psql</span>正常完成，它会向 shell 返回 0。如果它自身发生一个致命错误（例如内存用完、找不到文件），它会返回 1。如果到服务器的连接出问题并且事务不是交互式的，它会返回 2。如果在脚本中发生错误，它会返回 3 并且变量<code class="varname">ON_ERROR_STOP</code>会被设置。
  </p></div><div class="refsect1" id="id-1.9.4.18.8"><h2>用法</h2><div class="refsect2" id="R2-APP-PSQL-CONNECTING"><h3>连接到数据库</h3><p>
    <span class="application">psql</span>是一个常规<span class="productname">PostgreSQL</span>客户端应用。为了连接到数据库，你需要知道你的目标数据库的名称、主机名和该服务器的端口号，还有要作为哪个用户名连接。可以通过命令行选项告知<span class="application">psql</span>这些参数，分别是<code class="option">-d</code>、<code class="option">-h</code>、<code class="option">-p</code>以及<code class="option">-U</code>。如果发现一个参数不属于任何选项，它将被解释为数据库名称（如果已经给出数据库名称，就解释为用户名）。并非所有这些选项都是必需的，它们都有可用的默认值。如果省略主机名，<span class="application">psql</span>将通过一个 Unix 域套接字连接到本地主机上的服务器，或者通过 TCP/IP 连接到没有 Unix 域套接字的主机上的<code class="literal">localhost</code>。默认端口号则在编译时决定。由于数据库服务器使用相同的默认值，大多数情况下你将不必指定端口。默认的用户名是你的操作系统用户名，它也会是默认的数据库名。注意你不一定能连接到任意用户名下的任何数据库。你的数据库管理员应该已经告知过你有关你的访问权限。
    </p><p>
    当默认值不是很符合实际时，可以把环境变量<code class="envar">PGDATABASE</code>、<code class="envar">PGHOST</code>、<code class="envar">PGPORT</code>以及<code class="envar">PGUSER</code>设置为适当的值，这样也能节省一些敲打键盘的工作（额外的环境变量可见<a class="xref" href="libpq-envars.html" title="33.14. 环境变量">第 33.14 节</a>）。用一个<code class="filename">~/.pgpass</code>文件来避免定期输入密码也很方便。详见<a class="xref" href="libpq-pgpass.html" title="33.15. 口令文件">第 33.15 节</a>。
    </p><p>
     另一种指定连接参数的方法是用一个<em class="parameter"><code>conninfo</code></em>字符串或者一个<acronym class="acronym">URI</acronym>，它可以被用来替代数据库名。这种机制可以让我们对连接具有很广的控制权。例如：
</p><pre class="programlisting">
$ <strong class="userinput"><code>psql "service=myservice sslmode=require"</code></strong>
$ <strong class="userinput"><code>psql postgresql://dbmaster:5433/mydb?sslmode=require</code></strong>
</pre><p>
     用这种方式，你也可以把<acronym class="acronym">LDAP</acronym>用于<a class="xref" href="libpq-ldap.html" title="33.17. 连接参数的 LDAP 查找">第 33.17 节</a>中描述的连接参数查找。可用连接选项的更多信息请见<a class="xref" href="libpq-connect.html#LIBPQ-PARAMKEYWORDS" title="33.1.2. 参数关键词">第 33.1.2 节</a>。
    </p><p>
    如果由于任何原因（例如权限不足、服务器没有在目标主机上运行等）导致连接无法建立，<span class="application">psql</span>将返回一个错误并且终止。
    </p><p>
     如果标准输入和标准输出都是一个终端，那么<span class="application">psql</span>会把客户端编码设置成<span class="quote">“<span class="quote">auto</span>”</span>，这会使<span class="application">psql</span>从区域设置（Unix 系统上的<code class="envar">LC_CTYPE</code>环境变量）中检测合适的客户端编码。如果这样不起作用，可以使用环境变量<code class="envar">PGCLIENTENCODING</code>覆盖客户端编码。
    </p></div><div class="refsect2" id="R2-APP-PSQL-4"><h3>输入 SQL 命令</h3><p>
    在正常操作时，<span class="application">psql</span>会提供一个提示符，该提示符是<span class="application">psql</span>当前连接到的数据库名称后面跟上字符串<code class="literal">=&gt;</code>。例如：
</p><pre class="programlisting">
$ <strong class="userinput"><code>psql testdb</code></strong>
psql (12.2)
Type "help" for help.

testdb=&gt;
</pre><p>
    </p><p>
    在提示符下，用户可以键入<acronym class="acronym">SQL</acronym>命令。正常情况下，当碰到一个表示命令终结的分号时，输入的行会被发送给服务器。一行的结束并不表示命令的完结。因此，为了清晰，可以把命令散布在多个行上。如果命令被发送并且执行而不产生错误，该命令的结果将会显示在屏幕上。
    </p><p>
    如果不可信用户对还没有采用<a class="link" href="ddl-schemas.html#DDL-SCHEMAS-PATTERNS" title="5.9.6. 使用模式">安全方案使用模式</a>的一个而数据库拥有访问，通过从<code class="varname">search_path</code>移除公共可写的方案来开始你的会话。人们可以在连接字符串中加入<code class="literal">options=-csearch_path=</code>或者在其他SQL命令之前发出<code class="literal">SELECT pg_catalog.set_config('search_path', '', false)</code>。这种考虑并非专门针对<span class="application">psql</span>，它适用于每一种执行任意SQL命令的接口。
    </p><p>
    只要执行命令，<span class="application">psql</span>还会测试<a class="xref" href="sql-listen.html" title="LISTEN"><span class="refentrytitle">LISTEN</span></a>和<a class="xref" href="sql-notify.html" title="NOTIFY"><span class="refentrytitle">NOTIFY</span></a>产生的异步通知。
    </p><p>
    虽然 C 风格的注释块会被传给服务器处理并且移除，<span class="application">psql</span>会自己移除掉 SQL 标准的注释。
    </p></div><div class="refsect2" id="APP-PSQL-META-COMMANDS"><h3>元命令</h3><p>
    你输入到<span class="application">psql</span>中的任何以未加引用的反斜线开始的东西都是一个<span class="application">psql</span>元命令，它们由<span class="application">psql</span>自行处理。这些命令让<span class="application">psql</span>对管理和编写脚本更有用。元命令常常被称作斜线或者反斜线命令。
    </p><p>
    <span class="application">psql</span>命令的格式是用反斜线后面直接跟上一个命令动词，然后是一些参数。参数与命令动词和其他参数之间用任意多个空白字符分隔开。
    </p><p>
    要在一个参数中包括空白，可以将它加上单引号。要在一个参数中包括一个单引号，则需要在文本中写上两个单引号。任何包含在单引号中的东西都服从与 C 语言中<code class="literal">\n</code>（新行）、<code class="literal">\t</code>（制表符）、<code class="literal">\b</code>（退格）、<code class="literal">\r</code>（回车）、<code class="literal">\f</code>（换页）、<code class="literal">\</code><em class="replaceable"><code>digits</code></em>（10 进制）以及<code class="literal">\x</code><em class="replaceable"><code>digits</code></em>（16 进制）类似的替换规则。单引号内文本中的其他任何字符（不管它是什么）前面的反斜线都没有实际意义（会被忽略）。
    </p><p>
    如果在一个参数中出现一个未加引号的冒号（<code class="literal">:</code>）后面跟着一个<span class="application">psql</span>变量名，它会被该变量的值替换，如<a class="xref" href="app-psql.html#APP-PSQL-INTERPOLATION" title="SQL 中插入变量"><acronym class="acronym">SQL</acronym> 中插入变量</a>中所述。在其中描述的形式<code class="literal">:'<em class="replaceable"><code>variable_name</code></em>'</code>和<code class="literal">:"<em class="replaceable"><code>variable_name</code></em>"</code>也有同样的效果。<code class="literal">:{?<em class="replaceable"><code>variable_name</code></em>}</code>语法允许测试一个变量是否被定义。它会被TRUE或FALSE替换。用一个反斜线转义该冒号可以防止它被替换。
    </p><p>
    在一个参数中，封闭在反引号（<code class="literal">`</code>）中的文本会被当做一个传递给shell的命令行。该命令的输出（移除任何拖尾的新行）会替换反引号文本。在封闭在反引号的文本中，不会有特别的引号或者其他处理发生，<code class="literal">:<em class="replaceable"><code>variable_name</code></em></code>的出现除外，其中<em class="replaceable"><code>variable_name</code></em>是一个会被其值替换的<span class="application">psql</span>变量名。此外，Also, appearances of
    <code class="literal">:'<em class="replaceable"><code>variable_name</code></em>'</code>的出现会被替换为该变量的值，而值会被适当地加以引用以变成一个单一shell命令参数（后一种形式几乎总是优先，除非你非常确定变量中有什么）。因为回车和换行字符在所有的平台上都不能被安全地引用，<code class="literal">:'<em class="replaceable"><code>variable_name</code></em>'</code>形式会打印一个错误消息并且在这类字符出现在值中时不替换该变量值。
    </p><p>
    有些命令把<acronym class="acronym">SQL</acronym>标识符（例如一个表名）当作参数。这些参数遵循<acronym class="acronym">SQL</acronym>的语法规则：无引号的字母被强制变为小写，而双引号（<code class="literal">"</code>）可以保护字母避免大小写转换并且允许在标识符中包含空白。 在双引号内，成对的双引号会被缩减为结果名称中的单个双引号。例如，<code class="literal">FOO"BAR"BAZ</code>会被解释成<code class="literal">fooBARbaz</code>，而<code class="literal">"A weird"" name"</code>会变成<code class="literal">A weird" name</code>。
    </p><p>
    对参数的解析会在行尾或者碰到另一个未加引号的反斜线时停止。一个未加引号的反斜线被当做新元命令的开始。特殊的序列<code class="literal">\\</code>（两个反斜线）表示参数结束并且应继续解析<acronym class="acronym">SQL</acronym>命令（如果还有）。使用这种方法，<acronym class="acronym">SQL</acronym>命令和<span class="application">psql</span>命令可以被自由地混合在一行中。但是无论在何种情况中，元命令的参数都无法跨越一行。
    </p><p>
    很多元命令作用在<em class="firstterm">当前查询缓冲区</em>上。这就是一个缓冲区而已，它保存任何已经被键入但是还没有发送到服务器执行的SQL命令文本。这将包括之前输入的行以及在该元命令同一行上出现在前面的任何文本。
    </p><p>
    可以使用下列元命令：

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">\a</code></span></dt><dd><p>
        如果当前的表输出格式是非对齐的，则切换成对齐格式。如果不是非对齐格式，则设置成非对齐格式。保留这个命令是为了向后兼容性。更一般的方案请见<code class="command">\pset</code>。
        </p></dd><dt><span class="term"><code class="literal">\c</code> or <code class="literal">\connect [ -reuse-previous=<em class="replaceable"><code>on|off</code></em> ] [ <em class="replaceable"><code>dbname</code></em> [ <em class="replaceable"><code>username</code></em> ] [ <em class="replaceable"><code>host</code></em> ] [ <em class="replaceable"><code>port</code></em> ] | <em class="replaceable"><code>conninfo</code></em> ]</code></span></dt><dd><p>
        与一台<span class="productname">PostgreSQL</span>服务器建立一个新连接。可以使用位置语法指定要使用的连接参数，或者使用<a class="xref" href="libpq-connect.html#LIBPQ-CONNSTRING" title="33.1.1. 连接字符串">第 33.1.1 节</a>中详细介绍的<em class="replaceable"><code>conninfo</code></em>连接串。
        </p><p>
        在省略了数据库名、用户、主机或者端口的命令中，新的连接将会重用之前一个连接的值。默认情况下，前一个连接的值将会被重用，除非给出了一个<em class="replaceable"><code>conninfo</code></em>串。给出第一个参数<code class="literal">-reuse-previous=on</code>或者<code class="literal">-reuse-previous=off</code>可以覆盖默认行为。当这个命令既没有指定一个参数也没有重用它时，将使用<span class="application">libpq</span>的默认值。把<em class="replaceable"><code>dbname</code></em>、<em class="replaceable"><code>username</code></em>、<em class="replaceable"><code>host</code></em>或者<em class="replaceable"><code>port</code></em>中的任何一个指定为<code class="literal">-</code>等价于省略该参数。
        </p><p>
        如果新连接成功地被建立，之前的连接会被关闭。如果连接尝试失败（错误的用户名、访问被拒绝等），只有在<span class="application">psql</span>处于交互模式的情况下才会保留之前的连接。当执行一个非交互式脚本时出现连接尝试失败，处理将被立即停止，并且报出一个错误。这种区别一方面可以帮助用户发现打字错误，另一方面也可以作为一种安全机制防止脚本在错误的数据库上执行动作。
        </p><p>
        例子：
        </p><pre class="programlisting">
=&gt; \c mydb myuser host.dom 6432
=&gt; \c service=foo
=&gt; \c "host=localhost port=5432 dbname=mydb connect_timeout=10 sslmode=disable"
=&gt; \c postgresql://tom@localhost/mydb?application_name=myapp
</pre></dd><dt><span class="term"><code class="literal">\C [ <em class="replaceable"><code>title</code></em> ]</code></span></dt><dd><p>
        设置查询结果的任何表的标题，或者重置这类标题。这个命令等效于<code class="literal">\pset title <em class="replaceable"><code>title</code></em></code>（这个命令的名称来自于<span class="quote">“<span class="quote">caption</span>”</span>，因为它之前只被用来在<acronym class="acronym">HTML</acronym>表格中设置标题）。
        </p></dd><dt><span class="term"><code class="literal">\cd [ <em class="replaceable"><code>directory</code></em> ]</code></span></dt><dd><p>
         把当前工作目录改为<em class="replaceable"><code>directory</code></em>。如果不带参数，则切换到当前用户的主目录。
        </p><div class="tip"><h3 class="title">提示</h3><p>
          要打印当前的工作目录，可以使用<code class="literal">\! pwd</code>。
         </p></div></dd><dt><span class="term"><code class="literal">\conninfo</code></span></dt><dd><p>
        输出有关当前数据库连接的信息。
        </p></dd><dt id="APP-PSQL-META-COMMANDS-COPY"><span class="term"><code class="literal">\copy { <em class="replaceable"><code>table</code></em> [ ( <em class="replaceable"><code>column_list</code></em> ) ] | ( <em class="replaceable"><code>query</code></em> ) }
        { <code class="literal">from</code> | <code class="literal">to</code> }
        { <em class="replaceable"><code>'filename'</code></em> | program <em class="replaceable"><code>'command'</code></em> | stdin | stdout | pstdin | pstdout }
        [ [ with ] ( <em class="replaceable"><code>option</code></em> [, ...] ) ]</code></span></dt><dd><p>
        执行一次前端拷贝。这个操作会运行一个<acronym class="acronym">SQL</acronym> <a class="xref" href="sql-copy.html" title="COPY"><span class="refentrytitle">COPY</span></a>命令，不过不是服务器读取或者写入指定的文件，而是由<span class="application">psql</span>读写文件并且把数据从本地文件系统导向服务器。这意味着文件的可访问性和权限是本地用户的而非服务器上的，并且不需要 SQL 超级用户特权。
        </p><p>
        当<code class="literal">program</code>被指定时，<em class="replaceable"><code>command</code></em>被<span class="application">psql</span>执行并且传给<em class="replaceable"><code>command</code></em>的数据或者从<em class="replaceable"><code>command</code></em>传出的数据会在服务器和客户端之间流动。同样地，执行特权是本地用户的而非服务器上的，并且不需要 SQL 超级用户特权。
        </p><p>
        对于<code class="literal">\copy ... from stdin</code>，数据行从发出该命令的同一来源读取，一直到读到<code class="literal">\.</code>或者数据流到达<acronym class="acronym">EOF</acronym>。这个选项可以用来填充内嵌在一个 SQL 脚本文件中的表。对于<code class="literal">\copy ... to stdout</code>，输出被发送到与<span class="application">psql</span>命令输出相同的位置，并且<code class="literal">COPY <em class="replaceable"><code>count</code></em></code>命令的状态不会被打印（因为它会被一个数据行搞乱）。要读/写<span class="application">psql</span>的标准输入或者输出而不管当前命令的来源或者<code class="literal">\o</code>选项，可以写<code class="literal">from pstdin</code>或者<code class="literal">to pstdout</code>。
        </p><p>
        这个命令的语法和<acronym class="acronym">SQL</acronym> <a class="xref" href="sql-copy.html" title="COPY"><span class="refentrytitle">COPY</span></a>命令类似。所有除开数据来源/目的地的选项都和<a class="xref" href="sql-copy.html" title="COPY"><span class="refentrytitle">COPY</span></a>指定的一样。因此，<code class="command">\copy</code>元命令由特殊的解析规则。与大部分其他元命令不同，该行的所有剩余部分总是会被当做<code class="command">\copy</code>的参数，并且在参数中不会执行变量篡改以及反引号展开。
        </p><div class="tip"><h3 class="title">提示</h3><p>
        获得与<code class="literal">\copy ... to</code>相同结果的另一种方法是使用<acronym class="acronym">SQL</acronym> <code class="literal">COPY ... TO STDOUT</code>
        命令并使用<code class="literal">\g <em class="replaceable"><code>filename</code></em></code>或<code class="literal">\ g | <em class="replaceable"><code>program </code></em></code>终止它。
        与<code class="literal">\copy</code>不同，此方法允许命令跨越多行; 此外，可以使用变量插值和反引号扩展。

        </p></div><div class="tip"><h3 class="title">提示</h3><p>
        这些操作不如带有文件或程序数据源或目标的<acronym class="acronym">SQL</acronym> <code class="command">COPY</code>命令有效，
        因为所有数据都必须通过客户端/服务器连接。 对于大量数据，<acronym class="acronym">SQL</acronym>命令可能更可取。
        </p></div></dd><dt><span class="term"><code class="literal">\copyright</code></span></dt><dd><p>
        显示<span class="productname">PostgreSQL</span>的版权以及发布条款。
        </p></dd><dt id="APP-PSQL-META-COMMANDS-CROSSTABVIEW"><span class="term"><code class="literal">\crosstabview [
            <em class="replaceable"><code>colV</code></em>
            [ <em class="replaceable"><code>colH</code></em>
            [ <em class="replaceable"><code>colD</code></em>
            [ <em class="replaceable"><code>sortcolH</code></em>
            ] ] ] ] </code></span></dt><dd><p>
        执行当前的查询缓冲区（像<code class="literal">\g</code>那样）并且在一个交叉表格子中显示结果。该查询必须返回至少三列。由<em class="replaceable"><code>colV</code></em>标识的输出列会成为垂直页眉并且<em class="replaceable"><code>colH</code></em>所标识的输出列会成为水平页眉。<em class="replaceable"><code>colD</code></em>标识显示在格子中的输出列。<em class="replaceable"><code>sortcolH</code></em>标识用于水平页眉的可选的排序列。
        </p><p>
        每一个列说明可以是一个列编号（从 1 开始）或者一个列名。常用的 SQL 大小写折叠和引用规则适用于列名。如果省略，<em class="replaceable"><code>colV</code></em>被当做列 1 并且<em class="replaceable"><code>colH</code></em>被当做列 2。<em class="replaceable"><code>colH</code></em>必须和<em class="replaceable"><code>colV</code></em>不同。如果没有指定<em class="replaceable"><code>colD</code></em>，那么在查询结果中必须正好有三列，并且<em class="replaceable"><code>colV</code></em>和<em class="replaceable"><code>colH</code></em>之外的那一列会被当做<em class="replaceable"><code>colD</code></em>。
        </p><p>
        垂直页眉显示为最左边的列，它包含列<em class="replaceable"><code>colV</code></em>中找到的值，值的顺序和查询结果中的顺序相同，但是重复值会被移除。
        </p><p>
        水平页眉显示为第一行，它包含列<em class="replaceable"><code>colH</code></em>中找到的值，其中的重复值被移除。默认情况下，这些值会以查询结果中相同的顺序出现。但是如果给出了可选的<em class="replaceable"><code>sortcolH</code></em>参数，它标识一个值必须为整数编号的列，并且来自<em class="replaceable"><code>colH</code></em>的值将会根据相应的<em class="replaceable"><code>sortcolH</code></em>值排序后出现在水平页眉中。
        </p><p>
        在交叉表格子中，对于<em class="replaceable"><code>colH</code></em>的每一个可区分的值<code class="literal">x</code>以及<em class="replaceable"><code>colV</code></em>的每一个可区分的值<code class="literal">y</code>，位于交叉点<code class="literal">(x,y)</code>的单元包含<em class="replaceable"><code>colH</code></em>值为<code class="literal">x</code>且<em class="replaceable"><code>colV</code></em>值为<code class="literal">y</code>的查询结果行中<code class="literal">colD</code>列的值。如果没有这样的行，则该单元为空。如果有多个这样的行，则会报告一个错误。
        </p></dd><dt><span class="term"><code class="literal">\d[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        对于每一个匹配<em class="replaceable"><code>pattern</code></em>的关系（表、视图、物化视图、索引、序列或者外部表）或者组合类型，显示所有的列、它们的类型、表空间（如果非默认表空间）以及任何诸如<code class="literal">NOT NULL</code>或者默认值的特殊属性。相关的索引、约束、规则以及触发器也会被显示。对于外部表，还会显示相关的外部服务器（下文的<a class="xref" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）">模式（Pattern）</a>中定义了<span class="quote">“<span class="quote">匹配模式</span>”</span>）。
        </p><p>
        对于某些类型的关系，<code class="literal">\d</code>会为每一列显示额外的信息：对于序列会显示列值，对于索引显示被索引的表达式，对于外部表显示外部数据包装器选项。
        </p><p>
        命令形式<code class="literal">\d+</code>是一样的，不过会显示更多信息：与该表的列相关的任何注释，表中是否存在 OID，如果关系是视图则显示视图定义，非默认的<a class="link" href="sql-altertable.html#SQL-CREATETABLE-REPLICA-IDENTITY">replica identity</a>设置。
        </p><p>
        默认情况下只会显示用户创建的对象，提供一个模式或者<code class="literal">S</code>修饰符可以把系统对象包括在内。
        </p><div class="note"><h3 class="title">注意</h3><p>
        如果使用<code class="command">\d</code>但不带有<em class="replaceable"><code>pattern</code></em>参数，它等价于<code class="command">\dtvmsE</code>，后者将显示所有可见的表、视图、物化视图、序列和外部表的列表。这纯粹是一种便利措施。
        </p></div></dd><dt><span class="term"><code class="literal">\da[S] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出聚集函数，以及它们的返回类型和它们所操作的数据类型。如果指定了<em class="replaceable"><code>pattern</code></em>，只显示名称匹配该模式的聚集。默认情况下只会显示用户创建的对象，提供一个模式或者<code class="literal">S</code>修饰符可以把系统对象包括在内。
        </p></dd><dt><span class="term"><code class="literal">\dA[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出访问方法。如果指定了<em class="replaceable"><code>pattern</code></em>，只显示名称匹配该模式的访问方法。如果在命令名称后面追加<code class="literal">+</code>，则与访问方法相关的处理器函数和描述也会和访问方法本身一起被列出。
        </p></dd><dt><span class="term"><code class="literal">\db[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出表空间。如果指定了<em class="replaceable"><code>pattern</code></em>，只显示名称匹配该模式的表空间。如果在命令名称后面追加<code class="literal">+</code>，则与表空间相关的选项、磁盘上的尺寸、权限以及描述也会和表空间本身一起被列出。
        </p></dd><dt><span class="term"><code class="literal">\dc[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出字符集编码之间的转换。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的转换。默认情况下只会显示用户创建的对象，提供一个模式或者<code class="literal">S</code>修饰符可以把系统对象包括在内。如果在命令名称后面追加<code class="literal">+</code>，则每一个对象相关的描述也会被列出。
        </p></dd><dt><span class="term"><code class="literal">\dC[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出类型转换。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出源类型和目标类型匹配该模式的转换。如果在命令名称后面追加<code class="literal">+</code>，则每一个对象相关的描述也会被列出。
        </p></dd><dt><span class="term"><code class="literal">\dd[S] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        显示<code class="literal">约束</code>、<code class="literal">操作符类</code>、<code class="literal">操作符族</code>、<code class="literal">规则</code>以及<code class="literal">触发器</code>类型对象的描述。所有其他注释可以通过那些对象类型相应的反斜线命令查看。
        </p><p><code class="literal">\dd</code>显示匹配<em class="replaceable"><code>pattern</code></em>的对象的描述，如果没有给出参数则显示合适类型的可见对象的描述。但是在任一种情况下都只列出具有描述的对象。默认情况下只会显示用户创建的对象，提供一个模式或者<code class="literal">S</code>修饰符可以把系统对象包括在内。
        </p><p>
        对象的描述可以用<acronym class="acronym">SQL</acronym>命令<a class="xref" href="sql-comment.html" title="COMMENT"><span class="refentrytitle">COMMENT</span></a>创建。
       </p></dd><dt><span class="term"><code class="literal">\dD[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出域。如果指定了<em class="replaceable"><code>pattern</code></em>，只有名称匹配该模式的域会被显示。默认情况下，只有用户创建的对象会被显示，可以提供一个模式或者<code class="literal">S</code>修饰符以包括系统对象。如果<code class="literal">+</code>被追加到命令名称上，每一个被列出的对象会带有其相关的权限和描述。
        </p></dd><dt><span class="term"><code class="literal">\ddp [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出默认的访问特权设置。对那些默认特权设置已经被改变得与内建默认值不同的角色（以及模式，如果适用），为每一个角色（以及模式）显示一项。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出角色名称或者模式名称匹配该模式的项。
        </p><p>
        <a class="xref" href="sql-alterdefaultprivileges.html" title="ALTER DEFAULT PRIVILEGES"><span class="refentrytitle">ALTER DEFAULT PRIVILEGES</span></a>命令被用来设置默认访问特权。在<a class="xref" href="ddl-priv.html" title="5.7. 权限">第 5.7 节</a>中解释了显示的特权的含义。
        </p></dd><dt><span class="term"><code class="literal">\dE[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code><br /></span><span class="term"><code class="literal">\di[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code><br /></span><span class="term"><code class="literal">\dm[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code><br /></span><span class="term"><code class="literal">\ds[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code><br /></span><span class="term"><code class="literal">\dt[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code><br /></span><span class="term"><code class="literal">\dv[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        在这一组命令中，字母<code class="literal">E</code>、<code class="literal">i</code>、<code class="literal">m</code>、<code class="literal">s</code>、<code class="literal">t</code>和<code class="literal">v</code>分别对应着外部表、索引、物化视图、序列、表和视图。你可以以任何顺序指定这些字母中的任意一个或者多个，这样可以得到这些类型的对象的列表。例如，<code class="literal">\dit</code>会列出索引和表。如果在命令名称后面追加<code class="literal">+</code>，则每一个对象的物理尺寸以及相关的描述也会被列出。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的对象。默认情况下只会显示用户创建的对象，提供一个模式或者<code class="literal">S</code>修饰符可以把系统对象包括在内。
        </p></dd><dt><span class="term"><code class="literal">\des[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出外部服务器（助记：<span class="quote">“<span class="quote">外部服务器</span>”</span>）。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的那些服务器。如果使用了<code class="literal">\des+</code>形式，将显示每个服务器的完整描述，包括该服务器的 访问特权、类型、版本、选项和描述。
        </p></dd><dt><span class="term"><code class="literal">\det[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出外部表（助记：<span class="quote">“<span class="quote">外部表</span>”</span>）。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出表名称或者模式名称匹配该模式的项。如果使用了<code class="literal">\det+</code>选项，一般选项和外部表描述也会被显示。
        </p></dd><dt><span class="term"><code class="literal">\deu[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出用户映射（助记：<span class="quote">“<span class="quote">外部用户</span>”</span>）。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出用户名匹配该模式的那些映射。如果使用了<code class="literal">\deu+</code>形式，有关每个映射的额外信息也会被显示。
        </p><div class="caution"><h3 class="title">小心</h3><p>
        <code class="literal">\deu+</code>可能也会显示远程用户的用户名和口令，所以要小心不要把它们泄露出去。
        </p></div></dd><dt><span class="term"><code class="literal">\dew[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出外部数据包装器（助记：<span class="quote">“<span class="quote">外部包装器</span>”</span>）。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的那些外部数据包装器。如果使用了<code class="literal">\dew+</code>形式，外部数据包装器的访问特权、选项和描述也会被显示。
        </p></dd><dt><span class="term"><code class="literal">\df[anptwS+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出函数，以及它们的结果数据类型、参数数据类型和函数类型，函数类型被分为<span class="quote">“<span class="quote">agg</span>”</span>（聚集）、<span class="quote">“<span class="quote">normal</span>”</span>、<span class="quote">“<span class="quote">procedure</span>”</span>、<span class="quote">“<span class="quote">trigger</span>”</span>以及<span class="quote">“<span class="quote">window</span>”</span>。如果要只显示指定类型的函数，可以在该命令上增加相应的字母<code class="literal">a</code>、<code class="literal">n</code>、<code class="literal">p</code>、<code class="literal">t</code>或者<code class="literal">w</code>。如果指定了<em class="replaceable"><code>pattern</code></em>，只显示名称匹配该模式的函数。默认情况下只会显示用户创建的对象，提供一个模式或者<code class="literal">S</code>修饰符可以把系统对象包括在内。如果使用了<code class="literal">\df+</code>形式，则有关每个函数的额外信息也会被显示，包括易失性、并行安全性、拥有者、安全性分类、访问特权、语言、源代码和描述。
        </p><div class="tip"><h3 class="title">提示</h3><p>
        如果要查找接收指定数据类型参数或者返回指定类型值的函数，可以使用分页器的搜索能力来滚动显示<code class="literal">\df</code>输出。
        </p></div></dd><dt><span class="term"><code class="literal">\dF[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
         列出文本搜索配置。如果指定了<em class="replaceable"><code>pattern</code></em>，只显示名称匹配该模式的配置。如果使用了<code class="literal">\dF+</code>形式，每种配置的完整描述也会被显示，包括底层的文本搜索解析器和用于每一种解析器记号类型的字典列表。
        </p></dd><dt><span class="term"><code class="literal">\dFd[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
         列出文本搜索字典。如果指定了<em class="replaceable"><code>pattern</code></em>，只显示名称匹配该模式的字典。如果使用了<code class="literal">\dFd+</code>形式，有关每一种选中的字典的额外信息也会被显示，包括底层的文本搜索模板和选项值。
        </p></dd><dt><span class="term"><code class="literal">\dFp[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
         列出文本搜索解析器。如果指定了<em class="replaceable"><code>pattern</code></em>，只显示名称匹配该模式的解析器。如果使用了<code class="literal">\dFp+</code>形式，每一种解析器的完整描述也会被显示，包括底层的函数和可识别的记号类型列表。
        </p></dd><dt><span class="term"><code class="literal">\dFt[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
         列出文本搜索模板。如果指定了<em class="replaceable"><code>pattern</code></em>，只显示名称匹配该模式的模板。如果使用了<code class="literal">\dFt+</code>形式，每一种模板有关的额外信息也会被显示，包括底层的函数名称。
        </p></dd><dt><span class="term"><code class="literal">\dg[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出数据库角色（因为<span class="quote">“<span class="quote">用户</span>”</span>和<span class="quote">“<span class="quote">组</span>”</span>的概念已经被统一成<span class="quote">“<span class="quote">角色</span>”</span>，这个命令现在等价于<code class="literal">\du</code>）。默认情况下只会显示用户创建的角色，提供一个模式或者<code class="literal">S</code>修饰符可以把系统角色包括在内。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的那些角色。如果使用了<code class="literal">\dg+</code>形式，有关每种角色的额外信息也将被显示，当前这种形式会为角色增加显示注释。
        </p></dd><dt><span class="term"><code class="literal">\dl</code></span></dt><dd><p>
        这是<code class="command">\lo_list</code>的一个别名，它显示大对象的列表。
        </p></dd><dt><span class="term"><code class="literal">\dL[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出过程语言。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的语言。默认情况下只会显示用户创建的语言，提供一个模式或者<code class="literal">S</code>修饰符可以把系统对象包括在内。如果向命令名称追加<code class="literal">+</code>，则每一种语言会和它的调用处理器、验证器、访问特权以及它是否为系统对象一起列出。
        </p></dd><dt><span class="term"><code class="literal">\dn[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出模式（名字空间）。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的模式。默认情况下只会显示用户创建的对象，提供一个模式或者<code class="literal">S</code>修饰符可以把系统对象包括在内。如果向命令名称追加<code class="literal">+</code>，每个对象会与它相关的权限及描述（如果有）一起被列出。
        </p></dd><dt><span class="term"><code class="literal">\do[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出操作符及其操作数和结果类型。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的操作符。默认情况下只会显示用户创建的对象，提供一个模式或者<code class="literal">S</code>修饰符可以把系统对象包括在内。如果向命令名称追加<code class="literal">+</code>，有关每个操作符的额外信息也将被显示，当前只包括底层函数的名称。
        </p></dd><dt><span class="term"><code class="literal">\dO[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出排序规则。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的排序规则。默认情况下只会显示用户创建的对象，提供一个模式或者<code class="literal">S</code>修饰符可以把系统对象包括在内。如果向命令名称追加<code class="literal">+</code>，每个排序规则将和它相关的描述（如果有）一起被列出。注意只有可用于当前数据库编码的排序规则会被显示，因此在同一个安装下的不同数据库中执行此命令可能会得到不同的结果。
        </p></dd><dt><span class="term"><code class="literal">\dp [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出表、视图和序列，包括与它们相关的访问特权。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的表、视图以及序列。
        </p><p>
        <a class="xref" href="sql-grant.html" title="GRANT"><span class="refentrytitle">GRANT</span></a>和<a class="xref" href="sql-revoke.html" title="REVOKE"><span class="refentrytitle">REVOKE</span></a>命令被用来设置访问特权。所显示的特权的含义在<a class="xref" href="ddl-priv.html" title="5.7. 权限">第 5.7 节</a>中有介绍。
        </p></dd><dt><span class="term"><code class="literal">\dP[itn+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出分区关系。如果指定了<em class="replaceable"><code>pattern</code></em>，则仅列出名称与模式匹配的条目。
        修改符<code class="literal">t</code>（表）和<code class="literal">i</code>（索引）可以追加到命令中，筛选要列出的关系类型。默认会列出分区表和索引。
        </p><p>
        如果用了修饰符<code class="literal">n</code>（<span class="quote">“<span class="quote">nested</span>”</span>）或指定了模式，则包括非根分区关系，并显示每个分区关系的父级的列。
        </p><p>
        如果<code class="literal">+</code>被附加到命令名中，那么还会显示每个关系分区的大小总和，以及关系的描述。
        如果<code class="literal">n</code>与<code class="literal">_</code>相结合，将显示两种大小：一种包含直接连接的叶分区的总大小，另一种显示所有分区的总大小，包括间接附加的子分区。
        </p></dd><dt><span class="term"><code class="literal">\drds [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>role-pattern</code></em></a> [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>database-pattern</code></em></a> ] ]</code></span></dt><dd><p>
        列出已定义的配置设置。这些设置可以是针对角色的、针对数据库的或者同时针对两者的。<em class="replaceable"><code>role-pattern</code></em>和<em class="replaceable"><code>database-pattern</code></em>分别被用来选择要列出的角色和数据库。如果省略它们或者指定了<code class="literal">*</code>，则会列出所有设置，分别会包括针对角色和针对数据库的设置。
        </p><p>
        <a class="xref" href="sql-alterrole.html" title="ALTER ROLE"><span class="refentrytitle">ALTER ROLE</span></a>以及<a class="xref" href="sql-alterdatabase.html" title="ALTER DATABASE"><span class="refentrytitle">ALTER DATABASE</span></a>命令可以用来定义一个角色以及一个数据库的配置设置。
        </p></dd><dt><span class="term"><code class="literal">\dRp[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出复制的publication。如果指定有<em class="replaceable"><code>pattern</code></em>，只有那些名称匹配该模式的publication会被列出。如果<code class="literal">+</code>被追加到命令的名称上，与每个publication相关的表也会被显示。
        </p></dd><dt><span class="term"><code class="literal">\dRs[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出复制的订阅。如果指定有<em class="replaceable"><code>pattern</code></em>，只有那些名字匹配该模式的订阅才会被列出。如果<code class="literal">+</code>被追加到命令的名称上，订阅的额外属性会被显示。
        </p></dd><dt><span class="term"><code class="literal">\dT[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出数据类型。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的类型。如果向命令名称追加<code class="literal">+</code>，每一种类型、其内部名称和尺寸、允许的值（如果是一种<code class="type">enum</code>类型）以及相关权限会被一同列出。默认情况下只会显示用户创建的对象，提供一个模式或者<code class="literal">S</code>修饰符可以把系统对象包括在内。
        </p></dd><dt><span class="term"><code class="literal">\du[S+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出数据库角色（因为<span class="quote">“<span class="quote">用户</span>”</span>和<span class="quote">“<span class="quote">组</span>”</span>的概念已经被统一成<span class="quote">“<span class="quote">角色</span>”</span>，这个命令现在等价于<code class="literal">\dg</code>）。默认情况下只会显示用户创建的角色，提供一个模式或者<code class="literal">S</code>修饰符可以把系统角色包括在内。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的那些角色。如果使用了<code class="literal">\du+</code>形式，有关每一种角色的额外信息也会被显示，当前只会多显示角色的注释。
        </p></dd><dt><span class="term"><code class="literal">\dx[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出已安装的扩展。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的那些扩展。如果使用了<code class="literal">\dx+</code>形式，所有属于每个匹配扩展的对象会被列出。
        </p></dd><dt><span class="term"><code class="literal">\dy[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出事件触发器。如果指定了<em class="replaceable"><code>pattern</code></em>，只列出名称匹配该模式的事件触发器。如果在命令名称后面加上<code class="literal">+</code>，还会为每个列出的对象显示其相关的描述。
        </p></dd><dt><span class="term"><code class="literal">\e</code>或<code class="literal">\edit</code> <code class="literal"> [<span class="optional"> <em class="replaceable"><code>filename</code></em> </span>] [<span class="optional"> <em class="replaceable"><code>line_number</code></em> </span>] </code></span></dt><dd><p>
        如果指定了<em class="replaceable"><code>filename</code></em>，则它是被编辑的文件，在编辑器退出后，该文件的内容会被拷贝到当前查询缓冲区中。如果没有给定<em class="replaceable"><code>filename</code></em>，当前查询缓冲区会被拷贝到一个临时文件中，并且接着以相同的方式编辑。或者，如果当前查询缓冲区为空，则最近被执行的查询会被拷贝到一个临时文件并且以同样的方式编辑。
        </p><p>
        然后会根据<span class="application">psql</span>的一般规则重新解析查询缓冲区的新内容，把整个缓冲区当作一个单一行来处理。任何完整的查询都会被立即执行，也就是说，如果查询缓冲区包含一个分号或者以一个分号结尾，则到分号处为止的所有东西都会被执行。剩下的东西会在查询缓冲区中等待，输入分号或者<code class="literal">\g</code>会把它发送出去，输入<code class="literal">\r</code>会通过清除查询缓冲区来取消它。把缓冲区当作单一行主要会影响元命令：缓冲区中在一个元命令之后的任何东西都将被当作该元命令的参数，即便元命令之后的内容跨越多行也是如此。（因此不能以这种方式来制作使用元命令的脚本。应该使用<code class="command">\i</code>。）
        </p><p>
        如果指定了一个行号，<span class="application">psql</span>将会把游标（注意不是服务器端的游标）定位到文件或者查询缓冲区的指定行上。注意如果给出了一个全是数字的参数，<span class="application">psql</span>就会假定它是行号而不是文件名。
        </p><div class="tip"><h3 class="title">提示</h3><p>
        关于如何配置以及自定义编辑器，请见<a class="xref" href="app-psql.html#APP-PSQL-ENVIRONMENT" title="环境">环境</a>。
        </p></div></dd><dt><span class="term"><code class="literal">\echo <em class="replaceable"><code>text</code></em> [ ... ]</code></span></dt><dd><p>
        把参数打印到标准输出，参数之间用一个空格分隔，最后加上一个新行。这可以用来在脚本的输出中间混入信息，例如：
</p><pre class="programlisting">
=&gt; <strong class="userinput"><code>\echo `date`</code></strong>
Tue Oct 26 21:40:57 CEST 1999
</pre><p>
        如果第一个参数是一个没有加引号的<code class="literal">-n</code>，则不会加上最后的新行。
        </p><div class="tip"><h3 class="title">提示</h3><p>
        如果使用<code class="command">\o</code>命令来重定向查询的输出，你可能希望使用<code class="command">\qecho</code>来取代这个命令。
        </p></div></dd><dt><span class="term"><code class="literal">\ef [<span class="optional"> <em class="replaceable"><code>function_description</code></em> [<span class="optional">  <em class="replaceable"><code>line_number</code></em> </span>] </span>] </code></span></dt><dd><p>
         这个命令会以一个<code class="command">CREATE OR REPLACE FUNCTION</code>或<code class="command">CREATE OR REPLACE PROCEDURE</code>命令的形式取出并且编辑指定函数或过程的定义。编辑的方式与<code class="literal">\edit</code>完全相同。在编辑器退出后，更新过的命令将在查询缓冲区中等待，可以键入分号或者<code class="literal">\g</code>把它发出，也可以用<code class="literal">\r</code>取消之。
        </p><p>
         目标函数可以单独用名称或者用名称和参数（例如<code class="literal">foo(integer, text)</code>）来指定。如果有多于一个函数具有同样的名称，则必须给出参数的类型。
        </p><p>
         如果没有指定函数，将会给出一个空白的<code class="command">CREATE FUNCTION</code>模板来编辑。
        </p><p>
        如果指定了一个行号，<span class="application">psql</span>将把游标定位在该函数体的指定行上（注意函数体通常不是开始于文件的第一行）。
        </p><p>
        和大部分其他元命令不同，该行的整个剩余部分总是会被当作<code class="command">\ef</code>的参数，并且在参数中不会执行变量篡改以及反引号展开。
        </p><div class="tip"><h3 class="title">提示</h3><p>
        有关如何配置和自定义编辑器可见<a class="xref" href="app-psql.html#APP-PSQL-ENVIRONMENT" title="环境">环境</a>。
        </p></div></dd><dt><span class="term"><code class="literal">\encoding [ <em class="replaceable"><code>encoding</code></em> ]</code></span></dt><dd><p>
        设置客户端字符集编码。如果没有参数，这个命令会显示当前的编码。
        </p></dd><dt><span class="term"><code class="literal">\errverbose</code></span></dt><dd><p>
        以最详细的程度重复最近的服务器错误消息，就好像<code class="varname">VERBOSITY</code>被设置为<code class="literal">verbose</code>且<code class="varname">SHOW_CONTEXT</code>被设置为<code class="literal">always</code>。
        </p></dd><dt><span class="term"><code class="literal">\ev [<span class="optional"> <em class="replaceable"><code>view_name</code></em> [<span class="optional">  <em class="replaceable"><code>line_number</code></em> </span>] </span>] </code></span></dt><dd><p>
         这个命令会以一个<code class="command">CREATE OR REPLACE VIEW</code>的形式取出并且编辑指定函数的定义。编辑的方式与<code class="literal">\edit</code>完全相同。在编辑器退出后，更新过的命令将在查询缓冲区中等待，可以键入分号或者<code class="literal">\g</code>把它发出，也可以用<code class="literal">\r</code>取消之。
        </p><p>
         如果没有指定函数，将会给出一个空白的<code class="command">CREATE VIEW</code>模板来编辑。
        </p><p>
         如果指定了一个行号，<span class="application">psql</span>将把游标定位在该视图定义的指定行上。
        </p><p>
        和大部分其他元命令不同，该行的整个剩余部分总是会被当作<code class="command">\ev</code>的参数，并且在参数中不会执行变量篡改以及反引号展开。
        </p></dd><dt><span class="term"><code class="literal">\f [ <em class="replaceable"><code>string</code></em> ]</code></span></dt><dd><p>
        设置用于非对齐查询输出的域分隔符。默认值是竖线（<code class="literal">|</code>）。它等效于<code class="command">\pset fieldsep</code>。
        </p></dd><dt><span class="term"><code class="literal">\g [ <em class="replaceable"><code>filename</code></em> ]</code><br /></span><span class="term"><code class="literal">\g [ |<em class="replaceable"><code>command</code></em> ]</code></span></dt><dd><p>
        把当前查询缓冲区发送给服务器执行。如果给出一个参数，查询的输出将被写到提到的文件或者用管道导向给定的shell命令，而不是按照惯常显示出来。只有该查询成功地返回零或更多个元组时才会写文件或命令，如果查询失败或者不是一个数据返回SQL命令，则不会写文件或者导向shell命令。
        </p><p>
        如果当前查询缓冲区为空，则重新执行最近一次被发送的查询。除了这种行为之外，没有参数的<code class="literal">\g</code>实际上等效于一个分号。一个带有参数的<code class="literal">\g</code>是<code class="command">\o</code>命令的一种<span class="quote">“<span class="quote">一次性</span>”</span>选择。
        </p><p>
        如果该参数以<code class="literal">|</code>开始，则该行的所有剩余部分总是会被当做要执行的<em class="replaceable"><code>command</code></em>，并且在参数中不会执行变量篡改以及反引号展开。该行的剩余部分会被简单地按字面传给shell。
        </p></dd><dt><span class="term"><code class="literal">\gdesc</code></span></dt><dd><p>
         显示当前查询缓冲区的结果的描述（即列名和数据类型）。查询不会被实际执行，不过，如果它含有某种类型的语法错误，该错误将被以通常的方式报出。
        </p><p>
         如果当前查询缓冲区为空，则会描述最近被发送的查询。
        </p></dd><dt><span class="term"><code class="literal">\gexec</code></span></dt><dd><p>
         把当前查询缓冲区发送到服务器，然后该查询输出（如果有）中的每一行的每一列都当作一个要被执行的 SQL 语句。例如，要在<code class="structname">my_table</code>的每一列上都创建一个索引：
</p><pre class="programlisting">
=&gt; <strong class="userinput"><code>SELECT format('create index on my_table(%I)', attname)</code></strong>
-&gt; <strong class="userinput"><code>FROM pg_attribute</code></strong>
-&gt; <strong class="userinput"><code>WHERE attrelid = 'my_table'::regclass AND attnum &gt; 0</code></strong>
-&gt; <strong class="userinput"><code>ORDER BY attnum</code></strong>
-&gt; <strong class="userinput"><code>\gexec</code></strong>
CREATE INDEX
CREATE INDEX
CREATE INDEX
CREATE INDEX
</pre><p>
        </p><p>
         产生的查询会按照其所在行被返回的顺序执行，如果有多个列，则同一行中按照从左至右的顺序执行。NULL 域会被忽略。产生的查询会被原样发送给服务器处理，因此它们即不能是<span class="application">psql</span>元命令，也不能包含<span class="application">psql</span>变量引用。如果其中任何一个查询失败，剩余查询的执行将会继续，除非设置了<code class="varname">ON_ERROR_STOP</code>。每个查询的执行都遵照<code class="varname">ECHO</code>的处理（在使用<code class="command">\gexec</code>时，通常建议设置<code class="varname">ECHO</code>为<code class="literal">all</code>或者<code class="literal">queries</code>）。查询日志、单步模式、计时以及其他查询执行特性也适用于每一个生成的查询。
        </p><p>
         如果当前查询缓冲区为空，则会重新执行最近被发送的查询。
        </p></dd><dt><span class="term"><code class="literal">\gset [ <em class="replaceable"><code>prefix</code></em> ]</code></span></dt><dd><p>
         把当前查询输入缓冲区发送给服务器并且将查询的输出存储在<span class="application">psql</span>变量中（见<a class="xref" href="app-psql.html#APP-PSQL-VARIABLES" title="变量">变量</a>）。被执行的查询必须只返回一行。该行的每一列会被存储到一个单独的变量中，变量和该列的名字一样。例如：
</p><pre class="programlisting">
=&gt; <strong class="userinput"><code>SELECT 'hello' AS var1, 10 AS var2</code></strong>
-&gt; <strong class="userinput"><code>\gset</code></strong>
=&gt; <strong class="userinput"><code>\echo :var1 :var2</code></strong>
hello 10
</pre><p>
        </p><p>
         如果指定了一个<em class="replaceable"><code>prefix</code></em>，那么该字符串会被追加在该查询的输出列名称之前用来创建要使用的变量名：
</p><pre class="programlisting">
=&gt; <strong class="userinput"><code>SELECT 'hello' AS var1, 10 AS var2</code></strong>
-&gt; <strong class="userinput"><code>\gset result_</code></strong>
=&gt; <strong class="userinput"><code>\echo :result_var1 :result_var2</code></strong>
hello 10
</pre><p>
        </p><p>
         如果一个列的结果为 NULL，那么对应的变量会被重置而不是被设置。
        </p><p>
         如果查询失败或者没有返回一行，则不会有任何变量被更改。
        </p><p>
         如果当前查询缓冲区为空，则重新执行最近被发送的查询。
        </p></dd><dt><span class="term"><code class="literal">\gx [ <em class="replaceable"><code>filename</code></em> ]</code><br /></span><span class="term"><code class="literal">\gx [ |<em class="replaceable"><code>command</code></em> ]</code></span></dt><dd><p>
        <code class="literal">\gx</code>等效于<code class="literal">\g</code>，但会为这个查询强制扩展的输出模式。请参考<code class="literal">\x</code>。
        </p></dd><dt><span class="term"><code class="literal">\h</code> or <code class="literal">\help</code> <code class="literal">[ <em class="replaceable"><code>command</code></em> ]</code></span></dt><dd><p>
        给出指定<acronym class="acronym">SQL</acronym>命令的语法帮助。如果没有指定<em class="replaceable"><code>command</code></em>，则<span class="application">psql</span>会列出可以显示语法帮助的所有命令。如果<em class="replaceable"><code>command</code></em>是一个星号（<code class="literal">*</code>），则会显示所有<acronym class="acronym">SQL</acronym>命令的语法帮助。
        </p><p>
        与大部分其他元命令不同，该行的所有剩余部分总是会被当做<code class="command">\help</code>的参数，并且在参数中不会执行变量篡改以及反引号展开。
        </p><div class="note"><h3 class="title">注意</h3><p>
        为了简化输入，由几个词构成的命令不需要被加上引号。因此，键入<strong class="userinput"><code>\help alter table</code></strong>是可以的。
        </p></div></dd><dt><span class="term"><code class="literal">\H</code> or <code class="literal">\html</code></span></dt><dd><p>
        开启<acronym class="acronym">HTML</acronym>查询输出格式。如果<acronym class="acronym">HTML</acronym>格式已经开启，这会把它切换回默认的对齐文本格式。这个命令是为了兼容性和方便，有关设置其他输出选项请见<code class="command">\pset</code>。
        </p></dd><dt><span class="term"><code class="literal">\i</code> or <code class="literal">\include</code> <em class="replaceable"><code>filename</code></em></span></dt><dd><p>
        从文件<em class="replaceable"><code>filename</code></em>读取输入并且把它当作从键盘输入的命令来执行。
        </p><p>
        如果<em class="replaceable"><code>filename</code></em>是<code class="literal">-</code>（连字符），那么会一直读取标准输入直到碰到一个 EOF 指示符或者<code class="command">\q</code>元命令。这可以用来把交互式输入与文件输入混杂。注意只有在最外层激活了 readline 行为的情况下才将会使用 readline 行为。
        </p><div class="note"><h3 class="title">注意</h3><p>
        如果想在屏幕上看到被读入的行，必须把变量<code class="varname">ECHO</code>设置成<code class="literal">all</code>。
        </p></div></dd><dt id="PSQL-METACOMMAND-IF"><span class="term"><code class="literal">\if</code> <em class="replaceable"><code>expression</code></em><br /></span><span class="term"><code class="literal">\elif</code> <em class="replaceable"><code>expression</code></em><br /></span><span class="term"><code class="literal">\else</code><br /></span><span class="term"><code class="literal">\endif</code></span></dt><dd><p>
        这一组命令实现可嵌套的条件块。条件块必须以一个<code class="command">\if</code>开始并且以一个<code class="command">\endif</code>结束。两者之间可能有任意数量的<code class="command">\elif</code>子句，后面也可能有选择地跟着一个单一的<code class="command">\else</code>子句。一般查询以及其他类型的反斜线命令可以出现在这些命令之间构成条件块。
        </p><p>
        <code class="command">\if</code>和<code class="command">\elif</code>命令读取它们的参数并且将它们作为布尔表达式进行计算。如果表达式得到<code class="literal">真</code>则处理正常继续下去，否则会跳过下面的行直到到达一个匹配的<code class="command">\elif</code>、<code class="command">\else</code>或者<code class="command">\endif</code>。一旦一个<code class="command">\if</code>或者<code class="command">\elif</code>测试成功，同一个块中后面的<code class="command">\elif</code>命令的参数将不会被计算但会被当作为假。跟在一个<code class="command">\else</code>后面的行只有在先前的匹配的<code class="command">\if</code>或<code class="command">\elif</code>成功时才被处理。
        </p><p>
        就像任何其他反斜线命令参数一样，<code class="command">\if</code>或者<code class="command">\elif</code>命令的<em class="replaceable"><code>expression</code></em>参数服从变量篡改以及反引号展开。然后会像一个on/off选项变量的值一样来计算它。因此，对下列项无歧义、大小写无关的匹配都是有效的值：<code class="literal">true</code>、<code class="literal">false</code>、<code class="literal">1</code>、<code class="literal">0</code>、<code class="literal">on</code>、<code class="literal">off</code>、<code class="literal">yes</code>、<code class="literal">no</code>。例如，<code class="literal">t</code>、<code class="literal">T</code>以及<code class="literal">tR</code>都将被认为是<code class="literal">真</code>。
        </p><p>
        无法被正确计算为真或假的表达式将产生一个警告并且被当做假。
        </p><p>
        正在被跳过的行还是会被正常地解析以标识查询和反斜线命令，但是查询不会被发送到服务器，并且非条件（<code class="command">\if</code>、<code class="command">\elif</code>、<code class="command">\else</code>、<code class="command">\endif</code>）反斜线命令会被忽略。条件命令会被检查以判断嵌套是否有效。被跳过的行中的变量引用不会被展开，并且也不会执行反引号展开。
        </p><p>
        一个给定条件块中的所有反斜线命令必须出现在相同的源文件中。如果在所有的本地<code class="command">\if</code>块被关闭之前，主输入文件或者一个<code class="command">\include</code>进来的文件上就达到了EOF，则<span class="application">psql</span>将产生一个错误。
        </p><p>
         这里是一个例子：
        </p><pre class="programlisting">
-- 检查数据库中两个单独记录的存在性并且把结果存在单独的psql变量中
SELECT
    EXISTS(SELECT 1 FROM customer WHERE customer_id = 123) as is_customer,
    EXISTS(SELECT 1 FROM employee WHERE employee_id = 456) as is_employee
\gset
\if :is_customer
    SELECT * FROM customer WHERE customer_id = 123;
\elif :is_employee
    \echo 'is not a customer but is an employee'
    SELECT * FROM employee WHERE employee_id = 456;
\else
    \if yes
        \echo 'not a customer or employee'
    \else
        \echo 'this will never print'
    \endif
\endif
</pre></dd><dt><span class="term"><code class="literal">\ir</code> or <code class="literal">\include_relative</code> <em class="replaceable"><code>filename</code></em></span></dt><dd><p>
        <code class="literal">\ir</code>命令类似于<code class="literal">\i</code>，但是以不同的方式处理相对路径文件名。在交互模式中执行时，这两个命令的行为相同。不过，当被从脚本中调用时，<code class="literal">\ir</code>相对于脚本所在的目录而不是根据当前工作目录来解释文件名。
        </p></dd><dt><span class="term"><code class="literal">\l[+]</code> or <code class="literal">\list[+] [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出服务器中的数据库并且显示它们的名称、拥有者、字符集编码以及访问特权。如果指定了<em class="replaceable"><code>pattern</code></em>，则只列出名称匹配该模式的数据库。如果向命令名称追加<code class="literal">+</code>，则还会显示数据库的尺寸、默认表空间以及描述（尺寸信息只对当前用户能连接的数据库可用）。
        </p></dd><dt><span class="term"><code class="literal">\lo_export <em class="replaceable"><code>loid</code></em> <em class="replaceable"><code>filename</code></em></code></span></dt><dd><p>
        从数据库中读取具有<acronym class="acronym">OID</acronym> <em class="replaceable"><code>loid</code></em>的大对象并且将它写入到<em class="replaceable"><code>filename</code></em>。注意这和服务器函数<code class="function">lo_export</code>有微妙的不同，后者会以运行数据库服务器的用户权限来执行并且运行在服务器的文件系统上。
        </p><div class="tip"><h3 class="title">提示</h3><p>
        使用<code class="command">\lo_list</code>可以找出大对象的<acronym class="acronym">OID</acronym>。
        </p></div></dd><dt><span class="term"><code class="literal">\lo_import <em class="replaceable"><code>filename</code></em> [ <em class="replaceable"><code>comment</code></em> ]</code></span></dt><dd><p>
        把该文件存储到<span class="productname">PostgreSQL</span>大对象。可选地，它可以把给定的注释关联到该对象。例如：
</p><pre class="programlisting">
foo=&gt; <strong class="userinput"><code>\lo_import '/home/peter/pictures/photo.xcf' 'a picture of me'</code></strong>
lo_import 152801
</pre><p>
        该响应表示该大对象得到的对象 ID 是 152801，未来可以用这个 ID 来访问这个新创建的大对象。为了便于阅读，推荐总是给每一个对象都关联人类可读的注释。OID 和注释都可以用<code class="command">\lo_list</code>命令查看。
        </p><p>
        注意这个命令和服务器端的<code class="function">lo_import</code>有微妙的不同，因为它以本地文件系统上的本地用户的身份运行，而不是服务器用户和文件系统。
        </p></dd><dt><span class="term"><code class="literal">\lo_list</code></span></dt><dd><p>
        显示当前存储在数据库中的所有<span class="productname">PostgreSQL</span>大对象，同时显示它们的任何注释。
        </p></dd><dt><span class="term"><code class="literal">\lo_unlink <em class="replaceable"><code>loid</code></em></code></span></dt><dd><p>
        从数据库中删除<acronym class="acronym">OID</acronym>为<em class="replaceable"><code>loid</code></em>的大对象。
        </p><div class="tip"><h3 class="title">提示</h3><p>
        使用<code class="command">\lo_list</code>可以找出该大对象的<acronym class="acronym">OID</acronym>。
        </p></div></dd><dt><span class="term"><code class="literal">\o</code> or <code class="literal">\out [ <em class="replaceable"><code>filename</code></em> ]</code><br /></span><span class="term"><code class="literal">\o</code> or <code class="literal">\out [ |<em class="replaceable"><code>command</code></em> ]</code></span></dt><dd><p>
        安排把未来的查询结果保存到文件<em class="replaceable"><code>filename</code></em>中或者用管道导向到 shell 命令<em class="replaceable"><code>command</code></em>。如果没有指定参数，查询输出会被重置到标准输出。
        </p><p>
        如果该参数以<code class="literal">|</code>开始，则该行的所有剩余部分总是会被当做要执行的<em class="replaceable"><code>command</code></em>，并且在参数中不会执行变量篡改以及反引号展开。该行的剩余部分会被简单地按字面传给shell。
        </p><p><span class="quote">“<span class="quote">查询结果</span>”</span>包括从数据库服务器得到的所有表、命令响应和提示，还有查询数据库的各种反斜线命令（如<code class="command">\d</code>）的输出，但不包括错误消息。
        </p><div class="tip"><h3 class="title">提示</h3><p>
        要在查询结果之间混入文本输出，可以使用<code class="command">\qecho</code>。
        </p></div></dd><dt><span class="term"><code class="literal">\p</code> or <code class="literal">\print</code></span></dt><dd><p>
        把当前查询缓冲区打印到标准输出。如果当前查询缓冲区为空，会打印最近被执行的查询。
        </p></dd><dt><span class="term"><code class="literal">\password [ <em class="replaceable"><code>username</code></em> ]</code></span></dt><dd><p>
        更改指定用户（默认情况下是当前用户）的口令。这个命令会提示要求输入新口令、对口令加密然后把加密后的口令作为一个<code class="command">ALTER ROLE</code>命令发送到服务器。这确保新口令不会以明文的形式出现在命令历史、服务器日志或者其他地方。
        </p></dd><dt><span class="term"><code class="literal">\prompt [ <em class="replaceable"><code>text</code></em> ] <em class="replaceable"><code>name</code></em></code></span></dt><dd><p>
         提示用户提供一个文本用于分配给变量<em class="replaceable"><code>name</code></em>。可以指定一个可选的提示字符串<em class="replaceable"><code>text</code></em>（对于多个词组成的提示，把文本包裹在单引号中）。
        </p><p>
         默认情况下，<code class="literal">\prompt</code>使用终端进行输入和输出。不过，如果使用了<code class="option">-f</code>命令行开关，<code class="literal">\prompt</code>会使用标准输入和标准输出。
        </p></dd><dt><span class="term"><code class="literal">\pset [ <em class="replaceable"><code>option</code></em> [ <em class="replaceable"><code>value</code></em> ] ]</code></span></dt><dd><p>
        这个命令设置影响查询结果表输出的选项。<em class="replaceable"><code>option</code></em>表示要设置哪个选项。<em class="replaceable"><code>value</code></em>的语义取决于选中的选项。对于某些选项，如果省略<em class="replaceable"><code>value</code></em>会导致该选项值被切换或者被重置，具体是哪些选项可见特定选项的描述。如果没有上面提到的那种行为，那么省略<em class="replaceable"><code>value</code></em>只会导致当前设置被显示。
        </p><p>
        不带任何参数的<code class="command">\pset</code>显示所有打印选项的当前状态。
        </p><p>
        可调整的打印选项有：
        </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">border</code></span></dt><dd><p>
          <em class="replaceable"><code>value</code></em>必须是一个数字。通常，数字越大，表格就会有更多的边框和线条，但具体要看是哪一种格式。在<acronym class="acronym">HTML</acronym>格式中，这会直接被转换成<code class="literal">border=...</code>属性。在大部分其他格式中，只有值 0（没有边框）、1（内部分隔线）和 2（表格边框）有意义，并且 2 以上的值会被视为与<code class="literal">border = 2</code>相同。<code class="literal">latex</code>和<code class="literal">latex-longtable</code>格式会额外地允许一个值 3 表示在数据行之间增加分隔线。
          </p></dd><dt><span class="term"><code class="literal">columns</code></span></dt><dd><p>
          为<code class="literal">wrapped</code>格式设置目标宽度，还有扩展自动模式中决定输出是否足够多到需要分页器或者切换到垂直显示的宽度限制。零（默认）导致目标宽度由环境变量<code class="envar">COLUMNS</code>所控制，如果没有设置<code class="envar">COLUMNS</code>则使用检测到的屏幕宽度。此外，如果<code class="literal">columns</code>为零则<code class="literal">wrapped</code>格式只影响屏幕输出。如果<code class="literal">columns</code>为非零则文件和管道输出也会被包裹成该宽度。
          </p></dd><dt><span class="term"><code class="literal">csv_fieldsep</code></span></dt><dd><p>
          规定要用于<acronym class="acronym">CSV</acronym>输出格式的字段分隔符。如果分隔符出现在字段的值中，则该字段遵循标准<acronym class="acronym">CSV</acronym>规则在双引号中输出。默认值为逗号。
          </p></dd><dt><span class="term"><code class="literal">expanded</code> (or <code class="literal">x</code>)</span></dt><dd><p>
          如果<em class="replaceable"><code>value</code></em>被指定，它必须是<code class="literal">on</code>或者<code class="literal">off</code>，它们分别会启用或者禁用扩展模式，也可以是<code class="literal">auto</code>。如果<em class="replaceable"><code>value</code></em>被省略，则该命令会在开启和关闭设置之间切换。当扩展模式被启用时，查询结果被显示在两列中，第一列是列名而第二列是列值。如果在通常的<span class="quote">“<span class="quote">水平</span>”</span>模式中数据不适合屏幕，则可以用这种模式。在自动设置中，只要查询输出有多于一列并且比屏幕宽，就会使用扩展模式。否则，将使用常规模式。只有在对齐格式和 wrapped 格式中自动设置才有效。在其他格式中，它的行为总是像扩展模式被关闭一样。
          </p></dd><dt><span class="term"><code class="literal">fieldsep</code></span></dt><dd><p>
          指定在非对齐输出格式中使用的域分隔符。用那种方式，用户可以创建 tab 分隔的输出，这种形式其他程序可能更喜欢。要设置 tab 为域分隔符，可以键入<code class="literal">\pset fieldsep '\t'</code>。默认的域分隔符是<code class="literal">'|'</code>（一个竖线）。
          </p></dd><dt><span class="term"><code class="literal">fieldsep_zero</code></span></dt><dd><p>
          把用在非对齐输出格式中的域分隔符设置为一个零字节。
          </p></dd><dt><span class="term"><code class="literal">footer</code></span></dt><dd><p>
          如果<em class="replaceable"><code>value</code></em>被指定，它必须是<code class="literal">on</code>或者<code class="literal">off</code>，它们分别会启用或者禁用表格页脚（<code class="literal">(<em class="replaceable"><code>n</code></em> rows)</code>计数）的显示。如果<em class="replaceable"><code>value</code></em>被省略，则该命令会切换页脚显示为打开或者关闭。
          </p></dd><dt><span class="term"><code class="literal">format</code></span></dt><dd><p>
          设置输出格式为下列的一种： <code class="literal">aligned</code>,
          <code class="literal">asciidoc</code>,
          <code class="literal">csv</code>,
          <code class="literal">html</code>,
          <code class="literal">latex</code>,
          <code class="literal">latex-longtable</code>, <code class="literal">troff-ms</code>,
          <code class="literal">unaligned</code>, 或 <code class="literal">wrapped</code>。允许唯一的缩写。
          </p><p><code class="literal">aligned</code> 格式是标准,人类可阅读的、良好格式化的文本输出；这是默认值。
          </p><p><code class="literal">unaligned</code>格式把一个数据行的所有列都写在一行上，之间用当前活动的域分隔符分隔。这可用于生成意图由其他程序读取的输出，例如，tab 分隔或者逗号分隔格式。
          但是，如果字段分隔符出现在列的值中，则不专门处理该字符；因此<acronym class="acronym">CSV</acronym>格式可能更适合此类目的。
          </p><p><code class="literal">csv</code> 格式
          <a id="id-1.9.4.18.8.4.10.1.69.2.3.1.8.2.4.2" class="indexterm"></a>
          写入以逗号分隔的列值，应用引号规则描述在<a class="ulink" href="https://tools.ietf.org/html/rfc4180" target="_top">RFC 4180</a>。
          此输出与服务器<code class="command">COPY</code>命令的 CSV 格式兼容。
          除非<code class="literal">tuples_only</code>参数为<code class="literal">on</code>，否则将生成具有列名称的标头行。不打印标题和页脚。
          每行都由系统相关的行尾字符结束，该字符通常是类似 Unix 的系统的单一换行符（<code class="literal">\n</code>）或应用于微软Windows的回车和换行顺序（<code class="literal">\r\n</code>）。
          除了逗号之外的<code class="command">\pset csv_fieldsep</code>字段分隔符，还可以使用<code class="command">\pset csv_fieldsep</code>选择。
          </p><p><code class="literal">wrapped</code>格式和<code class="literal">aligned</code>相似，但是前者会把过宽的数据值分成多个行以便输出能够适合目标行的宽度。目标行的宽度由<code class="literal">columns</code>选项决定。注意<span class="application">psql</span>将不会尝试对列头部标题进行换行，因此如果列头部需要的总宽度超过目标宽度，<code class="literal">wrapped</code>格式的行为就变得和<code class="literal">aligned</code>一样了。
          </p><p>
          The <code class="literal">asciidoc</code>, <code class="literal">html</code>,<code class="literal">latex</code>, <code class="literal">latex-longtable</code>, 
          和<code class="literal">troff-ms</code> 格式分别用相应的标记语言把要输出的表格放在文档中。不过它们的输出并不是完整的文档。
          这在<acronym class="acronym">HTML</acronym>中也许不重要，但是在<span class="application">LaTeX</span>中必须有完整的文档包装器。
          <code class="literal">latex</code> 格式使用 <span class="application">LaTeX</span>的 <code class="literal">tabular</code>环境。
          <code class="literal">latex-longtable</code> 格式需要 <span class="application">LaTeX</span>、<code class="literal">longtable</code> 和 <code class="literal">booktabs</code> 包。
          </p></dd><dt><span class="term"><code class="literal">linestyle</code></span></dt><dd><p>
          设置边框线的绘制样式为<code class="literal">ascii</code>、<code class="literal">old-ascii</code>或者<code class="literal">unicode</code>之一。允许不产生歧义的缩写（这意味着一个字母就足够了）。默认的设置是<code class="literal">ascii</code>。这个选项只影响<code class="literal">aligned</code>以及<code class="literal">wrapped</code>输出格式。
          </p><p><code class="literal">ascii</code>样式使用纯<acronym class="acronym">ASCII</acronym>字符。数据中的新行使用一个<code class="literal">+</code>符号在右手边的空白处显示。当在<code class="literal">wrapped</code>格式中包裹两行中间没有新行字符的数据时，会在第一行右手边空白处显示一个点号（<code class="literal">.</code>），并且在下一行的左手边空白处也显示一个点号（<code class="literal">.</code>）。
          </p><p><code class="literal">old-ascii</code>样式使用纯<acronym class="acronym">ASCII</acronym>字符，使用<span class="productname">PostgreSQL</span> 8.4 及更早版本中用过的格式化样式。数据中的新行使用<code class="literal">:</code>符号来代替左手边的列分隔符显示。在包裹两行中间没有新行字符的数据时，会用一个<code class="literal">;</code>符号取代左手边的列分隔符。
          </p><p><code class="literal">unicode</code>样式使用 Unicode 的方框绘制字符。数据中的新行会使用一个回车符号显示在右手边的空白处。在包裹两行中间没有新行字符的数据时，会在第一行的右手边空白处显示一个省略号，并且在下一行的左手边空白处也显示一个省略号。
          </p><p>
          当<code class="literal">border</code>设置大于零时，<code class="literal">linestyle</code>选项也决定边框线用什么字符绘制。纯<acronym class="acronym">ASCII</acronym>字符到处都可以使用，但是在识别 Unicode 字符的显示上使用 Unicode 字符会更好看。
          </p></dd><dt><span class="term"><code class="literal">null</code></span></dt><dd><p>
          设置要用来替代空值被打印的字符串。默认是什么也不打印，对于一个空字符串这很容易弄错。例如，有人可能更想用<code class="literal">\pset null '(null)'</code>。
          </p></dd><dt><span class="term"><code class="literal">numericlocale</code></span></dt><dd><p>
          如果<em class="replaceable"><code>value</code></em>被指定，它必须是<code class="literal">on</code>或者<code class="literal">off</code>，它们将分别启用或者禁用一个与区域相关的字符来分隔数字和左边的十进制标记。如果<em class="replaceable"><code>value</code></em>被省略，该命令会在常规输出和区域相关的数字输出之间切换。
          </p></dd><dt><span class="term"><code class="literal">pager</code></span></dt><dd><p>
          控制对查询和<span class="application">psql</span>的帮助输出使用分页器程序。如果环境变量<code class="envar">PSQL_PAGER</code>或<code class="envar">PAGER</code>被设置，输出会被用管道输送到指定的程序。否则将使用与平台相关的默认分页器程序（例如<code class="filename">more</code>）。
          </p><p>
          如果<code class="literal">pager</code>选项被设为<code class="literal">off</code>，则不会使用分页器程序。如果<code class="literal">pager</code>选项被设为<code class="literal">on</code>，则会在适当的时候使用分页器，即当输出到终端并且无法适合屏幕时就会使用分页器。<code class="literal">pager</code>选项也可以被设置为<code class="literal">always</code>，这会导致对所有的终端输出都是用分页器而不管输出是否适合屏幕。不带<em class="replaceable"><code>value</code></em>的<code class="literal">\pset pager</code>会切换分页器开、关状态。
          </p></dd><dt><span class="term"><code class="literal">pager_min_lines</code></span></dt><dd><p>
          如果<code class="literal">pager_min_lines</code>被设置为一个大于页面高度的数字，在至少这么多输出行被显示之前都不会调用分页器程序。默认设置为 0。
          </p></dd><dt><span class="term"><code class="literal">recordsep</code></span></dt><dd><p>
          指定用在非对齐输出格式中的记录（行）分隔符。
          </p></dd><dt><span class="term"><code class="literal">recordsep_zero</code></span></dt><dd><p>
          把用在非对齐输出格式中的记录分隔符设置为一个零字节。
          </p></dd><dt><span class="term"><code class="literal">tableattr</code> (or <code class="literal">T</code>)</span></dt><dd><p>
          在<acronym class="acronym">HTML</acronym>格式中，这会指定要放在<code class="sgmltag-element">table</code>标记内的属性。例如，这可能是<code class="literal">cellpadding</code>或者<code class="literal">bgcolor</code>。注意你可能不想在这里指定<code class="literal">border</code>，因为那由<code class="literal">\pset border</code>负责。如果没有给出<em class="replaceable"><code>value</code></em>，则表属性会被重置。
          </p><p>
          在<code class="literal">latex-longtable</code>格式中，这个选项控制每个包含左对齐数据类型的列的宽度比例。这个选项的值是一个由空格分隔的值列表，例如<code class="literal">'0.2 0.2 0.6'</code>。没有指定的输出列会使用最后一个指定的值。
          </p></dd><dt><span class="term"><code class="literal">title</code> (or <code class="literal">C</code>)</span></dt><dd><p>
          设置用于任何后续被打印表的表标题。这可以用来给输出加上描述性的标签。如果没有给出<em class="replaceable"><code>value</code></em>，这个标题会被复原。
          </p></dd><dt><span class="term"><code class="literal">tuples_only</code> (or <code class="literal">t</code>)</span></dt><dd><p>
          如果<em class="replaceable"><code>value</code></em>被指定，它必须是<code class="literal">on</code>或者<code class="literal">off</code>，这个选项将启用或者禁用只显示元组的模式。如果<em class="replaceable"><code>value</code></em>被省略，则该命令会在常规输出和只显示元组输出之间切换。常规输出包括列头、标题以及多种页脚之类的额外信息。在只显示元组的模式中，只会显示实际的表数据。
          </p></dd><dt><span class="term"><code class="literal">unicode_border_linestyle</code></span></dt><dd><p>
          设置<code class="literal">unicode</code>线型的边框绘制风格为<code class="literal">single</code>或者<code class="literal">double</code>之一。
          </p></dd><dt><span class="term"><code class="literal">unicode_column_linestyle</code></span></dt><dd><p>
          设置<code class="literal">unicode</code>线型的列绘制风格为<code class="literal">single</code>或者<code class="literal">double</code>之一。
          </p></dd><dt><span class="term"><code class="literal">unicode_header_linestyle</code></span></dt><dd><p>
          设置<code class="literal">unicode</code>线型的页眉绘制风格为<code class="literal">single</code>或者<code class="literal">double</code>之一。
          </p></dd></dl></div><p>
        </p><p>
        这些不同格式的外观可以在<a class="xref" href="app-psql.html#APP-PSQL-EXAMPLES" title="示例">示例</a>小节的图示中看到。
        </p><div class="tip"><h3 class="title">提示</h3><p>
        <code class="command">\pset</code>有多种快捷命令。请参见<code class="command">\a</code>、<code class="command">\C</code>、<code class="command">\f</code>、<code class="command">\H</code>、<code class="command">\t</code>、<code class="command">\T</code>以及<code class="command">\x</code>。
        </p></div></dd><dt><span class="term"><code class="literal">\q</code> or <code class="literal">\quit</code></span></dt><dd><p>
        退出<span class="application">psql</span>程序。在一个脚本文件中，只有该脚本的执行会被终止。
        </p></dd><dt><span class="term"><code class="literal">\qecho <em class="replaceable"><code>text</code></em> [ ... ] </code></span></dt><dd><p>
        这个命令和<code class="command">\echo</code>一样，不过输出将被写到<code class="command">\o</code>所设置的查询输出通道。
        </p></dd><dt><span class="term"><code class="literal">\r</code> or <code class="literal">\reset</code></span></dt><dd><p>
        重置（清除）查询缓冲区。
        </p></dd><dt><span class="term"><code class="literal">\s [ <em class="replaceable"><code>filename</code></em> ]</code></span></dt><dd><p>
        打印<span class="application">psql</span>的命令行历史到<em class="replaceable"><code>filename</code></em>。如果省略<em class="replaceable"><code>filename</code></em>，该历史会被写入到标准输出（如果适用则使用分页器）。如果编译<span class="application">psql</span>时没有加上<span class="application">Readline</span>支持，则这个命令不可用。
        </p></dd><dt><span class="term"><code class="literal">\set [ <em class="replaceable"><code>name</code></em> [ <em class="replaceable"><code>value</code></em> [ ... ] ] ]</code></span></dt><dd><p>
        设置<span class="application">psql</span>变量<em class="replaceable"><code>name</code></em>为<em class="replaceable"><code>value</code></em>，如果给出了多于一个值，则把该变量的值设置为所有给出的值的串接。如果只给了一个参数，该变量会被设置为空字符串值。要重置一个变量，可以使用<code class="command">\unset</code> 命令。
        </p><p>不带任何参数的<code class="command">\set</code>显示所有当前设置的<span class="application">psql</span>变量的名称和值。
        </p><p>
        合法的变量名可以包含字母、数字和下划线。详见下文的<a class="xref" href="app-psql.html#APP-PSQL-VARIABLES" title="变量">变量</a>。变量名是大小写敏感的。
        </p><p>
        某些变量是特殊的，它们控制<span class="application">psql</span>的行为或者会被自动设置以反映连接状态。这些变量在下文的<a class="xref" href="app-psql.html#APP-PSQL-VARIABLES" title="变量">变量</a>中记录。
        </p><div class="note"><h3 class="title">注意</h3><p>
        这个命令和<acronym class="acronym">SQL</acronym>命令<a class="xref" href="sql-set.html" title="SET"><span class="refentrytitle">SET</span></a>无关。
        </p></div></dd><dt><span class="term"><code class="literal">\setenv <em class="replaceable"><code>name</code></em> [ <em class="replaceable"><code>value</code></em> ]</code></span></dt><dd><p>
        把环境变量<em class="replaceable"><code>name</code></em>设置为<em class="replaceable"><code>value</code></em>，如果没有提供<em class="replaceable"><code>value</code></em>，则会重置该环境变量。例如：
</p><pre class="programlisting">
testdb=&gt; <strong class="userinput"><code>\setenv PAGER less</code></strong>
testdb=&gt; <strong class="userinput"><code>\setenv LESS -imx4F</code></strong>
</pre></dd><dt><span class="term"><code class="literal">\sf[+] <em class="replaceable"><code>function_description</code></em> </code></span></dt><dd><p>
         这个命令以一个<code class="command">CREATE OR REPLACE FUNCTION</code>命令或者<code class="command">CREATE OR REPLACE PROCEDURE</code>命令取出并且显示指定函数或者过程的定义。定义会被打印到当前的查询输出渠道，就像<code class="command">\o</code>所作的那样。
        </p><p>
         目标函数可以单独用名称指定，也可以用名称和参数指定，例如<code class="literal">foo(integer, text)</code>。如果有多于一个函数具有相同的名字，则必须给出参数的类型。
        </p><p>
         如果向命令名称追加<code class="literal">+</code>，那么输出行会被编号，函数体的第一行会被编为 1。
        </p><p>
        与大部分其他元命令不同，该行的所有剩余部分总是会被当做<code class="command">\sf</code>的参数，并且在参数中不会执行变量篡改以及反引号展开。
        </p></dd><dt><span class="term"><code class="literal">\sv[+] <em class="replaceable"><code>view_name</code></em> </code></span></dt><dd><p>
          这个命令以一个<code class="command">CREATE OR REPLACE VIEW</code>命令取出并且显示指定视图的定义。定义会被打印到当前的查询输出渠道，就像<code class="command">\o</code>所作的那样。
         </p><p>
          如果在命令名称上追加<code class="literal">+</code>，那么输出行会从 1 开始编号。
         </p><p>
        与大部分其他元命令不同，该行的所有剩余部分总是会被当做<code class="command">\sv</code>的参数，并且在参数中不会执行变量篡改以及反引号展开。
        </p></dd><dt><span class="term"><code class="literal">\t</code></span></dt><dd><p>
        切换输出列名标题和行计数页脚的显示。这个命令等效于<code class="literal">\pset tuples_only</code>，提供它只是为了使用方便而已。
        </p></dd><dt><span class="term"><code class="literal">\T <em class="replaceable"><code>table_options</code></em></code></span></dt><dd><p>
        指定在<acronym class="acronym">HTML</acronym>输出格式中，要放在<code class="sgmltag-element">table</code>标签内的属性。这个命令等效于<code class="literal">\pset tableattr <em class="replaceable"><code>table_options</code></em></code>。
        </p></dd><dt><span class="term"><code class="literal">\timing [ <em class="replaceable"><code>on</code></em> | <em class="replaceable"><code>off</code></em> ]</code></span></dt><dd><p>
         如果给出一个参数，这个参数用来打开或者关闭对每个SQL语句执行时长的显示。如果没有参数，则在打开和关闭之间切换。显示的数据以毫秒为单位，超过1秒的区间还会被显示为“分钟:秒”的格式，如果必要还会加上小时和日的字段。
        </p></dd><dt><span class="term"><code class="literal">\unset <em class="replaceable"><code>name</code></em></code></span></dt><dd><p>
        重置（删除）<span class="application">psql</span>变量<em class="replaceable"><code>name</code></em>。
        </p><p>
        大部分控制<span class="application">psql</span>行为的变量不能被重置，相反，<code class="literal">\unset</code>命令会被解释为把它们设置为其默认值。请参考下文的<a class="xref" href="app-psql.html#APP-PSQL-VARIABLES" title="变量">变量</a>。
        </p></dd><dt><span class="term"><code class="literal">\w</code> or <code class="literal">\write</code> <em class="replaceable"><code>filename</code></em><br /></span><span class="term"><code class="literal">\w</code> or <code class="literal">\write</code> <code class="literal">|</code><em class="replaceable"><code>command</code></em></span></dt><dd><p>
        把当前查询缓冲区写到文件<em class="replaceable"><code>filename</code></em>或者用管道导出到 shell 命令<em class="replaceable"><code>command</code></em>。如果当前查询缓冲区为空，则写最近被执行的查询。
        </p><p>
        如果参数以<code class="literal">|</code>开始，则该行的整个剩余部分会被当做要执行的<em class="replaceable"><code>command</code></em>，并且在参数中不会执行变量篡改以及反引号展开。该行的剩余部分会被简单地按字面传递给shell。
        </p></dd><dt><span class="term"><code class="literal">\watch [ <em class="replaceable"><code>seconds</code></em> ]</code></span></dt><dd><p>
        反复执行当前的查询缓冲区（就像<code class="literal">\g</code>那样）直到被中止或者查询失败。两次执行之间等待指定的秒数（默认是 2 秒）。显示每个查询结果时带上一个由<code class="literal">\pset title</code>字符串（如果有）、从查询开始起的时间以及延时间隔组成的页眉。
        </p><p>
        如果当前查询缓冲区为空，则会重新执行最近被发送的查询。
        </p></dd><dt><span class="term"><code class="literal">\x [ <em class="replaceable"><code>on</code></em> | <em class="replaceable"><code>off</code></em> | <em class="replaceable"><code>auto</code></em> ]</code></span></dt><dd><p>
        设置或者切换扩展表格格式化模式。究其本身而言，这个命令等效于<code class="literal">\pset expanded</code>。
       </p></dd><dt><span class="term"><code class="literal">\z [ <a class="link" href="app-psql.html#APP-PSQL-PATTERNS" title="模式（Pattern）"><em class="replaceable"><code>pattern</code></em></a> ]</code></span></dt><dd><p>
        列出表、视图和序列，以及它们相关的访问特权。如果指定了<em class="replaceable"><code>pattern</code></em>，则只会列出名称匹配该模式的表、视图和序列。
        </p><p>
        这是<code class="command">\dp</code>（<span class="quote">“<span class="quote">display privileges</span>”</span>）的一个别名。
        </p></dd><dt><span class="term"><code class="literal">\! [ <em class="replaceable"><code>command</code></em> ]</code></span></dt><dd><p>
        如果没有参数，就跳出到一个子shell，当子shell退出时<span class="application">psql</span>会继续。如果有一个参数，则执行shell命令<em class="replaceable"><code>command</code></em>。
        </p><p>
        与大部分其他元命令不同，该行的所有剩余部分总是会被当做<code class="command">\!</code>的参数，并且在参数中不会执行变量篡改以及反引号展开。该行的剩余部分会被简单地按字面传递给shell。
        </p></dd><dt><span class="term"><code class="literal">\? [ <em class="replaceable"><code>topic</code></em> ]</code></span></dt><dd><p>
        显示帮助信息。可选的<em class="replaceable"><code>topic</code></em>参数（默认是<code class="literal">commands</code>）选择解释<span class="application">psql</span>的哪一部分：<code class="literal">commands</code>表示<span class="application">psql</span>的反斜线命令；<code class="literal">options</code>表示可以传递给<span class="application">psql</span>的命令行选项；而<code class="literal">variables</code>显示有关<span class="application">psql</span>配置变量的帮助。
        </p></dd><dt><span class="term"><code class="literal">\;</code></span></dt><dd><p>
        反斜线分号并非和前述命令相同的元命令，它只是会把一个分号加入到查询缓冲区且不会进一步执行。
        </p><p>
        通常，只要<span class="application">psql</span>达到了命令结束的分号，它就将分发一个SQL命令给服务器，即使在当前行上还留有更多输入。因此，例如输入
</p><pre class="programlisting">
select 1; select 2; select 3;
</pre><p>
        将导致三个SQL命令被逐个发送给服务器，在继续到下一个命令前会显示每一个命令的结果。不过，被输入为<code class="literal">\;</code>的分号将不会触发命令处理，这样在它之前的命令以及其后的命令实际上会被组合在一个请求中发送给服务器。例如
</p><pre class="programlisting">
select 1\; select 2\; select 3;
</pre><p>
        会导致在到达非反斜线分号时用一个单一的请求把三个SQL命令发送给服务器。服务器会把这样一个请求当作单一的事务执行，除非该字符串中有显式的<code class="command">BEGIN</code>/<code class="command">COMMIT</code>命令把它划分成多个事务（服务器如何处理多查询字符串的更多细节请参考<a class="xref" href="protocol-flow.html#PROTOCOL-FLOW-MULTI-STATEMENT" title="52.2.2.1. 一个简单查询中的多条语句">第 52.2.2.1 节</a>）。<span class="application">psql</span>对每个请求仅打印出它接收到的最后一个查询结果。在这个例子中，尽管所有三个<code class="command">SELECT</code>确实都被执行了，但<span class="application">psql</span>只会打印出<code class="literal">3</code>。
        </p></dd></dl></div><p>
  </p><div class="refsect3" id="APP-PSQL-PATTERNS"><h4>模式（Pattern）</h4><a id="id-1.9.4.18.8.4.11.2" class="indexterm"></a><p>
   很多<code class="literal">\d</code>命令都可以用一个<em class="replaceable"><code>pattern</code></em>参数来指定要被显示的对象名称。在最简单的情况下，模式正好就是该对象的准确名称。在模式中的字符通常会被变成小写形式（就像在 SQL 名称中那样），例如<code class="literal">\dt FOO</code>将会显示名为<code class="literal">foo</code>的表。就像在 SQL 名称中那样，把模式放在双引号中可以阻止它被转换成小写形式。如果需要在一个模式中包括一个真正的双引号字符，则需要把它写成两个相邻的双引号，这同样是符合 SQL 引用标识符的规则。例如，<code class="literal">\dt "FOO""BAR"</code>将显示名为<code class="literal">FOO"BAR</code>（不是<code class="literal">foo"bar</code>）的表。和普通的 SQL 名称规则不同，你不能只在模式的一部分周围放上双引号，例如<code class="literal">\dt FOO"FOO"BAR</code>将会显示名为<code class="literal">fooFOObar</code>的表。
  </p><p>
   只要<em class="replaceable"><code>pattern</code></em>参数被完全省略，<code class="literal">\d</code>命令会显示在当前 schema 搜索路径中可见的全部对象 — 这等价于用<code class="literal">*</code>作为模式（如果一个对象所在的 schema 位于搜索路径中并且没有同类且同名的对象出现在搜索路径中该 schema 之前的 schema 中，则说该对象是<em class="firstterm">可见</em>的。这表示可以直接用名称引用该对象，而不需要用 schema 来进行限定）。要查看数据库中所有的对象而不管它们的可见性，可以把<code class="literal">*.*</code>用作模式。
  </p><p>
   如果放在一个模式中，<code class="literal">*</code>将匹配任意字符序列（包括空序列），而<code class="literal">?</code>会匹配任意的单个字符（这种记号方法就像 Unix shell 的文件名模式一样）。例如，<code class="literal">\dt int*</code>会显示名称以<code class="literal">int</code>开始的表。但是如果被放在双引号内，<code class="literal">*</code>和<code class="literal">?</code>就会失去这些特殊含义而变成普通的字符。
  </p><p>
   包含一个点号（<code class="literal">.</code>）的模式被解释为一个 schema 名称模式后面跟上一个对象名称模式。例如，<code class="literal">\dt foo*.*bar*</code>会显示名称以<code class="literal">foo</code>开始的 schema 中所有名称包括<code class="literal">bar</code>的表。如果没有出现点号，那么模式将只匹配当前 schema 搜索路径中可见的对象。同样，双引号内的点号会失去其特殊含义并且变成普通的字符。
  </p><p>
   高级用户可以使用字符类等正则表达式记法，如<code class="literal">[0-9]</code>可以匹配任意数字。所有的正则表达式特殊字符都按照<a class="xref" href="functions-matching.html#FUNCTIONS-POSIX-REGEXP" title="9.7.3. POSIX正则表达式">第 9.7.3 节</a>所说的工作，以下字符除外：<code class="literal">.</code>会按照上面所说的作为一种分隔符，<code class="literal">*</code>会被翻译成正则表达式记号<code class="literal">.*</code>，<code class="literal">?</code>会被翻译成<code class="literal">.</code>，而<code class="literal">$</code>则按字面意思匹配。根据需要，可以通过书写<code class="literal">?</code>、<code class="literal">(<em class="replaceable"><code>R</code></em>+|)</code>、<code class="literal">(<em class="replaceable"><code>R</code></em>|)</code>和<code class="literal"><em class="replaceable"><code>R</code></em>?</code>来分别模拟模式字符<code class="literal">.</code>、<code class="literal"><em class="replaceable"><code>R</code></em>*</code>和<code class="literal"><em class="replaceable"><code>R</code></em>?</code>。<code class="literal">$</code>不需要作为一个正则表达式字符，因为模式必须匹配整个名称，而不是像正则表达式的常规用法那样解释（换句话说，<code class="literal">$</code>会被自动地追加到模式上）。如果不希望该模式的匹配位置被固定，可以在开头或者结尾写上<code class="literal">*</code>。注意在双引号内，所有的正则表达式特殊字符会失去其特殊含义并且按照其字面意思进行匹配。还有，在操作符名称模式中（即作为<code class="literal">\do</code>的参数），正则表达式特殊字符也按照字面意思进行匹配。
  </p></div></div><div class="refsect2" id="id-1.9.4.18.8.5"><h3>高级特性</h3><div class="refsect3" id="APP-PSQL-VARIABLES"><h4>变量</h4><p>
    <span class="application">psql</span>提供了和普通 Unix 命令 shell 相似的变量替换特性。变量简单来说就是一对名称/值，其中值可以是任意长度的任意字符串。名称必须由字母（包括非拉丁字母）、数字和下划线构成。
    </p><p>
    要设置一个变量，可以使用<span class="application">psql</span>的元命令<code class="command">\set</code>。例如，
</p><pre class="programlisting">
testdb=&gt; <strong class="userinput"><code>\set foo bar</code></strong>
</pre><p>
    会设置<code class="literal">foo</code>为值<code class="literal">bar</code>。要检索该变量的内容，可以在名称前放一个分号，例如：
</p><pre class="programlisting">
testdb=&gt; <strong class="userinput"><code>\echo :foo</code></strong>
bar
</pre><p>
    这在常规 SQL 命令和元命令中均有效，下文的<a class="xref" href="app-psql.html#APP-PSQL-INTERPOLATION" title="SQL 中插入变量"><acronym class="acronym">SQL</acronym> 中插入变量</a>中有更多细节。
    </p><p>
    如果调用<code class="command">\set</code>时没有第二个参数，该变量会被设置为一个空字符串值。要重置（即删除）一个变量，可以使用命令<code class="command">\unset</code>。要显示所有变量的值，在调用<code class="command">\set</code>时不带任何参数即可。
    </p><div class="note"><h3 class="title">注意</h3><p>
    <code class="command">\set</code>的参数服从与其他命令相同的替换规则。因此可以构造有趣的引用，例如<code class="literal">\set :foo 'something'</code>以及分别得到<span class="productname">Perl</span>或者<span class="productname"><acronym class="acronym">PHP</acronym></span>的<span class="quote">“<span class="quote">软链接</span>”</span>或者<span class="quote">“<span class="quote">可变变量</span>”</span>。不幸的是（或者幸运的是？），这些构造出来的东西并没有什么用处。在另一方面，<code class="literal">\set bar :foo</code>是一种很好的拷贝变量的方法。
    </p></div><p>
    有一些变量会被<span class="application">psql</span>特殊对待。它们表示特定的选项设置，运行时这类选项设置可以通过修改该变量的值来改变，或者在某些情况下它们表示<span class="application">psql</span>的可更改的状态。按照惯例，所有被特殊对待的变量的名称由全部大写形式的 ASCII 字母（还有可能是数字和下划线）组成。为了确保未来最大的兼容性，最好避免把这类变量名用于自己的目的。
   </p><p>
    控制<span class="application">psql</span>行为的变量通常不能被重置或者设置为无效值。允许<code class="literal">\unset</code>命令，但它会被解释为将变量设置为它的默认值。没有第二参数的<code class="literal">\set</code>命令会被解释为将变量设置为<code class="literal">on</code>（对于接受该值的控制变量），对不接受该值的变量则会拒绝这个命令。此外，接受值<code class="literal">on</code>和<code class="literal">off</code>的控制变量也能接受其他常见的布尔值拼写方式，例如<code class="literal">true</code>和<code class="literal">false</code>。
   </p><p>
    被特殊对待的变量是：
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
       <code class="varname">AUTOCOMMIT</code>
       <a id="id-1.9.4.18.8.5.2.9.1.1.2" class="indexterm"></a>
      </span></dt><dd><p>
        在被设置为<code class="literal">on</code>（默认）时，每一个 SQL 命令在成功完成时会被自动提交。在这种模式中要推迟提交，必须输入一个<code class="command">BEGIN</code>或者<code class="command">START TRANSACTION</code> SQL 命令。当被设置为<code class="literal">off</code>或者被重置时，在显式发出<code class="command">COMMIT</code>或者<code class="command">END</code>之前，SQL 命令不会被提交。自动提交打开模式会为你发出一个隐式的<code class="command">BEGIN</code>，这会发生在任何不在一个事务块中且本身即不是<code class="command">BEGIN</code>及其他事务控制命令且不是无法在事务块中执行的命令（例如<code class="command">VACUUM</code>）之前。
        </p><div class="note"><h3 class="title">注意</h3><p>
         在自动提交关闭模式中，必须通过<code class="command">ABORT</code>或者<code class="command">ROLLBACK</code>显式地放弃任何失败的事务。还要记住，如果退出会话时没有提交，则所有的工作都会丢失。
        </p></div><div class="note"><h3 class="title">注意</h3><p>
         自动提交打开模式是<span class="productname">PostgreSQL</span>的传统行为，但是自动提交关闭模式更接近于 SQL 的规范。如果更喜欢自动提交关闭模式，可以在系统级的<code class="filename">psqlrc</code>文件或者个人的<code class="filename">~/.psqlrc</code>文件中设置它。
        </p></div></dd><dt><span class="term"><code class="varname">COMP_KEYWORD_CASE</code></span></dt><dd><p>
        确定在补全一个 SQL 关键词时要使用的大小写形式。如果被设置为<code class="literal">lower</code>或者<code class="literal">upper</code>，补全后的词将分别是小写或者大写形式。如果被设置为<code class="literal">preserve-lower</code>或者<code class="literal">preserve-upper</code>（默认），补全后的词将会保持该词已输入部分的大小写形式，但是如果被补全的词还没有被输入，则它会被分别补全成小写或者大写形式。
        </p></dd><dt><span class="term"><code class="varname">DBNAME</code></span></dt><dd><p>
        当前已连接的数据库名称。每次连接到一个数据库时都会设置该变量（包括程序启动时），但是可以被更改或者重置。
        </p></dd><dt><span class="term"><code class="varname">ECHO</code></span></dt><dd><p>
        如果被设置为<code class="literal">all</code>，所有非空输入行会被按照读入它们的样子打印到标准输出（不适用于交互式读取的行）。要在程序开始时选择这种行为，可以使用开关<code class="option">-a</code>。如果被设置为<code class="literal">queries</code>，<span class="application">psql</span>会在发送每个查询给服务器时将它们打印到标准输出。选择这种行为的开关是<code class="option">-e</code>。如果被设置为<code class="literal">errors</code>，那么只有失败的查询会被显示在标准错误输出上。这种行为的开关是<code class="option">-b</code>。如果被重置或者设置为<code class="literal">none</code>（默认值）则不会显示任何查询。
        </p></dd><dt><span class="term"><code class="varname">ECHO_HIDDEN</code></span></dt><dd><p>
        当这个变量被设置为<code class="literal">on</code>且一个反斜线命令查询数据库时，相应的查询会被先显示。这种特性可以帮助我们学习<span class="productname">PostgreSQL</span>的内部并且在自己的程序中提供类似的功能（要在程序开始时选择这种行为，可以使用开关<code class="option">-E</code>）。如果把这个变量设置为值<code class="literal">noexec</code>，则对应的查询只会被显示而并不真正被发送给服务器执行。默认值是<code class="literal">off</code>。
        </p></dd><dt><span class="term"><code class="varname">ENCODING</code></span></dt><dd><p>
        当前的客户端字符集编码。每一次你连接到一个数据库（包括程序启动）时以及当你用<code class="literal">\encoding</code>更改编码时，这个变量都会被设置，但它可以被更改或者重置。
        </p></dd><dt><span class="term"><code class="varname">ERROR</code></span></dt><dd><p>
         如果上一个SQL查询失败则为<code class="literal">true</code>，如果成功则是<code class="literal">false</code>。另见<code class="varname">SQLSTATE</code>。
        </p></dd><dt><span class="term"><code class="varname">FETCH_COUNT</code></span></dt><dd><p>
        如果这个变量被设置为一个大于零的整数值，<code class="command">SELECT</code>查询的结果会以一组一组的方式取出并且显示（而不是像默认的那样把整个结果集拿到以后再显示），每一组就会包括这么多个行。因此，这种方式只会使用有限的内存量，而不管整个结果集的大小。在启用这个特性时，通常会使用 100 到 1000 的设置。记住在使用这种特性时，一个查询可能会在已经显示了一些行之后失败。
        </p><div class="tip"><h3 class="title">提示</h3><p>
        尽管可以把这种特性用于任何的输出格式，但是默认的<code class="literal">aligned</code>格式看起来会比较糟糕，因为每一组的<code class="varname">FETCH_COUNT</code>个行将被单独格式化，这就会导致不同的行组的列宽不同。其他的输出格式会更好。
        </p></div></dd><dt><span class="term"><code class="varname">HIDE_TABLEAM</code></span></dt><dd><p>
         如果此变量设置为<code class="literal">true</code>，则不显示表的访问方法的详细信息。这主要用于回归测试。
        </p></dd><dt><span class="term"><code class="varname">HISTCONTROL</code></span></dt><dd><p>
         如果这个变量被设置为<code class="literal">ignorespace</code>，则以一个空格开始的行不会被放入到历史列表中。如果被设置为值<code class="literal">ignoredups</code>，则匹配之前的历史行的行不会被放入。值<code class="literal">ignoreboth</code>组合了上述两种值。如果被重置或者被设置为<code class="literal">none</code>（默认值），所有在交互模式中被读入的行都会保存在历史列表中。
        </p><div class="note"><h3 class="title">注意</h3><p>
        这个特性是可耻地从<span class="application">Bash</span>抄袭过来的。
        </p></div></dd><dt><span class="term"><code class="varname">HISTFILE</code></span></dt><dd><p>
        该文件名将被用于存储历史列表。如果被重设，文件名将从<code class="envar">PSQL_HISTORY</code>环境变量中取得。如果该环境变量也没有被设置，则默认值是<code class="filename">~/.psql_history</code>，在Windows上是<code class="filename">%APPDATA%\postgresql\psql_history</code>。例如，
</p><pre class="programlisting">
\set HISTFILE ~/.psql_history- :DBNAME
</pre><p>
        放在<code class="filename">~/.psqlrc</code>中将会导致<span class="application">psql</span>为每一个数据库维护一个单独的历史。
        </p><div class="note"><h3 class="title">注意</h3><p>
        这个特性是可耻地从<span class="application">Bash</span>抄袭过来的。
        </p></div></dd><dt><span class="term"><code class="varname">HISTSIZE</code></span></dt><dd><p>
        存储在命令历史中的最大命令数（默认值是500）。如果被设置为一个负值，则不会应用限制。
        </p><div class="note"><h3 class="title">注意</h3><p>
        这个特性是可耻地从<span class="application">Bash</span>抄袭过来的。
        </p></div></dd><dt><span class="term"><code class="varname">HOST</code></span></dt><dd><p>
        当前连接到的数据库服务器端口。每次连接到一个数据库时都会设置该变量（包括程序启动时），但是可以被更改或者重置。
        </p></dd><dt><span class="term"><code class="varname">IGNOREEOF</code></span></dt><dd><p>
         如果被设置为1或者更小，向一个<span class="application">psql</span>的交互式会话发送一个<acronym class="acronym">EOF</acronym>字符（通常是<span class="keycap"><strong>Control</strong></span>+<span class="keycap"><strong>D</strong></span>）将会终止应用。如果设置为一个较大的数字值，则必须键入多个连续的<acronym class="acronym">EOF</acronym>字符才能让交互式会话终止。如果该变量被设置为一个非数字值，则它会被解释为10。默认值为0。
        </p><div class="note"><h3 class="title">注意</h3><p>
        这个特性是可耻地从<span class="application">Bash</span>抄袭过来的。
        </p></div></dd><dt><span class="term"><code class="varname">LASTOID</code></span></dt><dd><p>
        最后被影响的 OID 的值，这可能会由<code class="command">INSERT</code>或者<code class="command">\lo_import</code>命令返回。这个变量只保证在下一个<acronym class="acronym">SQL</acronym>命令被显示完之前有效。
        <span class="productname"> PostgreSQL</span> 服务器从12版开始不再支持 OID 系统列，因此，在面向此类服务器时，跟随在<code class="command">INSERT</code>后面的 LASTOID 将始终为0。
        </p></dd><dt><span class="term"><code class="varname">LAST_ERROR_MESSAGE</code><br /></span><span class="term"><code class="varname">LAST_ERROR_SQLSTATE</code></span></dt><dd><p>
         当前<span class="application">psql</span>会话中最近一个失败查询的主错误消息和相关的SQLSTATE代码，如果在当前会话中没有发生错误，则是一个空字符串和<code class="literal">00000</code>。
        </p></dd><dt><span class="term">
       <code class="varname">ON_ERROR_ROLLBACK</code>
       <a id="id-1.9.4.18.8.5.2.9.17.1.2" class="indexterm"></a>
      </span></dt><dd><p>
        当被设置为<code class="literal">on</code>时，如果事务块中的一个语句产生一个错误，该错误会被忽略并且该事务会继续。当被设置为<code class="literal">interactive</code>时，只在交互式会话中忽略这类错误，而读取脚本文件时则不会忽略错误。当被重置或者设置为<code class="literal">off</code>（默认值）时，事务块中产生错误的一个语句会中止整个事务。错误回滚模式的工作原理是在事务块的每个命令之前都为你发出一个隐式的<code class="command">SAVEPOINT</code>，然后在该命令失败时回滚到该保存点。
        </p></dd><dt><span class="term"><code class="varname">ON_ERROR_STOP</code></span></dt><dd><p>
        默认情况下，出现一个错误后命令处理会继续下去。当这个变量被设置为<code class="literal">on</code>后，出现错误后命令处理会立即停止。在交互模式下，<span class="application">psql</span>将会返回到命令提示符；否则，<span class="application">psql</span>将会退出并且返回错误代码 3 来把这种情况与致命错误区分开来，致命错误会被报告为错误代码 1。在两种情况下，任何当前正在运行的脚本（顶层脚本以及任何它已经调用的其他脚本）将被立即中止。如果顶层命名字符串包含多个 SQL 命令，将在当前命令处停止处理。
        </p></dd><dt><span class="term"><code class="varname">PORT</code></span></dt><dd><p>
        当前连接到的数据库服务器端口。每次连接到一个数据库时都会设置该变量（包括程序启动时），但是可以被更改或者重置。
        </p></dd><dt><span class="term"><code class="varname">PROMPT1</code><br /></span><span class="term"><code class="varname">PROMPT2</code><br /></span><span class="term"><code class="varname">PROMPT3</code></span></dt><dd><p>
        这些变量指定<span class="application">psql</span>发出的提示符的模样。见下文的<a class="xref" href="app-psql.html#APP-PSQL-PROMPTING" title="提示符">提示符</a>。
        </p></dd><dt><span class="term"><code class="varname">QUIET</code></span></dt><dd><p>
        把这个变量设置为<code class="literal">on</code>等效于命令行选项<code class="option">-q</code>。在交互模式下可能用处不大。
        </p></dd><dt><span class="term"><code class="varname">ROW_COUNT</code></span></dt><dd><p>
         上一个SQL查询返回的行数或者受影响的行数，如果该查询失败或者没有报告行计数则为0。
        </p></dd><dt><span class="term"><code class="varname">SERVER_VERSION_NAME</code><br /></span><span class="term"><code class="varname">SERVER_VERSION_NUM</code></span></dt><dd><p>
        字符串形式的服务器版本号，例如<code class="literal">9.6.2</code>、<code class="literal">10.1</code>或者<code class="literal">11beta1</code>，以及数字形式的服务器版本号，例如<code class="literal">90602</code>或者<code class="literal">100001</code>。每次你连接到一个数据库（包括程序启动）时，这些都会被设置，但可以被改变或者重设。
        </p></dd><dt><span class="term"><code class="varname">SHOW_CONTEXT</code></span></dt><dd><p>
        这个变量可以被设置为值<code class="literal">never</code>、<code class="literal">errors</code>或者<code class="literal">always</code>来控制是否在来自服务器的消息中显示<code class="literal">CONTEXT</code>域。默认是<code class="literal">errors</code>（表示在错误消息中显示上下文，但在通知和警告消息中不显示）。
        当<code class="varname">VERBOSITY</code>被设置为<code class="literal">terse</code>或<code class="literal">sqlstate</code>时，这个设置无效（另见<code class="command">\errverbose</code>，它可以用来得到刚遇到的错误的详细信息）。
        </p></dd><dt><span class="term"><code class="varname">SINGLELINE</code></span></dt><dd><p>
        设置这个变量为<code class="literal">on</code>等效于命令行选项<code class="option">-S</code>。
        </p></dd><dt><span class="term"><code class="varname">SINGLESTEP</code></span></dt><dd><p>
        设置这个变量为<code class="literal">on</code>等效于命令选项<code class="option">-s</code>。
        </p></dd><dt><span class="term"><code class="varname">SQLSTATE</code></span></dt><dd><p>
         与上一个SQL查询的失败相关的错误代码（见<a class="xref" href="errcodes-appendix.html" title="附录 A. PostgreSQL错误代码">附录 A</a>），如果上一个查询成功则为<code class="literal">00000</code>。
        </p></dd><dt><span class="term"><code class="varname">USER</code></span></dt><dd><p>
        当前连接的数据库用户。每次连接到一个数据库时都会设置该变量（包括程序启动时），但是可以被更改或者重置。
        </p></dd><dt><span class="term"><code class="varname">VERBOSITY</code></span></dt><dd><p>
        这个变量可以被设置为值<code class="literal">default</code>、<code class="literal">verbose</code>、<code class="literal">terse</code>或者<code class="literal">sqlstate</code>来控制错误报告的详细程度（另见<code class="command">\errverbose</code>，在想得到之前的错误的详细版本时使用）。
        </p></dd><dt><span class="term"><code class="varname">VERSION</code><br /></span><span class="term"><code class="varname">VERSION_NAME</code><br /></span><span class="term"><code class="varname">VERSION_NUM</code></span></dt><dd><p>
        这些变量在程序启动时被设置以反映<span class="application">psql</span>的版本，分别是一个详细的字符串、一个短字符串（例如<code class="literal">9.6.2</code>、<code class="literal">10.1</code>或者<code class="literal">11beta1</code>）以及一个数字（例如<code class="literal">90602</code>或者<code class="literal">100001</code>）。它们可以被更改或重设。
        </p></dd></dl></div></div><div class="refsect3" id="APP-PSQL-INTERPOLATION"><h4><acronym class="acronym">SQL</acronym> 中插入变量</h4><p>
    <span class="application">psql</span>变量的一个关键特性是可以把它们替换（<span class="quote">“<span class="quote">插入</span>”</span>）到常规<acronym class="acronym">SQL</acronym>语句中，也可以把它们作为元命令的参数。此外，<span class="application">psql</span>还提供了功能来确保被用作 SQL 文字和标识符的变量值会被正确地引用。插入一个值而不需要加引用的语法是在变量名前面加上一个冒号（<code class="literal">:</code>）。例如，
</p><pre class="programlisting">
testdb=&gt; <strong class="userinput"><code>\set foo 'my_table'</code></strong>
testdb=&gt; <strong class="userinput"><code>SELECT * FROM :foo;</code></strong>
</pre><p>
    将查询表<code class="literal">my_table</code>。注意这可能会不安全：该变量的值会被按字面拷贝，因此它可能包含不平衡的引号甚至反斜线命令。必须确保把它放在那里是有意义的。
    </p><p>
    当一个值被用作 SQL 文本或者标识符时，最安全的是把它加上引用。要引用一个变量的值作为 SQL 文本，可以把变量名称放在单引号中并且在引号前面写一个冒号。要引用作为 SQL 标识符，则可以把变量名称放在双引号中并且在引号前面写一个冒号。这种结构可以正确地处理变量值中嵌入的引号和其他特殊字符。之前的例子用这种方法写会更安全：
</p><pre class="programlisting">
testdb=&gt; <strong class="userinput"><code>\set foo 'my_table'</code></strong>
testdb=&gt; <strong class="userinput"><code>SELECT * FROM :"foo";</code></strong>
</pre><p>
    </p><p>
    在被引用的<acronym class="acronym">SQL</acronym>文本和标识符中将不会执行变量插入。因此，一个诸如<code class="literal">':foo'</code>的结构不会从一个变量的值产生一个被引用的文本（即便能够也会不安全，因为无法正确地处理嵌入在值中的引号）。
    </p><p>
    使用这种机制的一个例子是把一个文件的内容拷贝到一个表列中。首先把该文件载入到一个变量，然后把该变量的值作为一个被引用的字符串插入：
</p><pre class="programlisting">
testdb=&gt; <strong class="userinput"><code>\set content `cat my_file.txt`</code></strong>
testdb=&gt; <strong class="userinput"><code>INSERT INTO my_table VALUES (:'content');</code></strong>
</pre><p>
    （注意如果<code class="filename">my_file.txt</code>包含 NUL 字节，这样也不行。<span class="application">psql</span>不支持在变量值中嵌入 NUL 字节）。
    </p><p>
    因为冒号可以合法地出现在 SQL 命令中，一次明显的插入尝试（即<code class="literal">:name</code>、<code class="literal">:'name'</code>或者<code class="literal">:"name"</code>）不会被替换，除非所提及的变量就是当前被设置的。在任何情况下，可以用一个反斜线对冒号进行转义以避免它被替换。
    </p><p>
    <code class="literal">:{?<em class="replaceable"><code>name</code></em>}</code>特殊语法根据该变量存在与否返回TRUE或者FALSE，并且因此总是会被替换，除非分号被反斜线转义。
    </p><p>
    变量的冒号语法对嵌入式查询语言（例如<span class="application">ECPG</span>）来说是标准的<acronym class="acronym">SQL</acronym>。用于数组切片和类型造型的冒号语法是<span class="productname">PostgreSQL</span>扩展，它有时可能会与标准用法冲突。把一个变量值转义成 SQL 文本或者标识符的冒号引用语法是一种<span class="application">psql</span>扩展。
    </p></div><div class="refsect3" id="APP-PSQL-PROMPTING"><h4>提示符</h4><p>
    <span class="application">psql</span>发出的提示符可以根据用户的喜好自定义。<code class="varname">PROMPT1</code>、<code class="varname">PROMPT2</code>和<code class="varname">PROMPT3</code>这三个变量包含了描述提示符外观的字符串和特殊转义序列。Prompt 1 是当<span class="application">psql</span>等待新命令时发出的常规提示符。Prompt 2 是在命令输入时需要更多输入时发出的提示符，例如因为当命令没有被分号终止或者引用没有被关闭时就会发出这个提示符。在运行一个<acronym class="acronym">SQL</acronym> <code class="command">COPY FROM STDIN</code>命令并且需要在终端上输入一个行值时，会发出 Prompt 3。
    </p><p>
    被选中的提示符变量会被原样打印，除非碰到一个百分号（<code class="literal">%</code>）。百分号的下一个字符会被特定的其他文本替换。预定义好的替换有：

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">%M</code></span></dt><dd><p>
          数据库服务器的完整主机名（带有域名），或者当该连接是建立在一个 Unix 域套接字上时则是<code class="literal">[local]</code>，或者当 Unix 域套接字不在编译在系统内的默认位置上时则是<code class="literal">[local:<em class="replaceable"><code>/dir/name</code></em>]</code>。
        </p></dd><dt><span class="term"><code class="literal">%m</code></span></dt><dd><p>
          数据库服务器的主机名称（在第一个点处截断），或者当连接建立在一个 Unix 域套接字上时是<code class="literal">[local]</code>。
         </p></dd><dt><span class="term"><code class="literal">%&gt;</code></span></dt><dd><p>数据库服务器正在监听的端口号。</p></dd><dt><span class="term"><code class="literal">%n</code></span></dt><dd><p>
          数据库会话的用户名（在数据库会话期间，这个值可能会因为命令<code class="command">SET SESSION AUTHORIZATION</code>的结果而改变）。
         </p></dd><dt><span class="term"><code class="literal">%/</code></span></dt><dd><p>当前数据库的名称。</p></dd><dt><span class="term"><code class="literal">%~</code></span></dt><dd><p>和<code class="literal">%/</code>类似，但是如果数据库是默认数据库时输出是<code class="literal">~</code>（波浪线）。</p></dd><dt><span class="term"><code class="literal">%#</code></span></dt><dd><p>
          如果会话用户时一个数据库超级用户，则是<code class="literal">#</code>，否则是一个<code class="literal">&gt;</code>（在数据库会话期间，这个值可能会因为命令<code class="command">SET SESSION AUTHORIZATION</code>的结果而改变）。
         </p></dd><dt><span class="term"><code class="literal">%p</code></span></dt><dd><p>当前连接到的后端的进程 ID。</p></dd><dt><span class="term"><code class="literal">%R</code></span></dt><dd><p>
        在提示符1下通常是<code class="literal">=</code>，但如果会话位于一个条件块的一个非活动分支中则是<code class="literal">@</code>，如果会话处于单行模式中则是<code class="literal">^</code>，如果会话从数据库断开连接（<code class="command">\connect</code>失败时会发生这种情况）则是<code class="literal">!</code>。在提示符 2 中，根据为什么<span class="application">psql</span>期待更多的输入，<code class="literal">%R</code>会被一个相应的字符替换：如果命令还没有被终止是<code class="literal">-</code>，如果有一个未完的<code class="literal">/* ... */</code>注释则是<code class="literal">*</code>，如果有一个未完的被引用字符串则是一个单引号，如果有一个未完的被引用标识符则是一个双引号，如果有一个未完的美元引用字符串则是一个美元符号，如果有一个还没有被配对的左圆括号则是<code class="literal">(</code>。在提示符 3 中<code class="literal">%R</code>不会产生任何东西。
        </p></dd><dt><span class="term"><code class="literal">%x</code></span></dt><dd><p>
        事务状态：当不在事务块中时是一个空字符串，在一个事务块中时是<code class="literal">*</code>，在一个失败的事务块中时是<code class="literal">!</code>，当事务状态是未判定时（例如因为没有连接）为<code class="literal">?</code>。
        </p></dd><dt><span class="term"><code class="literal">%l</code></span></dt><dd><p>
          当前语句中的行号，从<code class="literal">1</code>开始。
         </p></dd><dt><span class="term"><code class="literal">%</code><em class="replaceable"><code>digits</code></em></span></dt><dd><p>
        带有指定的八进制码的字符会被替换。
        </p></dd><dt><span class="term"><code class="literal">%:</code><em class="replaceable"><code>name</code></em><code class="literal">:</code></span></dt><dd><p>
        <span class="application">psql</span>变量<em class="replaceable"><code>name</code></em>的值。详见<a class="xref" href="app-psql.html#APP-PSQL-VARIABLES" title="变量">变量</a>。
        </p></dd><dt><span class="term"><code class="literal">%`</code><em class="replaceable"><code>command</code></em><code class="literal">`</code></span></dt><dd><p>
        <em class="replaceable"><code>command</code></em>的输出，类似于平常的<span class="quote">“<span class="quote">反引号</span>”</span>替换。
        </p></dd><dt><span class="term"><code class="literal">%[</code> ... <code class="literal">%]</code></span></dt><dd><p>
         提示符可以包含终端控制字符，例如改变提示符文本的颜色、背景或者风格以及更改终端窗口标题的控制字符。为了让<span class="application">Readline</span>的行编辑特性正确工作，这些不可打印的控制字符必须被包裹在<code class="literal">%[</code>和<code class="literal">%]</code>之间以指定它们是不可见的。在提示附中可以出现多个这样的标识对。例如：
</p><pre class="programlisting">
testdb=&gt; \set PROMPT1 '%[%033[1;33;40m%]%n@%/%R%[%033[0m%]%# '
</pre><p>
         会导致一个在兼容 VT100 的彩色终端上的粗体（<code class="literal">1;</code>）的、黑底黄字（<code class="literal">33;40</code>）的提示符。
        </p></dd></dl></div><p>

    要在你的提示符中插入一个百分号，可以写成<code class="literal">%%</code>。提示符 1 和 2 的默认提示是<code class="literal">'%/%R%# '</code>，提示符 3 的提示是<code class="literal">'&gt;&gt; '</code>。
    </p><div class="note"><h3 class="title">注意</h3><p>
    这个特性是可耻地从<span class="application">tcsh</span>抄袭过来的。
    </p></div></div><div class="refsect3" id="id-1.9.4.18.8.5.5"><h4>命令行编辑</h4><p>
    为了方便的行编辑和检索，<span class="application">psql</span>支持<span class="application">Readline</span>库。<span class="application">psql</span>退出时命令历史会被自动保存，而当<span class="application">psql</span>启动时命令历史会被重新载入。<span class="application">psql</span>也支持 tab 补全，不过补全逻辑绝不是一个<acronym class="acronym">SQL</acronym>解析器。tab 补全产生的查询也可能会受其他 SQL 命令干扰，例如<code class="literal">SET TRANSACTION ISOLATION LEVEL</code>。如果出于某种原因不想用 tab 键补全，可以把下面的代码放在主目录下的名为<code class="filename">.inputrc</code>文件中关闭该特性：
</p><pre class="programlisting">
$if psql
set disable-completion on
$endif
</pre><p>
    （这不是<span class="application">psql</span>特性而是<span class="application">Readline</span>的特性。进一步的细节请阅读它的文档。）
    </p></div></div></div><div class="refsect1" id="APP-PSQL-ENVIRONMENT"><h2>环境</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="envar">COLUMNS</code></span></dt><dd><p>
      如果<code class="literal">\pset columns</code>为零，这个环境变量控制用于<code class="literal">wrapped</code>格式的宽度以及用来确定是否输出需要用到分页器或者切换到扩展自动模式中的垂直格式的宽度。
     </p></dd><dt><span class="term"><code class="envar">PGDATABASE</code><br /></span><span class="term"><code class="envar">PGHOST</code><br /></span><span class="term"><code class="envar">PGPORT</code><br /></span><span class="term"><code class="envar">PGUSER</code></span></dt><dd><p>
      默认连接参数（见<a class="xref" href="libpq-envars.html" title="33.14. 环境变量">第 33.14 节</a>）。
     </p></dd><dt><span class="term"><code class="envar">PG_COLOR</code></span></dt><dd><p>
      规定在诊断消息中是否使用颜色。可能的值为<code class="literal">always</code>、 <code class="literal">auto</code>、<code class="literal">never</code>。
     </p></dd><dt><span class="term"><code class="envar">PSQL_EDITOR</code><br /></span><span class="term"><code class="envar">EDITOR</code><br /></span><span class="term"><code class="envar">VISUAL</code></span></dt><dd><p>
      <code class="command">\e</code>、<code class="command">\ef</code>以及<code class="command">\ev</code>命令所使用的编辑器。会按照列出的顺序检查这些变量，第一个被设置的将被使用。如果都没有被设置，默认是使用Unix系统上的<code class="filename">vi</code>或者Windows系统上的<code class="filename">notepad.exe</code>。
     </p></dd><dt><span class="term"><code class="envar">PSQL_EDITOR_LINENUMBER_ARG</code></span></dt><dd><p>
      当<code class="command">\e</code>、<code class="command">\ef</code>或者<code class="command">\ev</code>带有一个行号参数时，这个变量指定用于传递起始行号给用户编辑器的命令行参数。对于<span class="productname">Emacs</span>或者<span class="productname">vi</span>之类的编辑器，这个变量是一个加号。如果需要在选项名称和行号之间有空格，可以在该变量的值中包括一个结尾的空格。例如：
</p><pre class="programlisting">
PSQL_EDITOR_LINENUMBER_ARG='+'
PSQL_EDITOR_LINENUMBER_ARG='--line '
</pre><p>
     </p><p>
      在 Unix 系统上默认是<code class="literal">+</code>（对应于默认编辑器<code class="filename">vi</code>，且对很多其他常见编辑器可用）。在 Windows 系统上没有默认值。
     </p></dd><dt><span class="term"><code class="envar">PSQL_HISTORY</code></span></dt><dd><p>
      命令历史文件的替代位置。波浪线（<code class="literal">~</code>）扩展会被执行。
     </p></dd><dt><span class="term"><code class="envar">PSQL_PAGER</code><br /></span><span class="term"><code class="envar">PAGER</code></span></dt><dd><p>
      如果一个查询的结果在屏幕上放不下，它们会通过这个命令分页显示。典型的值是<code class="literal">more</code>或<code class="literal">less</code>。通过把<code class="envar">PSQL_PAGER</code>或<code class="envar">PAGER</code>设置为空字符串可以禁用分页器的使用，调整<code class="command">\pset</code>命令与分页器相关的选项也能达到同样的效果。会按照列出的顺序检查这些变量，第一个被设置的将被使用。如果都没有被设置，则大部分平台上默认使用<code class="literal">more</code>，但在Cygwin上使用<code class="literal">less</code>。
     </p></dd><dt><span class="term"><code class="envar">PSQLRC</code></span></dt><dd><p>
      用户的<code class="filename">.psqlrc</code>文件的替代位置。波浪线（<code class="literal">~</code>）扩展会被执行。
     </p></dd><dt><span class="term"><code class="envar">SHELL</code></span></dt><dd><p>
      被<code class="command">\!</code>命令执行的命令。
     </p></dd><dt><span class="term"><code class="envar">TMPDIR</code></span></dt><dd><p>
      存储临时文件的目录。默认是<code class="filename">/tmp</code>。
     </p></dd></dl></div><p>
   和大部分其他<span class="productname">PostgreSQL</span>工具一样，这个工具也使用<span class="application">libpq</span>所支持的环境变量（见<a class="xref" href="libpq-envars.html" title="33.14. 环境变量">第 33.14 节</a>）。
  </p></div><div class="refsect1" id="id-1.9.4.18.10"><h2>文件</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="filename">psqlrc</code> and <code class="filename">~/.psqlrc</code></span></dt><dd><p>
     如果没有<code class="option">-X</code>选项，在连接到数据库后但在接收正常的命令之前，<span class="application">psql</span>会尝试依次从系统级的启动文件（<code class="filename">psqlrc</code>）和用户的个人启动文件（<code class="filename">~/.psqlrc</code>）中读取并且执行命令。这些文件可以被用来设置客户端或者服务器，通常是一些<code class="command">\set</code>和<code class="command">SET</code>命令。
    </p><p>
     系统级的启动文件是<code class="filename">psqlrc</code>，它应该在安装好的<span class="productname">PostgreSQL</span>的<span class="quote">“<span class="quote">系统配置</span>”</span>目录中，最可靠的定位方法是运行<code class="literal">pg_config --sysconfdir</code>。默认情况下，这个目录将是<code class="filename">../etc/</code>（相对于包含<span class="productname">PostgreSQL</span>可执行文件的目录）。可以通过<code class="envar">PGSYSCONFDIR</code>环境变量显式地设置这个目录的名称。
    </p><p>
     用户个人的启动文件是<code class="filename">.psqlrc</code>，它应该在调用用户的主目录中。在 Windows 上，由于没有用户主目录的概念，个人的启动文件是<code class="filename">%APPDATA%\postgresql\psqlrc.conf</code>。用户启动文件的位置可以通过<code class="envar">PSQLRC</code>环境变量设置。        
    </p><p>
     系统级和用户个人的启动文件都可以弄成是针对特定<span class="application">psql</span>版本的，方法是在文件名后面加上一个横线以及<span class="productname">PostgreSQL</span>的主、次版本号，例如<code class="filename">~/.psqlrc-9.2</code>或者<code class="filename">~/.psqlrc-9.2.5</code>。版本最为匹配的文件会优先于不那么匹配的文件读入。
    </p></dd><dt><span class="term"><code class="filename">.psql_history</code></span></dt><dd><p>
     命令行历史被存储在文件<code class="filename">~/.psql_history</code>中，或者是 Windows 的文件<code class="filename">%APPDATA%\postgresql\psql_history</code>中。
    </p><p>
     历史文件的位置可以通过<code class="varname">HISTFILE</code> <span class="application">psql</span>变量或者<code class="envar">PSQL_HISTORY</code>环境变量明确的设置。
    </p></dd></dl></div></div><div class="refsect1" id="id-1.9.4.18.11"><h2>注解</h2><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="application">psql</span>和具有相同主版本或者更老的主版本服务器最为匹配。如果服务器的版本比<span class="application">psql</span>本身要高，则反斜线命令尤其容易失败。不过，<code class="literal">\d</code>家族的反斜线命令应该可以和版本 7.4 之后的服务器一起使用，但服务器的版本不必比<span class="application">psql</span>本身新。运行 SQL 命令并且显示查询结果的一般功能应该也能和具有更新主版本的服务器一起使用，但是并非在所有的情况下都能保证如此。
      </p><p>
       如果你想用<span class="application">psql</span>连接到多个具有不同主版本的服务器，推荐使用最新版本的<span class="application">psql</span>。或者，你可以为每一个主版本保留一份<span class="application">psql</span>拷贝，并且针对相应的服务器使用匹配的版本。但实际上，这种额外的麻烦是不必要的。
      </p></li><li class="listitem"><p>
       在<span class="productname">PostgreSQL</span> 9.6 之前，<code class="option">-c</code>选项表示<code class="option">-X</code>（<code class="option">--no-psqlrc</code>），但现在不是这样了。
      </p></li><li class="listitem"><p>
       在<span class="productname">PostgreSQL</span> 8.4 之前，<span class="application">psql</span>允许一个单字母反斜线命令的第一个参数直接写在该命令后面，中间不需要空格。现在则要求一些空格。
      </p></li></ul></div></div><div class="refsect1" id="id-1.9.4.18.12"><h2>给 Windows 用户的注解</h2><p>
  <span class="application">psql</span>是一个<span class="quote">“<span class="quote">控制台应用</span>”</span>。由于 Windows 的控制台窗口使用的是一种和系统中其他应用不同的编码，在<span class="application">psql</span>中使用 8 位字符时要特别注意。如果<span class="application">psql</span>检测到一个有问题的控制台代码页，它将会在启动时警告你。要更改控制台代码页，有两件事是必要的：

   </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
      输入<strong class="userinput"><code>cmd.exe /c chcp 1252</code></strong>可以设置代码页（1252 是适用于德语的一个代码页，请在这里替换成你的值）。如果正在使用 Cygwin，可以把这个命令放在<code class="filename">/etc/profile</code>中。
     </p></li><li class="listitem"><p>
      把控制台字体设置为<code class="literal">Lucida Console</code>，因为栅格字体无法与 ANSI 代码页一起使用。
     </p></li></ul></div></div><div class="refsect1" id="APP-PSQL-EXAMPLES"><h2>示例</h2><p>
  第一个例子展示了如何如何跨越多行输入一个命令。注意提示符的改变：
</p><pre class="programlisting">
testdb=&gt; <strong class="userinput"><code>CREATE TABLE my_table (</code></strong>
testdb(&gt; <strong class="userinput"><code> first integer not null default 0,</code></strong>
testdb(&gt; <strong class="userinput"><code> second text)</code></strong>
testdb-&gt; <strong class="userinput"><code>;</code></strong>
CREATE TABLE
</pre><p>
  现在再看看表定义：
</p><pre class="programlisting">
testdb=&gt; <strong class="userinput"><code>\d my_table</code></strong>
              Table "public.my_table"
 Column |  Type   | Collation | Nullable | Default
--------+---------+-----------+----------+---------
 first  | integer |           | not null | 0
 second | text    |           |          | 
</pre><p>
  现在我们把提示符改一改：
</p><pre class="programlisting">
testdb=&gt; <strong class="userinput"><code>\set PROMPT1 '%n@%m %~%R%# '</code></strong>
peter@localhost testdb=&gt;
</pre><p>
  假定已经用数据填充了这个表并且想看看其中的数据：
</p><pre class="programlisting">
peter@localhost testdb=&gt; SELECT * FROM my_table;
 first | second
-------+--------
     1 | one
     2 | two
     3 | three
     4 | four
(4 rows)

</pre><p>
  你可以用<code class="command">\pset</code>命令以不同的方式显示表：
</p><pre class="programlisting">
peter@localhost testdb=&gt; <strong class="userinput"><code>\pset border 2</code></strong>
Border style is 2.
peter@localhost testdb=&gt; <strong class="userinput"><code>SELECT * FROM my_table;</code></strong>
+-------+--------+
| first | second |
+-------+--------+
|     1 | one    |
|     2 | two    |
|     3 | three  |
|     4 | four   |
+-------+--------+
(4 rows)

peter@localhost testdb=&gt; <strong class="userinput"><code>\pset border 0</code></strong>
Border style is 0.
peter@localhost testdb=&gt; <strong class="userinput"><code>SELECT * FROM my_table;</code></strong>
first second
----- ------
    1 one
    2 two
    3 three
    4 four
(4 rows)

peter@localhost testdb=&gt; <strong class="userinput"><code>\pset border 1</code></strong>
Border style is 1.
peter@localhost testdb=&gt; <strong class="userinput"><code>\pset format csv</code></strong>
Output format is csv.
peter@localhost testdb=&gt; <strong class="userinput"><code>\pset tuples_only</code></strong>
Tuples only is on.
peter@localhost testdb=&gt; <strong class="userinput"><code>SELECT second, first FROM my_table;</code></strong>
one,1
two,2
three,3
four,4
peter@localhost testdb=&gt; <strong class="userinput"><code>\pset format unaligned</code></strong>
Output format is unaligned.
peter@localhost testdb=&gt; <strong class="userinput"><code>\pset fieldsep '\t'</code></strong>
Field separator is "    ".
peter@localhost testdb=&gt; <strong class="userinput"><code>SELECT second, first FROM my_table;</code></strong>
one     1
two     2
three   3
four    4
</pre><p>
  或者使用短命令：
</p><pre class="programlisting">
peter@localhost testdb=&gt; <strong class="userinput"><code>\a \t \x</code></strong>
Output format is aligned.
Tuples only is off.
Expanded display is on.
peter@localhost testdb=&gt; <strong class="userinput"><code>SELECT * FROM my_table;</code></strong>
-[ RECORD 1 ]-
first  | 1
second | one
-[ RECORD 2 ]-
first  | 2
second | two
-[ RECORD 3 ]-
first  | 3
second | three
-[ RECORD 4 ]-
first  | 4
second | four
</pre><p>
  如果需要，可以用<code class="command">\crosstabview</code>命令以交叉表的形式显示查询结果：
</p><pre class="programlisting">
testdb=&gt; <strong class="userinput"><code>SELECT first, second, first &gt; 2 AS gt2 FROM my_table;</code></strong>
 first | second | gt2 
-------+--------+-----
     1 | one    | f
     2 | two    | f
     3 | three  | t
     4 | four   | t
(4 rows)

testdb=&gt; <strong class="userinput"><code>\crosstabview first second</code></strong>
 first | one | two | three | four 
-------+-----+-----+-------+------
     1 | f   |     |       | 
     2 |     | f   |       | 
     3 |     |     | t     | 
     4 |     |     |       | t
(4 rows)
</pre><p>

这第二个例子展示了表的“乘法”（连接），行按照序号降序排序且列按照独立的、升序的方式排序。
</p><pre class="programlisting">
testdb=&gt; <strong class="userinput"><code>SELECT t1.first as "A", t2.first+100 AS "B", t1.first*(t2.first+100) as "AxB",</code></strong>
testdb(&gt; <strong class="userinput"><code>row_number() over(order by t2.first) AS ord</code></strong>
testdb(&gt; <strong class="userinput"><code>FROM my_table t1 CROSS JOIN my_table t2 ORDER BY 1 DESC</code></strong>
testdb(&gt; <strong class="userinput"><code>\crosstabview "A" "B" "AxB" ord</code></strong>
 A | 101 | 102 | 103 | 104 
---+-----+-----+-----+-----
 4 | 404 | 408 | 412 | 416
 3 | 303 | 306 | 309 | 312
 2 | 202 | 204 | 206 | 208
 1 | 101 | 102 | 103 | 104
(4 rows)
</pre><p>

</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="app-pgrestore.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="reference-client.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="app-reindexdb.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">pg_restore </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> <span class="application">reindexdb</span></td></tr></table></div></body></html>