<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>68.6. 数据库页面布局</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="storage-init.html" title="68.5. 初始化分支" /><link rel="next" href="bki.html" title="第 69 章 系统目录声明和初始内容" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">68.6. 数据库页面布局</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="storage-init.html" title="68.5. 初始化分支">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="storage.html" title="第 68 章 数据库物理存储">上一级</a></td><th width="60%" align="center">第 68 章 数据库物理存储</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="bki.html" title="第 69 章 系统目录声明和初始内容">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="STORAGE-PAGE-LAYOUT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">68.6. 数据库页面布局</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="storage-page-layout.html#STORAGE-TUPLE-LAYOUT">68.6.1. 表行布局</a></span></dt></dl></div><p>
本章提供一个<span class="productname">PostgreSQL</span>的表和索引所使用的页面格式的概述。<a href="#ftn.id-1.10.21.8.2.2" class="footnote"><sup class="footnote" id="id-1.10.21.8.2.2">[15]</sup></a>
序列和<acronym class="acronym">TOAST</acronym>表的格式就像一个普通表一样。
</p><p>
在下面解释中，一个<em class="firstterm">字节</em>被假定包含 8 个位。
另外，术语<em class="firstterm">item</em>指的是存储在一个页面里的
独立数据值。 在一个表里，一个项是一个行；在一个索引里，一个项是
一条索引记录。
</p><p>
每个表和索引都以一个固定尺寸（通常是 8kB，不过在编译服务器时可以选择其他不同的尺寸）的<em class="firstterm">页面</em>数组存储。 在表中，所有页面在逻辑上都相同，所以一个特定的项（行）可以被存储在任何页面里。 在索引里，第一个页面通常保留为<em class="firstterm">元页</em>来保存控制信息， 并且依索引访问方法的不同，在索引里可能有不同类型的页面。
</p><p>
<a class="xref" href="storage-page-layout.html#PAGE-TABLE" title="表 68.2. 总体页面布局">表 68.2</a>显示一个页面的总体布局。每个页面有五个部分。
</p><div class="table" id="PAGE-TABLE"><p class="title"><strong>表 68.2. 总体页面布局</strong></p><div class="table-contents"><table class="table" summary="总体页面布局" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>
项
</th><th>描述</th></tr></thead><tbody><tr><td>PageHeaderData</td><td>24字节长。包含关于页面的一般信息，包括空闲空间指针。</td></tr><tr><td>ItemIdData</td><td>指向实际项的项标识符数组。每一个条目是一对(偏移量、长度)。每个项 4 字节。</td></tr><tr><td>Free space</td><td>未分配的空间（空闲空间）。新项标识符从这个区域的开头开始分配，新项从其结尾开始分配。</td></tr><tr><td>Items</td><td>实际的项本身。</td></tr><tr><td>Special space</td><td>索引访问模式相关的数据。不同的索引访问方式存放不同的数据。在普通表中为空。</td></tr></tbody></table></div></div><br class="table-break" /><p>

  每个页面的头24个字节组成页头（<code class="structname">PageHeaderData</code>）。它的格式在<a class="xref" href="storage-page-layout.html#PAGEHEADERDATA-TABLE" title="表 68.3. PageHeaderData布局">表 68.3</a>里详细介绍。 第一个域跟踪与此页面相关的最近的 WAL 项。第二个域包含该页面的校验码（如果<a class="xref" href="app-initdb.html#APP-INITDB-DATA-CHECKSUMS">data checksums</a>被启用）。接下来一个2字节的域包含标志位。此后跟随着三个 2 字节的整数域 （<code class="structfield">pd_lower</code>、<code class="structfield">pd_upper</code>和<code class="structfield">pd_special</code>）。 这些域包含从页面开始位置到未分配空间开头的字节偏移、到未分配空间结尾的字节偏移以及到特殊空间开头的字节偏移。页面头中再接下来的 2 字节（<code class="structfield">pd_pagesize_version</code>）存储页面尺寸和一个版本指示器。从<span class="productname">PostgreSQL</span> 8.3开始的版本号为4；<span class="productname">PostgreSQL</span> 8.1和8.2使用版本号3；<span class="productname">PostgreSQL</span> 8.0 使用版本号 2；<span class="productname">PostgreSQL</span> 7.3 和 7.4 使用版本号 1； 更早的版本使用版本号 0（基本页面布局和头格式在大部分这些版本里都没有改变，但是堆的行头部布局有所变化）。 页面大小主要用于交叉检查；目前在一次安装里，还不能支持多于一种页面大小。最后的域是一个提示，它显示删除该页是否可能获益：它跟踪在页面上最老的未删除的XMAX。

 </p><div class="table" id="PAGEHEADERDATA-TABLE"><p class="title"><strong>表 68.3. PageHeaderData布局</strong></p><div class="table-contents"><table class="table" summary="PageHeaderData布局" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>域</th><th>类型</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>pd_lsn</td><td>PageXLogRecPtr</td><td>8 bytes</td><td>LSN: 最后修改这个页面的WAL记录最后一个字节后面的第一个字节</td></tr><tr><td>pd_checksum</td><td>uint16</td><td>2 bytes</td><td>页面校验码</td></tr><tr><td>pd_flags</td><td>uint16</td><td>2 bytes</td><td>标志位</td></tr><tr><td>pd_lower</td><td>LocationIndex</td><td>2 bytes</td><td>到空闲空间开头的偏移量</td></tr><tr><td>pd_upper</td><td>LocationIndex</td><td>2 bytes</td><td>到空闲空间结尾的偏移量</td></tr><tr><td>pd_special</td><td>LocationIndex</td><td>2 bytes</td><td>到特殊空间开头的偏移量</td></tr><tr><td>pd_pagesize_version</td><td>uint16</td><td>2 bytes</td><td>页面大小和布局版本号信息</td></tr><tr><td>pd_prune_xid</td><td>TransactionId</td><td>4 bytes</td><td>页面上最老未删除XMAX，如果没有则为0</td></tr></tbody></table></div></div><br class="table-break" /><p>
  所有细节都可以在<code class="filename">src/include/storage/bufpage.h</code>中找到。
 </p><p>

  在页头后面是项标识符（<code class="type">ItemIdData</code>），每个占用四个字节。 一个项标识符包含一个到项开头的字节偏移量（它的长度以字节计）， 以及一些属性位，这些属性位影响对它的解释。 新的项标识符根据需要从未分配空间的开头分配。项标识符的数目可以通过查看<code class="structfield">pd_lower</code>来判断，在分配新标识符的时候<code class="structfield">pd_lower</code>会增长。因为一个项标识符在被释放前绝对不会移动，所以它的索引可以用于长期地引用一个项， 即使该项本身因为压缩空闲空间在页面内部进行了移动。实际上，<span class="productname">PostgreSQL</span>创建的每个指向项的指针（<code class="type">ItemPointer</code>，也叫做<code class="type">CTID</code>）都由一个页号和一个项标识符的索引组成。

 </p><p>

  项本身存储在从未分配空间末尾开始从后向前分配的空间里。它们的实际结构取决于表包含的内容。表和序列都使用一种叫做 <code class="type">HeapTupleHeaderData</code>的结构，如下文所述。

 </p><p>

  最后一部分是<span class="quote">“<span class="quote">特殊部分</span>”</span>，它可以包含访问方法想存放的任何东西。比如，b-tree 索引用它存储指向页面的左右兄妹的链接，以及其他一些和索引结构相关的数据。普通表并不使用这个部分（通过设置<code class="structfield">pd_special</code>等于页面大小来表示）。

 </p><p>
  <a class="xref" href="storage-page-layout.html#STORAGE-PAGE-LAYOUT-FIGURE" title="图 68.1. 页面布局">图 68.1</a> 举例说明这些组件如何在一个页面中布局。
 </p><div class="figure" id="STORAGE-PAGE-LAYOUT-FIGURE"><p class="title"><strong>图 68.1. 页面布局</strong></p><div class="figure-contents"><div class="mediaobject"><object type="image/svg+xml" data="pagelayout.svg" width="100%"></object></div></div></div><br class="figure-break" /><div class="sect2" id="STORAGE-TUPLE-LAYOUT"><div class="titlepage"><div><div><h3 class="title">68.6.1. 表行布局</h3></div></div></div><p>

  所有表行都用同样方法构造。它们有一个定长的头部（在大多数机器上占据 23 个字节）， 后面跟着一个可选的空值位图、一个可选的对象 ID 域以及用户数据。 该头部在<a class="xref" href="storage-page-layout.html#HEAPTUPLEHEADERDATA-TABLE" title="表 68.4. HeapTupleHeaderData布局">表 68.4</a>里详细描述。实际的用户数据（行的列）从<code class="structfield">t_hoff</code>指示的偏移位置开始， 它必须总是该平台的 MAXALIGN 距离的倍数。空值位图只有在<code class="structfield">t_infomask</code>中的<em class="firstterm">HEAP_HASNULL</em>位被设置时存在。 
  如果存在，那么它紧跟在定长的头部后面，并占据足够的字节来容纳每个数据列对应的一个位（也就是说，位数等于<code class="structfield">t_infomask2</code>中的属性计数。）。 在这个位的列表中，为 1 的位表示非空，而为 0 的位表示空。如果这个位图不存在，那么所有列都被假设为非空的。
  对象 ID 只有在设置了 <code class="structfield">t_infomask</code>里面的<em class="firstterm">HEAP_HASOID_OLD</em>位时才存在。 
  如果存在，它正好出现在<code class="structfield">t_hoff</code>边界之前。如果需要对齐<code class="structfield">t_hoff</code>使之成为 MAXALIGN 的倍数，那么填充将出现在空值位图和对象 ID 之间（这样也保证了对象 ID 得到恰当的对齐）。

 </p><div class="table" id="HEAPTUPLEHEADERDATA-TABLE"><p class="title"><strong>表 68.4. HeapTupleHeaderData布局</strong></p><div class="table-contents"><table class="table" summary="HeapTupleHeaderData布局" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>域</th><th>类型</th><th>长度</th><th>描述</th></tr></thead><tbody><tr><td>t_xmin</td><td>TransactionId</td><td>4 bytes</td><td>插入XID标志</td></tr><tr><td>t_xmax</td><td>TransactionId</td><td>4 bytes</td><td>删除XID标志</td></tr><tr><td>t_cid</td><td>CommandId</td><td>4 bytes</td><td>插入和/或删除CID标志（覆盖t_xvac）</td></tr><tr><td>t_xvac</td><td>TransactionId</td><td>4 bytes</td><td>VACUUM操作移动一个行版本的XID</td></tr><tr><td>t_ctid</td><td>ItemPointerData</td><td>6 bytes</td><td>当前版本的TID或者指向更新的行版本</td></tr><tr><td>t_infomask2</td><td>uint16</td><td>2 bytes</td><td>一些属性，加上多个标志位</td></tr><tr><td>t_infomask</td><td>uint16</td><td>2 bytes</td><td>多个标志位</td></tr><tr><td>t_hoff</td><td>uint8</td><td>1 byte</td><td>到用户数据的偏移量</td></tr></tbody></table></div></div><br class="table-break" /><p>
   所有细节都可以在<code class="filename">src/include/access/htup_details.h</code>中找到。
 </p><p>

  只有从其他表里获取了信息之后才能对确切数据进行， 这些信息大多数在<code class="structname">pg_attribute</code>中。 标识域位置的关键值是<code class="structfield">attlen</code>和<code class="structfield">attalign</code>。 我们没有办法直接获取某个特定属性，除非它们是定宽并且没有空值。所有这些复杂的操作都封装在函数<em class="firstterm">heap_getattr</em>、<em class="firstterm">fastgetattr</em>和<em class="firstterm">heap_getsysattr</em>中。

 </p><p>

  要读取数据的话，你需要轮流检查每个属性。首先根据空值位图检查该域是否为NULL。 如果是，那么跳到下一个。然后保证你的对齐是正确的。如果域是一个定宽域，那么所有字节都简单地放在其中。 如果它是一个变长域（attlen = -1），那么它就会有点复杂。所有变长数据类型都使用一个通用的头部结构<code class="type">struct varlena</code>， 它包含所存储的值的总长度以及一些标志位。根据标志的不同，数据可能在线内或者是在一个<acronym class="acronym">TOAST</acronym>中，还可能是压缩的（参阅<a class="xref" href="storage-toast.html" title="68.2. TOAST">第 68.2 节</a>）。

 </p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.10.21.8.2.2" class="footnote"><p><a href="#id-1.10.21.8.2.2" class="para"><sup class="para">[15] </sup></a>
    实际上，表和索引访问模式并不需要使用这种页面格式。 <code class="literal">heap</code>表访问方法总是采用这种格式。
    目前所有的索引方法的确也使用这个基本格式， 但索引元页里的数据通常并不遵循项布局规则。
  </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="storage-init.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="storage.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="bki.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">68.5. 初始化分支 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 69 章 系统目录声明和初始内容</td></tr></table></div></body></html>