<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>51.7. pg_attribute</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="catalog-pg-attrdef.html" title="51.6. pg_attrdef" /><link rel="next" href="catalog-pg-authid.html" title="51.8. pg_authid" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">51.7. <code xmlns="http://www.w3.org/1999/xhtml" class="structname">pg_attribute</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="catalog-pg-attrdef.html" title="51.6. pg_attrdef">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="catalogs.html" title="第 51 章 系统目录">上一级</a></td><th width="60%" align="center">第 51 章 系统目录</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="catalog-pg-authid.html" title="51.8. pg_authid">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="CATALOG-PG-ATTRIBUTE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">51.7. <code class="structname">pg_attribute</code></h2></div></div></div><a id="id-1.10.4.9.2" class="indexterm"></a><p>
   目录<code class="structname">pg_attribute</code>存储有关表列的信息。数据库中的每一个表的每一个列都恰好在<code class="structname">pg_attribute</code>中有一行。（这其中也会有索引的属性项，并且事实上所有具有<code class="structname">pg_class</code>项的对象在这里都有属性项）
   entries.)
  </p><p>
   术语属性等同于列，这里使用它只是出于历史原因。
  </p><div class="table" id="id-1.10.4.9.5"><p class="title"><strong>表 51.7. <code class="structname">pg_attribute</code>的列</strong></p><div class="table-contents"><table class="table" summary="pg_attribute的列" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>类型</th><th>引用</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">attrelid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-class.html" title="51.11. pg_class"><code class="structname">pg_class</code></a>.oid</code></td><td>列所属的表</td></tr><tr><td><code class="structfield">attname</code></td><td><code class="type">name</code></td><td> </td><td>列名</td></tr><tr><td><code class="structfield">atttypid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-type.html" title="51.63. pg_type"><code class="structname">pg_type</code></a>.oid</code></td><td>列的数据类型</td></tr><tr><td><code class="structfield">attstattarget</code></td><td><code class="type">int4</code></td><td> </td><td>
       <code class="structfield">attstattarget</code>控制由<a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a>对此列收集的统计信息的细节层次。0值表示不会收集任何统计信息。一个负值则说明直接使用系统默认的目标。正值的确切含义取决于数据类型。对于标量数据类型，<code class="structfield">attstattarget</code>既是要收集的<span class="quote">“<span class="quote">最常见值</span>”</span>的目标号，也是要创建的柱状图容器的目标号。
      </td></tr><tr><td><code class="structfield">attlen</code></td><td><code class="type">int2</code></td><td> </td><td>
       本列类型的<code class="literal">pg_type.typlen</code>一个拷贝
      </td></tr><tr><td><code class="structfield">attnum</code></td><td><code class="type">int2</code></td><td> </td><td>
       列的编号。一般列从1开始向上编号。系统列（如<code class="structfield">ctid</code>）则拥有（任意）负值编号。
      </td></tr><tr><td><code class="structfield">attndims</code></td><td><code class="type">int4</code></td><td> </td><td>
       如果该列是一个数组类型，这里就是其维度数；否则为0。（在目前一个数组的维度数并不被强制，因此任何非零值都能有效地表明<span class="quote">“<span class="quote">这是一个数组</span>”</span>。）
      </td></tr><tr><td><code class="structfield">attcacheoff</code></td><td><code class="type">int4</code></td><td> </td><td>
       在存储中总是为-1，但是当被载入到一个内存中的行描述符后，这里可能会被更新为属性在行内的偏移
      </td></tr><tr><td><code class="structfield">atttypmod</code></td><td><code class="type">int4</code></td><td> </td><td>
       <code class="structfield">atttypmod</code>记录了在表创建时提供的类型相关数据（例如一个<code class="type">varchar</code>列的最大长度）。它会被传递给类型相关的输入函数和长度强制函数。对于那些不需要<code class="structfield">atttypmod</code>的类型，这个值通常总是为-1。
      </td></tr><tr><td><code class="structfield">attbyval</code></td><td><code class="type">bool</code></td><td> </td><td>
       该列类型的<code class="literal">pg_type.typbyval</code>的一个拷贝
      </td></tr><tr><td><code class="structfield">attstorage</code></td><td><code class="type">char</code></td><td> </td><td>
       通常是该列类型的<code class="literal">pg_type.typstorage</code>的一个拷贝。对于可TOAST的数据类型，这可以在列创建后被修改以控制存储策略。
      </td></tr><tr><td><code class="structfield">attalign</code></td><td><code class="type">char</code></td><td> </td><td>
       该列类型的<code class="literal">pg_type.typalign</code>的一个拷贝
      </td></tr><tr><td><code class="structfield">attnotnull</code></td><td><code class="type">bool</code></td><td> </td><td>
       这表示一个非空约束。
      </td></tr><tr><td><code class="structfield">atthasdef</code></td><td><code class="type">bool</code></td><td> </td><td>
      该列有一个默认表达式或生成的表达式，在此情况下在<code class="structname">pg_attrdef</code>目录中会有一个对应项来真正定义该表达式。（检查<code class="structfield">attgenerated</code>以确定是默认还是生成的表达式。）
      </td></tr><tr><td><code class="structfield">atthasmissing</code></td><td><code class="type">bool</code></td><td> </td><td>
       该列在行中完全缺失时会用到这个列的值，如果在行创建之后增加一个有非易失<code class="literal">DEFAULT</code>值的列，就会发生这种情况。实际使用的值被存放在<code class="structfield">attmissingval</code>列中。
      </td></tr><tr><td><code class="structfield">attidentity</code></td><td><code class="type">char</code></td><td> </td><td>
       如果是一个零字节（<code class="literal">''</code>），则不是一个标识列。否则，<code class="literal">a</code> = 总是生成，<code class="literal">d</code> = 默认生成。
      </td></tr><tr><td><code class="structfield">attgenerated</code></td><td><code class="type">char</code></td><td> </td><td>
       如果为零字节(<code class="literal">''</code>)，则不是生成的列。否则，<code class="literal">s</code> = stored。（将来可能会添加其他值。）
      </td></tr><tr><td><code class="structfield">attisdropped</code></td><td><code class="type">bool</code></td><td> </td><td>
       该列被删除且不再有效。一个删除的列仍然物理存在于表中，但是会被分析器忽略并因此无法通过SQL访问。
      </td></tr><tr><td><code class="structfield">attislocal</code></td><td><code class="type">bool</code></td><td> </td><td>
       该列是由关系本地定义的。注意一个列可以同时是本地定义和继承的。
      </td></tr><tr><td><code class="structfield">attinhcount</code></td><td><code class="type">int4</code></td><td> </td><td>
       该列的直接祖先的编号。一个具有非零编号祖先的列不能被删除或者重命名。
      </td></tr><tr><td><code class="structfield">attcollation</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-collation.html" title="51.12. pg_collation"><code class="structname">pg_collation</code></a>.oid</code></td><td>
       该列被定义的排序规则，如果该列不是一个可排序数据类型则为0。
      </td></tr><tr><td><code class="structfield">attacl</code></td><td><code class="type">aclitem[]</code></td><td> </td><td>
       列级访问权限
      </td></tr><tr><td><code class="structfield">attoptions</code></td><td><code class="type">text[]</code></td><td> </td><td>
       属性级选项，以<span class="quote">“<span class="quote">keyword=value</span>”</span>形式的字符串
      </td></tr><tr><td><code class="structfield">attfdwoptions</code></td><td><code class="type">text[]</code></td><td> </td><td>
       属性级的外部数据包装器选项，以<span class="quote">“<span class="quote">keyword=value</span>”</span>形式的字符串
      </td></tr><tr><td><code class="structfield">attmissingval</code></td><td><code class="type">anyarray</code></td><td> </td><td>
       这个列中是一个含有一个元素的数组，其中的值被用于该列在行中完全缺失时，如果在行创建之后增加一个有非易失<code class="literal">DEFAULT</code>值的列，就会发生这种情况。只有当<code class="structfield">atthasmissing</code>为真时才使用这个值。如果没有值则该列为空。
      </td></tr></tbody></table></div></div><br class="table-break" /><p>
   在一个被删除的列的<code class="structname">pg_attribute</code>的项中，<code class="structfield">atttypid</code>被重置为0，但<code class="structfield">attlen</code>以及其他从<code class="structname">pg_type</code>拷贝的域仍然有效。这种安排用于处理一种情况，即被删除列的数据类型后来被删除，并且因此不再有相应的<code class="structname">pg_type</code>行。<code class="structfield">attlen</code>和其他域可以被用来解释表的一行的内容。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="catalog-pg-attrdef.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="catalogs.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="catalog-pg-authid.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">51.6. <code class="structname">pg_attrdef</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 51.8. <code class="structname">pg_authid</code></td></tr></table></div></body></html>