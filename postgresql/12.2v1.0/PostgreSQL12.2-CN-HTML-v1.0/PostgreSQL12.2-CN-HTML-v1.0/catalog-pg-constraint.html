<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>51.13. pg_constraint</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="catalog-pg-collation.html" title="51.12. pg_collation" /><link rel="next" href="catalog-pg-conversion.html" title="51.14. pg_conversion" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">51.13. <code xmlns="http://www.w3.org/1999/xhtml" class="structname">pg_constraint</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="catalog-pg-collation.html" title="51.12. pg_collation">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="catalogs.html" title="第 51 章 系统目录">上一级</a></td><th width="60%" align="center">第 51 章 系统目录</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="catalog-pg-conversion.html" title="51.14. pg_conversion">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="CATALOG-PG-CONSTRAINT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">51.13. <code class="structname">pg_constraint</code></h2></div></div></div><a id="id-1.10.4.15.2" class="indexterm"></a><p>
   目录<code class="structname">pg_constraint</code>存储表上的检查、主键、唯一、外键和排他约束（列约束也不会被特殊对待。每一个列约束都等同于某种表约束。）。非空约束不在这里，而是在<code class="structname">pg_attribute</code>目录中表示。
  </p><p>
   用户定义的约束触发器（使用<code class="command">CREATE CONSTRAINT TRIGGER</code>创建）也会在这个表中产生一项。
  </p><p>
   域上的检查约束也存储在这里。
  </p><div class="table" id="id-1.10.4.15.6"><p class="title"><strong>表 51.13. <code class="structname">pg_constraint</code>的列</strong></p><div class="table-contents"><table class="table" summary="pg_constraint的列" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>类型</th><th>引用</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">oid</code></td><td><code class="type">oid</code></td><td> </td><td>行标识符</td></tr><tr><td><code class="structfield">conname</code></td><td><code class="type">name</code></td><td> </td><td>约束名字（不需要唯一！）</td></tr><tr><td><code class="structfield">connamespace</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-namespace.html" title="51.32. pg_namespace"><code class="structname">pg_namespace</code></a>.oid</code></td><td>
       包含此约束的名字空间的OID
      </td></tr><tr><td><code class="structfield">contype</code></td><td><code class="type">char</code></td><td> </td><td>
        <code class="literal">c</code> = 检查约束，
        <code class="literal">f</code> = 外键约束，
        <code class="literal">p</code> = 主键约束，
        <code class="literal">u</code> = 唯一约束，
        <code class="literal">t</code> = 约束触发器，
        <code class="literal">x</code> = 排他约束
      </td></tr><tr><td><code class="structfield">condeferrable</code></td><td><code class="type">bool</code></td><td> </td><td>该约束是否能被延迟？</td></tr><tr><td><code class="structfield">condeferred</code></td><td><code class="type">bool</code></td><td> </td><td>该约束是否默认被延迟？</td></tr><tr><td><code class="structfield">convalidated</code></td><td><code class="type">bool</code></td><td> </td><td>此约束是否被验证过？当前对于外键和检查约束只能是假</td></tr><tr><td><code class="structfield">conrelid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-class.html" title="51.11. pg_class"><code class="structname">pg_class</code></a>.oid</code></td><td>该约束所在的表，如果不是表约束则为0</td></tr><tr><td><code class="structfield">contypid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-type.html" title="51.63. pg_type"><code class="structname">pg_type</code></a>.oid</code></td><td>该约束所在的域，如果不是域约束则为0</td></tr><tr><td><code class="structfield">conindid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-class.html" title="51.11. pg_class"><code class="structname">pg_class</code></a>.oid</code></td><td>如果该约束是唯一、主键、外键或排他约束，此列表示支持此约束的索引，否则为0</td></tr><tr><td><code class="structfield">conparentid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-constraint.html" title="51.13. pg_constraint"><code class="structname">pg_constraint</code></a>.oid</code></td><td>如果这是一个分区中的约束，则是父分区表中对应的约束；否则为0</td></tr><tr><td><code class="structfield">confrelid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-class.html" title="51.11. pg_class"><code class="structname">pg_class</code></a>.oid</code></td><td>如果此约束是一个外键约束，此列为被引用的表，否则为0</td></tr><tr><td><code class="structfield">confupdtype</code></td><td><code class="type">char</code></td><td> </td><td>外键更新动作代码：
            <code class="literal">a</code> = 无动作，
            <code class="literal">r</code> = 限制，
            <code class="literal">c</code> = 级联，
            <code class="literal">n</code> = 置空，
            <code class="literal">d</code> = 置为默认值
          </td></tr><tr><td><code class="structfield">confdeltype</code></td><td><code class="type">char</code></td><td> </td><td>外键删除动作代码：
            <code class="literal">a</code> = 无动作，
            <code class="literal">r</code> = 限制，
            <code class="literal">c</code> = 级联，
            <code class="literal">n</code> = 置空，
            <code class="literal">d</code> = 置为默认值
          </td></tr><tr><td><code class="structfield">confmatchtype</code></td><td><code class="type">char</code></td><td> </td><td>外键匹配类型：
            <code class="literal">f</code> = 完全，
            <code class="literal">p</code> = 部分，
            <code class="literal">s</code> = 简单
          </td></tr><tr><td><code class="structfield">conislocal</code></td><td><code class="type">bool</code></td><td> </td><td>
       此约束是定义在关系本地。注意一个约束可以同时是本地定义和继承。
      </td></tr><tr><td><code class="structfield">coninhcount</code></td><td><code class="type">int4</code></td><td> </td><td>
       此约束的直接继承祖先数目。一个此列非零的约束不能被删除或重命名。
      </td></tr><tr><td><code class="structfield">connoinherit</code></td><td><code class="type">bool</code></td><td> </td><td>
       为真表示此约束被定义在关系本地。它是一个不可继承约束。
      </td></tr><tr><td><code class="structfield">conkey</code></td><td><code class="type">int2[]</code></td><td><code class="literal"><a class="link" href="catalog-pg-attribute.html" title="51.7. pg_attribute"><code class="structname">pg_attribute</code></a>.attnum</code></td><td>如果是一个表约束（包括外键但不包括约束触发器），此列是被约束列的列表</td></tr><tr><td><code class="structfield">confkey</code></td><td><code class="type">int2[]</code></td><td><code class="literal"><a class="link" href="catalog-pg-attribute.html" title="51.7. pg_attribute"><code class="structname">pg_attribute</code></a>.attnum</code></td><td>如果是一个外键，此列是被引用列的列表</td></tr><tr><td><code class="structfield">conpfeqop</code></td><td><code class="type">oid[]</code></td><td><code class="literal"><a class="link" href="catalog-pg-operator.html" title="51.34. pg_operator"><code class="structname">pg_operator</code></a>.oid</code></td><td>如果是一个外键，此列是用于PK = FK比较的等值操作符的列表</td></tr><tr><td><code class="structfield">conppeqop</code></td><td><code class="type">oid[]</code></td><td><code class="literal"><a class="link" href="catalog-pg-operator.html" title="51.34. pg_operator"><code class="structname">pg_operator</code></a>.oid</code></td><td>如果是一个外键，此列是用于PK = PK比较的等值操作符的列表</td></tr><tr><td><code class="structfield">conffeqop</code></td><td><code class="type">oid[]</code></td><td><code class="literal"><a class="link" href="catalog-pg-operator.html" title="51.34. pg_operator"><code class="structname">pg_operator</code></a>.oid</code></td><td>如果是一个外键，此列是用于FK = FK比较的等值操作符的列表</td></tr><tr><td><code class="structfield">conexclop</code></td><td><code class="type">oid[]</code></td><td><code class="literal"><a class="link" href="catalog-pg-operator.html" title="51.34. pg_operator"><code class="structname">pg_operator</code></a>.oid</code></td><td>如果是一个排他约束，此列是没列排他操作符的列表</td></tr><tr><td><code class="structfield">conbin</code></td><td><code class="type">pg_node_tree</code></td><td> </td><td>如果是一个检查约束，此列是表达式的一个内部表示。建议使用 <code class="function">pg_get_constraintdef()</code>提取检查约束的定义。</td></tr></tbody></table></div></div><br class="table-break" /><p>
   在一个排他约束的情况中， <code class="structfield">conkey</code>只对约束元素是单一列引用时有用。对于其他情况，<code class="structfield">conkey</code>为0且必须查阅相关索引来发现被约束的表达式（<code class="structfield">conkey</code>因此和<code class="structname">pg_index</code>.<code class="structfield">indkey</code>具有相同的内容）。
  </p><div class="note"><h3 class="title">注意</h3><p>
    <code class="literal">pg_class.relchecks</code>需要和每个关系在此目录中的检查约束数量保持一致。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="catalog-pg-collation.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="catalogs.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="catalog-pg-conversion.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">51.12. <code class="structname">pg_collation</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 51.14. <code class="structname">pg_conversion</code></td></tr></table></div></body></html>