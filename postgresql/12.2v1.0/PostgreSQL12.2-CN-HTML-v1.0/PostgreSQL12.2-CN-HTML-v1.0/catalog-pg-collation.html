<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>51.12. pg_collation</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="catalog-pg-class.html" title="51.11. pg_class" /><link rel="next" href="catalog-pg-constraint.html" title="51.13. pg_constraint" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">51.12. <code xmlns="http://www.w3.org/1999/xhtml" class="structname">pg_collation</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="catalog-pg-class.html" title="51.11. pg_class">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="catalogs.html" title="第 51 章 系统目录">上一级</a></td><th width="60%" align="center">第 51 章 系统目录</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 12.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="catalog-pg-constraint.html" title="51.13. pg_constraint">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="CATALOG-PG-COLLATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">51.12. <code class="structname">pg_collation</code></h2></div></div></div><a id="id-1.10.4.14.2" class="indexterm"></a><p>
   目录<code class="structname">pg_collation</code>描述了可用的排序规则，其本质是从一个SQL名字到操作系统locale分类的映射。更多信息参见<a class="xref" href="collation.html" title="23.2. 排序规则支持">第 23.2 节</a>。
  </p><div class="table" id="id-1.10.4.14.4"><p class="title"><strong>表 51.12. <code class="structname">pg_collation</code>的列</strong></p><div class="table-contents"><table class="table" summary="pg_collation的列" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>类型</th><th>引用</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">oid</code></td><td><code class="type">oid</code></td><td> </td><td>行标识符</td></tr><tr><td><code class="structfield">collname</code></td><td><code class="type">name</code></td><td> </td><td>排序规则名字（在每一个名字空间和编码中唯一）</td></tr><tr><td><code class="structfield">collnamespace</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-namespace.html" title="51.32. pg_namespace"><code class="structname">pg_namespace</code></a>.oid</code></td><td>
       包含该排序规则的名字空间的OID
      </td></tr><tr><td><code class="structfield">collowner</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-authid.html" title="51.8. pg_authid"><code class="structname">pg_authid</code></a>.oid</code></td><td>排序规则的拥有者</td></tr><tr><td><code class="structfield">collprovider</code></td><td><code class="type">char</code></td><td> </td><td>排序规则的提供者：<code class="literal">d</code> = 数据库默认，<code class="literal">c</code> = libc，<code class="literal">i</code> = icu</td></tr><tr><td><code class="structfield">collisdeterministic</code></td><td><code class="type">bool</code></td><td> </td><td>排序规则是确定性的吗？</td></tr><tr><td><code class="structfield">collencoding</code></td><td><code class="type">int4</code></td><td> </td><td>该排序规则可应用的编码，-1表示它可用于任何编码</td></tr><tr><td><code class="structfield">collcollate</code></td><td><code class="type">name</code></td><td> </td><td>该排序规则对象的<code class="symbol">LC_COLLATE</code></td></tr><tr><td><code class="structfield">collctype</code></td><td><code class="type">name</code></td><td> </td><td>该排序规则对象的<code class="symbol">LC_CTYPE</code></td></tr><tr><td><code class="structfield">collversion</code></td><td><code class="type">text</code></td><td> </td><td>
       排序规则的提供者相关的版本。这是在排序规则创建时记录下来的，并且在使用排序规则时会被检查以检测可能导致数据损坏的排序规则定义的改变。
      </td></tr></tbody></table></div></div><br class="table-break" /><p>
   注意在这个目录中的唯一键是（<code class="structfield">collname</code>、
   <code class="structfield">collencoding</code>、 <code class="structfield">collnamespace</code>）， 不仅仅是（<code class="structfield">collname</code>，<code class="structfield">collnamespace</code>）。
   所有<code class="structfield">collencoding</code>不等于当前数据库编码或-1的编码规则通常都会被<span class="productname">PostgreSQL</span>忽略，且禁止创建和<code class="structfield">collencoding</code> = -1的项重名的项。因此使用一个受限的SQL名字（<em class="replaceable"><code>schema</code></em>.<em class="replaceable"><code>name</code></em>）来标识一个排序规则是足够的，即使这根据目录定义是不唯一的。以这种方式定义这个目录的原因是<span class="application">initdb</span>会在集簇初始化时使用系统上所有可用的locale填充这个目录，所以它必须能够为所有可能在集簇中使用的编码保持项。
  </p><p>
   在<code class="literal">template0</code>数据库中，创建与数据库编码不匹配的编码是有用的，因为它们可以匹配后面从<code class="literal">template0</code>克隆的数据库的编码。这在目前必须手动完成。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="catalog-pg-class.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="catalogs.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="catalog-pg-constraint.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">51.11. <code class="structname">pg_class</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 51.13. <code class="structname">pg_constraint</code></td></tr></table></div></body></html>