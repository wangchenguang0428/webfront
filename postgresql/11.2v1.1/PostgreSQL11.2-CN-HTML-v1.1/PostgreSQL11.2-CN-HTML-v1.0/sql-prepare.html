<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>PREPARE</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-notify.html" title="NOTIFY" /><link rel="next" href="sql-prepare-transaction.html" title="PREPARE TRANSACTION" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">PREPARE</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-notify.html" title="NOTIFY">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQL 命令">上一级</a></td><th width="60%" align="center">SQL 命令</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-prepare-transaction.html" title="PREPARE TRANSACTION">下一页</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-PREPARE"><div class="titlepage"></div><a id="id-1.9.3.158.1" class="indexterm"></a><a id="id-1.9.3.158.2" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">PREPARE</span></h2><p>PREPARE — 为执行准备一个语句</p></div><div class="refsynopsisdiv"><h2>大纲</h2><pre class="synopsis">
PREPARE <em class="replaceable"><code>name</code></em> [ ( <em class="replaceable"><code>data_type</code></em> [, ...] ) ] AS <em class="replaceable"><code>statement</code></em>
</pre></div><div class="refsect1" id="id-1.9.3.158.6"><h2>描述</h2><p>
   <code class="command">PREPARE</code>创建一个预备语句。预备语句是一种服务器端对象，它可以被用来优化性能。当<code class="command">PREPARE</code>语句被执行时，指定的语句会被解析、分析并且重写。当后续发出一个<code class="command">EXECUTE</code>命令时，该预备语句会被规划并且执行。这种工作的划分避免了重复性的解析分析工作，不过允许执行计划依赖所提供的特定参数值。
  </p><p>
   预备语句可以接受参数：在执行时会被替换到语句中的值。在创建预备语句时，可以用位置引用参数，如<code class="literal">$1</code>、<code class="literal">$2</code>等。也可以选择性地指定参数数据类型的一个列表。当一个参数的数据类型没有被指定或者被声明为<code class="literal">unknown</code>时，其类型会从该参数第一次被引用的环境中推知（如果可能）。在执行该语句时，在<code class="command">EXECUTE</code>语句中为这些参数指定实际值。更多有关于此的信息可参考<a class="xref" href="sql-execute.html" title="EXECUTE"><span class="refentrytitle">EXECUTE</span></a>。
  </p><p>
   预备语句只在当前数据库会话期间存在。当会话结束时，预备语句会消失，因此在重新使用之前必须重新建立它。这也意味着一个预备语句不能被多个数据库客户端同时使用。不过，每一个客户端可以创建它们自己的预备语句来使用。预备语句可以用<a class="xref" href="sql-deallocate.html" title="DEALLOCATE"><span class="refentrytitle">DEALLOCATE</span></a>命令手工清除。
  </p><p>
   当一个会话要执行大量类似语句时，预备语句可能会有最大性能优势。如果该语句很复杂（难于规划或重写），例如，如果查询涉及很多表的连接或者要求应用多个规则，性能差异将会特别明显。如果语句相对比较容易规划和重写，但是执行起来开销相对较大，那么预备语句的性能优势就不那么显著了。
  </p></div><div class="refsect1" id="id-1.9.3.158.7"><h2>参数</h2><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>name</code></em></span></dt><dd><p>
      给这个特定预备语句的任意名称。它在一个会话中必须唯一并且后续将被用来执行或者清除一个之前准备好的语句。
     </p></dd><dt><span class="term"><em class="replaceable"><code>data_type</code></em></span></dt><dd><p>
      预备语句一个参数的数据类型。如果一个特定参数的数据类型没有被指定或者被指定为<code class="literal">unknown</code>，将从该参数第一次被引用的环境中推得。要在预备语句本身中引用参数，可以使用
      <code class="literal">$1</code>、<code class="literal">$2</code>等。
     </p></dd><dt><span class="term"><em class="replaceable"><code>statement</code></em></span></dt><dd><p>
      任何<code class="command">SELECT</code>、<code class="command">INSERT</code>、<code class="command">UPDATE</code>、<code class="command">DELETE</code>或者<code class="command">VALUES</code>语句。
     </p></dd></dl></div></div><div class="refsect1" id="SQL-PREPARE-NOTES"><h2>注解</h2><p>
   对每一组提供的<code class="command">EXECUTE</code>值，预备语句可以使用通用计划而不是重新做计划。对于没有参数的预备语句马上就会这样做，否则只有五次或者更多次执行产生的计划的估计代价平均值（包括规划开销）比通用计划的代价估计更昂贵时才会这样做。一旦选中一个通用计划，在该预备语句剩余的生存时间内都将使用它。使用在重复值很多的列中很少出现的<code class="command">EXECUTE</code>值可以产生比通用计划更加廉价的定制计划（即使加上规划开销），这样通用计划将不会被使用。
  </p><p>
   通用计划假定每一个提供给<code class="command">EXECUTE</code>的值都是该列的可区分值并且列值是均匀分布的。例如，如果统计信息记录了三个可区分的列值，通用计划会假定一个列等值比较将匹配被处理行中的 33%。列统计值也允许通用计划准确地计算唯一列的选择度。如果一个通用计划被选中时，在非均匀分布列上的比较以及制定不存在的值都会影响平均计划代价。
  </p><p>
   要检查<span class="productname">PostgreSQL</span>为一个预备语句使用的查询计划，可以使用<a class="xref" href="sql-explain.html" title="EXPLAIN"><span class="refentrytitle">EXPLAIN</span></a>，例如<code class="command">EXPLAIN EXECUTE</code>。如果使用的是一个通用计划，它将包含参数符号<code class="literal">$<em class="replaceable"><code>n</code></em></code>，而一个定制计划则会把提供的参数值替换进去。通用计划中的行估计值反映了这些参数计算出来的选择度。
  </p><p>
   更多关于查询规划以及<span class="productname">PostgreSQL</span>为此所收集的统计信息的内容，请见<a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a>文档。
  </p><p>
   尽管预备语句主要是为了避免重复对语句进行解析分析以及规划，但是只要上一次使用该预备语句后该语句中用到的数据库对象发生了定义性（DDL）改变，<span class="productname">PostgreSQL</span>将会对该语句强制进行重新分析和重新规划。还有，如果<a class="xref" href="runtime-config-client.html#GUC-SEARCH-PATH">search_path</a>的值发生变化，也将使用新的<code class="varname">search_path</code>重新解析该语句（后一种行为是从<span class="productname">PostgreSQL</span> 9.3 开始的新行为）。这些规则让预备语句的使用在语义上几乎等效于反复提交相同的查询文本，但是能在性能上获利（如果没有对象定义被改变，特别是如果最优计划保持不变时）。该语义等价性不完美的一个例子是：如果语句用一个未限定的名称引用表，并且之后在<code class="varname">search_path</code>中更靠前的模式中创建了一个新的同名表，则不会发生自动的重解析，因为该语句使用的对象没有被改变。不过，如果某些其他更改造成了重解析，后续使用中都会引用新表。
  </p><p>
   可以通过查询<a class="link" href="view-pg-prepared-statements.html" title="52.76. pg_prepared_statements"><code class="structname">pg_prepared_statements</code></a>系统视图来看到会话中所有可用的预备语句。
  </p></div><div class="refsect1" id="SQL-PREPARE-EXAMPLES"><h2>例子</h2><p>
   为一个<code class="command">INSERT</code>语句创建一个预备语句，然后执行它：
</p><pre class="programlisting">
PREPARE fooplan (int, text, bool, numeric) AS
    INSERT INTO foo VALUES($1, $2, $3, $4);
EXECUTE fooplan(1, 'Hunter Valley', 't', 200.00);
</pre><p>
  </p><p>
   为一个<code class="command">SELECT</code>语句创建一个预备语句，然后执行它：
</p><pre class="programlisting">
PREPARE usrrptplan (int) AS
    SELECT * FROM users u, logs l WHERE u.usrid=$1 AND u.usrid=l.usrid
    AND l.date = $2;
EXECUTE usrrptplan(1, current_date);
</pre><p>

   注意第二个参数的数据类型没有被指定，因此会从使用<code class="literal">$2</code>的环境中推知。
  </p></div><div class="refsect1" id="id-1.9.3.158.10"><h2>兼容性</h2><p>
   SQL 标准包括一个<code class="command">PREPARE</code>语句，但是它只用于嵌入式 SQL。这个版本的<code class="command">PREPARE</code>语句也使用了一种有些不同的语法。
  </p></div><div class="refsect1" id="id-1.9.3.158.11"><h2>另见</h2><span class="simplelist"><a class="xref" href="sql-deallocate.html" title="DEALLOCATE"><span class="refentrytitle">DEALLOCATE</span></a>, <a class="xref" href="sql-execute.html" title="EXECUTE"><span class="refentrytitle">EXECUTE</span></a></span></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-notify.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-prepare-transaction.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">NOTIFY </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> PREPARE TRANSACTION</td></tr></table></div></body></html>