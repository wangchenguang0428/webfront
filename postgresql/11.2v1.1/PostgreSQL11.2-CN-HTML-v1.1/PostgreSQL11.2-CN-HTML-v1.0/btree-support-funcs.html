<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>63.3. B-树支持函数</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="btree-behavior.html" title="63.2. B-树操作符类的行为" /><link rel="next" href="btree-implementation.html" title="63.4. 实现" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">63.3. B-树支持函数</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="btree-behavior.html" title="63.2. B-树操作符类的行为">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="btree.html" title="第 63 章 B-树索引">上一级</a></td><th width="60%" align="center">第 63 章 B-树索引</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="btree-implementation.html" title="63.4. 实现">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="BTREE-SUPPORT-FUNCS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">63.3. B-树支持函数</h2></div></div></div><p>
  如<a class="xref" href="xindex.html#XINDEX-BTREE-SUPPORT-TABLE" title="表 38.8. B-树支持函数">表 38.8</a>中所示，btree定义了一种必需的和两种可选的支持函数。
 </p><p>
  对于btree操作符族为其提供了比较操作符的每一种数据类型组合，操作符族必须提供一个比较支持函数，在<code class="structname">pg_amproc</code>中注册：支持函数编号为1，<code class="structfield">amproclefttype</code>/<code class="structfield">amprocrighttype</code>等于比较的左右数据类型（即匹配的操作符注册在<code class="structname">pg_amop</code>中的数据类型）。比较函数必须接收两个非空值<em class="replaceable"><code>A</code></em>和<em class="replaceable"><code>B</code></em>并且返回一个<code class="type">int32</code>值，返回值在<em class="replaceable"><code>A</code></em> <code class="literal">&lt;</code> <em class="replaceable"><code>B</code></em>、<em class="replaceable"><code>A</code></em> <code class="literal">=</code> <em class="replaceable"><code>B</code></em>以及<em class="replaceable"><code>A</code></em> <code class="literal">&gt;</code> <em class="replaceable"><code>B</code></em>时分别为<code class="literal">&lt;</code> <code class="literal">0</code>、<code class="literal">0</code>和<code class="literal">&gt;</code> <code class="literal">0</code>。不允许空值结果：该数据类型的所有值必须是可比较的。例子请见<code class="filename">src/backend/access/nbtree/nbtcompare.c</code>。
 </p><p>
  如果被比较的值是一种可排序的数据类型，合适的排序规则OID将使用标准的PG_GET_COLLATION()机制被传递给比较支持函数。
 </p><p>
  可选地，btree操作符族可以提供<em class="firstterm">排序支持</em>函数，它们以支持函数编号2注册。这些函数允许以一种比单纯调用比较支持函数更加高效的方式实现排序比较。涉及的API在<code class="filename">src/include/utils/sortsupport.h</code>中定义。
 </p><a id="id-1.10.15.5.6" class="indexterm"></a><a id="id-1.10.15.5.7" class="indexterm"></a><p>
  可选地，btree操作符族可以提供<em class="firstterm">in_range</em>支持函数，它们以支持函数编号3注册。在btree索引操作期间不会用到这些函数，它们扩展了操作符族的语义，这样就能支持包含<code class="literal">RANGE</code> <em class="replaceable"><code>offset</code></em> <code class="literal">PRECEDING</code>以及<code class="literal">RANGE</code> <em class="replaceable"><code>offset</code></em> <code class="literal">FOLLOWING</code>窗口帧界类型（见<a class="xref" href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" title="4.2.8. 窗口函数调用">第 4.2.8 节</a>）的窗口子句。归根到底，这些函数所提供的额外信息是如何以一种与该操作符族的数据排序相兼容的方式加上或者减去一个<em class="replaceable"><code>offset</code></em>值。
 </p><p>
  一个<code class="function">in_range</code>函数必须具有这样的签名
</p><pre class="synopsis">
in_range(<em class="replaceable"><code>val</code></em> type1, <em class="replaceable"><code>base</code></em> type1, <em class="replaceable"><code>offset</code></em> type2, <em class="replaceable"><code>sub</code></em> bool, <em class="replaceable"><code>less</code></em> bool)
returns bool
</pre><p>
  <em class="replaceable"><code>val</code></em>和<em class="replaceable"><code>base</code></em>必须是同一种类型，该类型也是操作符族所支持的类型之一（即它提供排序的一种类型）。不过，<em class="replaceable"><code>offset</code></em>可以是一种不同的类型，该类型有可能不被该操作符族所支持。例如内建的<code class="literal">time_ops</code>族提供了一个<code class="function">in_range</code>函数，其<em class="replaceable"><code>offset</code></em>是类型<code class="type">interval</code>。一个操作符族可以为其所支持的任意类型提供<code class="function">in_range</code>函数以及一个或者更多种<em class="replaceable"><code>offset</code></em>类型。每一个<code class="function">in_range</code>函数在进入到<code class="structname">pg_amproc</code>时，需要有<code class="structfield">amproclefttype</code>等于<code class="type">type1</code>以及<code class="structfield">amprocrighttype</code>等于<code class="type">type2</code>。
 </p><p>
  <code class="function">in_range</code>函数的本质语义取决于两个布尔标志参数。它应该将<em class="replaceable"><code>base</code></em>和<em class="replaceable"><code>offset</code></em>相加或者相减，然后用<em class="replaceable"><code>val</code></em>与其结果比较：
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
     如果<code class="literal">!</code><em class="replaceable"><code>sub</code></em>并且<code class="literal">!</code><em class="replaceable"><code>less</code></em>，则返回<em class="replaceable"><code>val</code></em> <code class="literal">&gt;=</code> (<em class="replaceable"><code>base</code></em> <code class="literal">+</code> <em class="replaceable"><code>offset</code></em>)
    </p></li><li class="listitem"><p>
     如果<code class="literal">!</code><em class="replaceable"><code>sub</code></em>并且<em class="replaceable"><code>less</code></em>，则返回<em class="replaceable"><code>val</code></em> <code class="literal">&lt;=</code> (<em class="replaceable"><code>base</code></em> <code class="literal">+</code> <em class="replaceable"><code>offset</code></em>)
    </p></li><li class="listitem"><p>
     如果<em class="replaceable"><code>sub</code></em>并且<code class="literal">!</code><em class="replaceable"><code>less</code></em>，则返回<em class="replaceable"><code>val</code></em> <code class="literal">&gt;=</code> (<em class="replaceable"><code>base</code></em> <code class="literal">-</code> <em class="replaceable"><code>offset</code></em>)
    </p></li><li class="listitem"><p>
     如果<em class="replaceable"><code>sub</code></em>并且<em class="replaceable"><code>less</code></em>，则返回<em class="replaceable"><code>val</code></em> <code class="literal">&lt;=</code> (<em class="replaceable"><code>base</code></em> <code class="literal">-</code> <em class="replaceable"><code>offset</code></em>)
    </p></li></ul></div><p>
  在这样做之前，该函数应该检查<em class="replaceable"><code>offset</code></em>的符号：如果它小于零，则抛出错误<code class="literal">ERRCODE_INVALID_PRECEDING_OR_FOLLOWING_SIZE</code> (22013)外加<span class="quote">“<span class="quote">invalid preceding or following size in window function</span>”</span>这样的错误文本（这是SQL标准所要求的，不过非标准操作符族可能会选择忽视这一限制，因为似乎其语义必要性很小）。这种要求被委托给了<code class="function">in_range</code>函数，这样核心代码不需要理解对一种特定数据类型<span class="quote">“<span class="quote">less than zero</span>”</span>表示什么。
 </p><p>
  一个额外的期望是，如果可行，<code class="function">in_range</code>函数应当在<em class="replaceable"><code>base</code></em> <code class="literal">+</code> <em class="replaceable"><code>offset</code></em>或者<em class="replaceable"><code>base</code></em> <code class="literal">-</code> <em class="replaceable"><code>offset</code></em>溢出时避免抛出错误。即便值超过了该数据类型的范围，也可以确定正确的比较结果。注意，如果数据类型包括诸如<span class="quote">“<span class="quote">infinity</span>”</span>或者<span class="quote">“<span class="quote">NaN</span>”</span>之类的概念，就需要额外的注意确保<code class="function">in_range</code>的结果符合该操作符族的正常排序顺序。
 </p><p>
  <code class="function">in_range</code>函数的结果必须与操作符族施加的排序顺序保持一致。准确的来说，给定任意固定的<em class="replaceable"><code>offset</code></em>值以及<em class="replaceable"><code>sub</code></em>值，那么：
  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
     如果带有<em class="replaceable"><code>less</code></em> = true的<code class="function">in_range</code>对某个<em class="replaceable"><code>val1</code></em>和<em class="replaceable"><code>base</code></em>为真，则它必须对每一个有相同<em class="replaceable"><code>base</code></em>的<em class="replaceable"><code>val2</code></em> <code class="literal">&lt;=</code> <em class="replaceable"><code>val1</code></em>为真。
    </p></li><li class="listitem"><p>
     如果带有<em class="replaceable"><code>less</code></em> = true的<code class="function">in_range</code>对某个<em class="replaceable"><code>val1</code></em>和<em class="replaceable"><code>base</code></em>为假，则它必须对每一个有相同<em class="replaceable"><code>base</code></em>的<em class="replaceable"><code>val2</code></em> <code class="literal">&gt;=</code> <em class="replaceable"><code>val1</code></em>为假。
    </p></li><li class="listitem"><p>
     如果带有<em class="replaceable"><code>less</code></em> = true的<code class="function">in_range</code>对于某些<em class="replaceable"><code>val</code></em>和<em class="replaceable"><code>base1</code></em>为真,那么它对于每一个有相同<em class="replaceable"><code>val</code></em>的<em class="replaceable"><code>base2</code></em> <code class="literal">&gt;=</code> <em class="replaceable"><code>base1</code></em>也必须为真。
    </p></li><li class="listitem"><p>
     如果带有<em class="replaceable"><code>less</code></em> =
     true的<code class="function">in_range</code>对于某些<em class="replaceable"><code>val</code></em>和<em class="replaceable"><code>base1</code></em>为假, name它对于每一个有相同<em class="replaceable"><code>val</code></em>的<em class="replaceable"><code>base2</code></em> <code class="literal">&lt;=</code> <em class="replaceable"><code>base1</code></em>也必须为假。
    </p></li></ul></div><p>
  当<em class="replaceable"><code>less</code></em> = false时，类似的具有相逆条件的语句成立。
 </p><p>
  如果被排序的类型（<code class="type">type1</code>）是可排序的，合适的排序规则OID将使用标准的PG_GET_COLLATION()机制被传递给<code class="function">in_range</code>函数。
 </p><p>
  <code class="function">in_range</code>函数不需要处理NULL输入，并且通常将被标记为strict。
 </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="btree-behavior.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="btree.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="btree-implementation.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">63.2. B-树操作符类的行为 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 63.4. 实现</td></tr></table></div></body></html>