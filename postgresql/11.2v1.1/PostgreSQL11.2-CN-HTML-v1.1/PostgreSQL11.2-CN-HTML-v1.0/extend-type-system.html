<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>38.2. PostgreSQL类型系统</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="extend-how.html" title="38.1. 扩展性如何工作" /><link rel="next" href="xfunc.html" title="38.3. 用户定义的函数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">38.2. <span xmlns="http://www.w3.org/1999/xhtml" class="productname">PostgreSQL</span>类型系统</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="extend-how.html" title="38.1. 扩展性如何工作">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="extend.html" title="第 38 章 扩展 SQL">上一级</a></td><th width="60%" align="center">第 38 章 扩展 <acronym xmlns="http://www.w3.org/1999/xhtml" class="acronym">SQL</acronym></th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="xfunc.html" title="38.3. 用户定义的函数">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="EXTEND-TYPE-SYSTEM"><div class="titlepage"><div><div><h2 class="title" style="clear: both">38.2. <span class="productname">PostgreSQL</span>类型系统</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="extend-type-system.html#id-1.8.3.5.9">38.2.1. 基础类型</a></span></dt><dt><span class="sect2"><a href="extend-type-system.html#id-1.8.3.5.10">38.2.2. 容器类型</a></span></dt><dt><span class="sect2"><a href="extend-type-system.html#EXTEND-TYPE-SYSTEM-DOMAINS">38.2.3. 域</a></span></dt><dt><span class="sect2"><a href="extend-type-system.html#id-1.8.3.5.12">38.2.4. 伪类型</a></span></dt><dt><span class="sect2"><a href="extend-type-system.html#EXTEND-TYPES-POLYMORPHIC">38.2.5. 多态类型</a></span></dt></dl></div><a id="id-1.8.3.5.2" class="indexterm"></a><a id="id-1.8.3.5.3" class="indexterm"></a><a id="id-1.8.3.5.4" class="indexterm"></a><a id="id-1.8.3.5.5" class="indexterm"></a><a id="id-1.8.3.5.6" class="indexterm"></a><a id="id-1.8.3.5.7" class="indexterm"></a><p>
    <span class="productname">PostgreSQL</span>数据类型被划分为基础类型、容器类型、域和伪类型。
   </p><div class="sect2" id="id-1.8.3.5.9"><div class="titlepage"><div><div><h3 class="title">38.2.1. 基础类型</h3></div></div></div><p>
     基础类型是那些被实现在<acronym class="acronym">SQL</acronym>语言层面之下的类型（通常用一种底层语言，如 C），例如<code class="type">integer</code>。它们通常对应于常说的抽象数据类型。<span class="productname">PostgreSQL</span>只能通过由用户提供的函数在这类类型上操作，并且只能理解到用户描述这种类型行为的程度。<a class="xref" href="datatype.html" title="第 8 章 数据类型">第 8 章</a>中描述了内建的基础类型。
    </p><p>
     枚举（enum）类型可以被认为是基础类型的一个子类。主要区别是它们可以使用<acronym class="acronym">SQL</acronym>命令创建，不需要用到底层的编程。更多信息请参考<a class="xref" href="datatype-enum.html" title="8.7. 枚举类型">第 8.7 节</a>。
    </p></div><div class="sect2" id="id-1.8.3.5.10"><div class="titlepage"><div><div><h3 class="title">38.2.2. 容器类型</h3></div></div></div><p>
     <span class="productname">PostgreSQL</span>有三种<span class="quote">“<span class="quote">容器</span>”</span>类型，它们是包含多个其他类型值的类型。它们是数组、组合以及范围。
    </p><p>
     数组可以保存全部是同种类型的多个值。为每一种基本类型、组合类型、范围类型以及域类型都会自动创建一个数组类型。但是没有数组的数组。就类型系统的认知而言，多维数组就和一维数组一样。更多信息请参考<a class="xref" href="arrays.html" title="8.15. 数组">第 8.15 节</a>。
    </p><p>
     只要用户创建一个表，就会创建组合类型或者行类型。也可以使用<a class="xref" href="sql-createtype.html" title="CREATE TYPE"><span class="refentrytitle">CREATE TYPE</span></a>来定义一个没有关联表的<span class="quote">“<span class="quote">stand-alone</span>”</span>组合类型。一个组合类型只是一个具有相关域名称的类型列表。一个组合类型的值是一个行或者域值记录。用户可以访问来自<acronym class="acronym">SQL</acronym>查询的组成域。更多信息请参考<a class="xref" href="rowtypes.html" title="8.16. 组合类型">第 8.16 节</a>。
    </p><p>
     范围类型可以保存同种类型的两个值，它们是该范围的上下界。范围类型是用户创建的，不过也存在一些内建的范围类型。更多信息请参考<a class="xref" href="rangetypes.html" title="8.17. 范围类型">第 8.17 节</a>。
    </p></div><div class="sect2" id="EXTEND-TYPE-SYSTEM-DOMAINS"><div class="titlepage"><div><div><h3 class="title">38.2.3. 域</h3></div></div></div><p>
     一个域是基于一种特定底层类型的，并且出于很多目的它可以与其底层类型互换。不过，一个域能够具有约束来限制它的合法值于其底层基础类型允许值的一个子集。可以使用<acronym class="acronym">SQL</acronym>命令<a class="xref" href="sql-createdomain.html" title="CREATE DOMAIN"><span class="refentrytitle">CREATE DOMAIN</span></a>创建域。更多信息请参考<a class="xref" href="domains.html" title="8.18. 域类型">第 8.18 节</a>。
    </p></div><div class="sect2" id="id-1.8.3.5.12"><div class="titlepage"><div><div><h3 class="title">38.2.4. 伪类型</h3></div></div></div><p>
     有一些用于特殊目的<span class="quote">“<span class="quote">伪类型</span>”</span>。伪类型不能作为表列或者容器类型的组件出现，但是它们能被用于声明函数的参数和结果类型。这在类型系统中提供了一种机制来标识函数的特殊分类。<a class="xref" href="datatype-pseudo.html#DATATYPE-PSEUDOTYPES-TABLE" title="表 8.25. 伪类型">表 8.25</a>列出了现有的伪类型。
    </p></div><div class="sect2" id="EXTEND-TYPES-POLYMORPHIC"><div class="titlepage"><div><div><h3 class="title">38.2.5. 多态类型</h3></div></div></div><a id="id-1.8.3.5.13.2" class="indexterm"></a><a id="id-1.8.3.5.13.3" class="indexterm"></a><a id="id-1.8.3.5.13.4" class="indexterm"></a><a id="id-1.8.3.5.13.5" class="indexterm"></a><p>
     特别让人感兴趣的五种伪类型是<code class="type">anyelement</code>、<code class="type">anyarray</code>、<code class="type">anynonarray</code>、<code class="type">anyenum</code>以及<code class="type">anyrange</code>，它们被统称为<em class="firstterm">多态类型</em>。任何使用这些类型声明的函数被称作是一个<em class="firstterm">多态函数</em>。通过使用根据一次特定调用实际传递的数据类型所决定的相关数据类型，一个多态函数能够在多种不同数据类型上操作。
    </p><p>
     多态参数和结果是相互关联的，并且它们在解析调用多态函数的查询时被决定到一种特定的数据类型。每一个被声明为<code class="type">anyelement</code>的位置（参数或返回值）被允许具有任意特定的实际数据类型，但是在任何给定的查询中它们必须全部是<span class="emphasis"><em>相同</em></span>的实际类型。每一个被声明为<code class="type">anyarray</code>的位置可以有任意数组数据类型，但是相似地，它们必须全部具有相同类型。并且类似地，被声明为<code class="type">anyrange</code>的位置必须是全部是相同的范围类型。此外，如果有位置被声明为<code class="type">anyarray</code>并且其他位置被声明为<code class="type">anyelement</code>，<code class="type">anyarray</code>位置中的实际数组类型必须是一个数组，该数组的元素都是出现在<code class="type">anyelement</code>位置的同一种类型。相似地，如果有位置被声明为<code class="type">anyrange</code>并且其他位置被声明为<code class="type">anyelement</code>，<code class="type">anyrange</code>位置的实际范围类型必须是一个范围，该范围的子类型是出现在<code class="type">anyelement</code>位置的同一种类型。<code class="type">anynonarray</code>被当做和<code class="type">anyelement</code>相同，但是增加了额外的约束要求实际类型不能是一种数组类型。<code class="type">anyenum</code>被当做和<code class="type">anyelement</code>相同，但是增加了额外的约束要求实际类型不能是一种枚举类型。
    </p><p>
     因此，当使用一种多态类型声明了多于一个参数位置，有效效果是只有实际参数类型的某些组合才被允许。例如，一个被声明为<code class="literal">equal(anyelement, anyelement)</code>的函数将要求任意两个输入值，只要它们是同一种数据类型。
    </p><p>
     当一个函数的返回值被声明为多态类型时，必须至少有一个参数位置也是多态的，并且作为该参数提供的实际数据类型决定了该调用的实际结果类型。例如，如果还没有一种数组下标机制，我们可以定义一个函数来实现下标：<code class="literal">subscript(anyarray, integer) returns anyelement</code>。这个声明约束了实际的第一个参数是一种数组类型，并且允许解析器从实际的第一个参数类型推断正确的结果类型。另一个例子是一个被声明为<code class="literal">f(anyarray) returns anyenum</code>的函数将只接受枚举类型的数组。
    </p><p>
     注意<code class="type">anynonarray</code>和<code class="type">anyenum</code>并不表示独立的类型变量，它们是和<code class="type">anyelement</code>相同的类型，只是有一个额外的约束。例如，将一个函数声明为<code class="literal">f(anyelement, anyenum)</code>等效于把它声明为<code class="literal">f(anyenum, anyenum)</code>：两种实际参数必须是相同的枚举类型。
    </p><p>
     一个可变函数（可以有可变数量的参数，如<a class="xref" href="xfunc-sql.html#XFUNC-SQL-VARIADIC-FUNCTIONS" title="38.5.5. 带有可变数量参数的SQL函数">第 38.5.5 节</a>中所述）能够是多态的：这可以通过声明其最后一个参数为<code class="literal">VARIADIC</code> <code class="type">anyarray</code>来实现。为了匹配和决定实际结果类型的参数，这样一种函数的行为和写了合适数量的<code class="type">anynonarray</code>参数是一样的。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="extend-how.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="extend.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="xfunc.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">38.1. 扩展性如何工作 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 38.3. 用户定义的函数</td></tr></table></div></body></html>