<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>F.16. hstore</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="fuzzystrmatch.html" title="F.15. fuzzystrmatch" /><link rel="next" href="intagg.html" title="F.17. intagg" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">F.16. hstore</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="fuzzystrmatch.html" title="F.15. fuzzystrmatch">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="contrib.html" title="附录 F. 额外提供的模块">上一级</a></td><th width="60%" align="center">附录 F. 额外提供的模块</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="intagg.html" title="F.17. intagg">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="HSTORE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">F.16. hstore</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="hstore.html#id-1.11.7.25.4">F.16.1. <code class="type">hstore</code> 外部表示</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.25.5">F.16.2. <code class="type">hstore</code> 操作符和函数</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.25.6">F.16.3. 索引</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.25.7">F.16.4. 例子</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.25.8">F.16.5. 统计</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.25.9">F.16.6. 兼容性</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.25.10">F.16.7. 转换</a></span></dt><dt><span class="sect2"><a href="hstore.html#id-1.11.7.25.11">F.16.8. 作者</a></span></dt></dl></div><a id="id-1.11.7.25.2" class="indexterm"></a><p>
  这个模块实现了<code class="type">hstore</code>数据类型用来在一个单一<span class="productname">PostgreSQL</span>值中存储键值对。这在很多情景下都有用，例如带有很多很少被检查的属性的行或者半结构化数据。键和值都是简单的文本字符串。
 </p><div class="sect2" id="id-1.11.7.25.4"><div class="titlepage"><div><div><h3 class="title">F.16.1. <code class="type">hstore</code> 外部表示</h3></div></div></div><p>

   一个<code class="type">hstore</code>的文本表示用于输入和输出，包括零个或者多个由逗号分隔的<em class="replaceable"><code>key</code></em> <code class="literal">=&gt;</code> <em class="replaceable"><code>value</code></em>对。一些例子：

</p><pre class="synopsis">
k =&gt; v
foo =&gt; bar, baz =&gt; whatever
"1-a" =&gt; "anything at all"
</pre><p>

   键值对的顺序没有意义（并且在输出时也不会重现）。键值对之间或者<code class="literal">=&gt;</code>号周围的空白会被忽略。双引号内的键和值可以包括空白、逗号、<code class="literal">=</code>或<code class="literal">&gt;</code>。要在一个键或值中包括一个双引号或一个反斜线，用一个反斜线对它转义。
  </p><p>
   一个<code class="type">hstore</code>中的每一个键是唯一的。如果你声明了一个有重复键的<code class="type">hstore</code>，只有一个会被存储在<code class="type">hstore</code>中并且无法保证哪一个将被保留：

</p><pre class="programlisting">
SELECT 'a=&gt;1,a=&gt;2'::hstore;
  hstore
----------
 "a"=&gt;"1"
</pre><p>
  </p><p>
   一个值（但不是一个键）能够是一个 SQL <code class="literal">NULL</code>。例如：

</p><pre class="programlisting">
key =&gt; NULL
</pre><p>

   <code class="literal">NULL</code>关键词是大小写不敏感的。将<code class="literal">NULL</code>放在双引号中可以将它当作一个普通的字符串<span class="quote">“<span class="quote">NULL</span>”</span>。
  </p><div class="note"><h3 class="title">注意</h3><p>
   记住当<code class="type">hstore</code>文本格式当被用于输入时，它应用在任何必须的引用或转义<span class="emphasis"><em>之前</em></span>。如果你通过一个参数传递一个<code class="type">hstore</code>文字，那么不需要额外的处理。但是如果你将它作为一个引用的文字常数，那么任何单引号字符以及（取决于<code class="varname">standard_conforming_strings</code>配置参数的设置）反斜线字符需要被正确地转义。更多关于处理字符串常量的处理可见<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS" title="4.1.2.1. 字符串常量">第 4.1.2.1 节</a>。
  </p></div><p>
   在输出时，双引号总是围绕着键和值，即使这样做不是绝对必要。
  </p></div><div class="sect2" id="id-1.11.7.25.5"><div class="titlepage"><div><div><h3 class="title">F.16.2. <code class="type">hstore</code> 操作符和函数</h3></div></div></div><p>
   <code class="literal">hstore</code>模块所提供的操作符显示在<a class="xref" href="hstore.html#HSTORE-OP-TABLE" title="表 F.7. hstore 操作符">表 F.7</a>中，函数在<a class="xref" href="hstore.html#HSTORE-FUNC-TABLE" title="表 F.8. hstore 函数">表 F.8</a>中。
  </p><div class="table" id="HSTORE-OP-TABLE"><p class="title"><strong>表 F.7. <code class="type">hstore</code> 操作符</strong></p><div class="table-contents"><table class="table" summary="hstore 操作符" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>操作符</th><th>描述</th><th>例子</th><th>结果</th></tr></thead><tbody><tr><td><code class="type">hstore</code> <code class="literal">-&gt;</code> <code class="type">text</code></td><td>为键得到值（不存在则是<code class="literal">NULL</code>）</td><td><code class="literal">'a=&gt;x, b=&gt;y'::hstore -&gt; 'a'</code></td><td><code class="literal">x</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">-&gt;</code> <code class="type">text[]</code></td><td>为多个键得到值（不存在则是<code class="literal">NULL</code>）</td><td><code class="literal">'a=&gt;x, b=&gt;y, c=&gt;z'::hstore -&gt; ARRAY['c','a']</code></td><td><code class="literal">{"z","x"}</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">||</code> <code class="type">hstore</code></td><td>串接<code class="type">hstore</code></td><td><code class="literal">'a=&gt;b, c=&gt;d'::hstore || 'c=&gt;x, d=&gt;q'::hstore</code></td><td><code class="literal">"a"=&gt;"b", "c"=&gt;"x", "d"=&gt;"q"</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">?</code> <code class="type">text</code></td><td><code class="type">hstore</code>是否包含键？</td><td><code class="literal">'a=&gt;1'::hstore ? 'a'</code></td><td><code class="literal">t</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">?&amp;</code> <code class="type">text[]</code></td><td><code class="type">hstore</code>是否包含所有指定的键？</td><td><code class="literal">'a=&gt;1,b=&gt;2'::hstore ?&amp; ARRAY['a','b']</code></td><td><code class="literal">t</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">?|</code> <code class="type">text[]</code></td><td><code class="type">hstore</code>是否包含任何指定的键？</td><td><code class="literal">'a=&gt;1,b=&gt;2'::hstore ?| ARRAY['b','c']</code></td><td><code class="literal">t</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">@&gt;</code> <code class="type">hstore</code></td><td>左操作数是否包含右操作数？</td><td><code class="literal">'a=&gt;b, b=&gt;1, c=&gt;NULL'::hstore @&gt; 'b=&gt;1'</code></td><td><code class="literal">t</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">&lt;@</code> <code class="type">hstore</code></td><td>左操作数是否被包含在右操作数中？</td><td><code class="literal">'a=&gt;c'::hstore &lt;@ 'a=&gt;b, b=&gt;1, c=&gt;NULL'</code></td><td><code class="literal">f</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">-</code> <code class="type">text</code></td><td>从左操作数中删除键</td><td><code class="literal">'a=&gt;1, b=&gt;2, c=&gt;3'::hstore - 'b'::text</code></td><td><code class="literal">"a"=&gt;"1", "c"=&gt;"3"</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">-</code> <code class="type">text[]</code></td><td>从左操作数中删除多个键</td><td><code class="literal">'a=&gt;1, b=&gt;2, c=&gt;3'::hstore - ARRAY['a','b']</code></td><td><code class="literal">"c"=&gt;"3"</code></td></tr><tr><td><code class="type">hstore</code> <code class="literal">-</code> <code class="type">hstore</code></td><td>从左操作数中删除匹配的对</td><td><code class="literal">'a=&gt;1, b=&gt;2, c=&gt;3'::hstore - 'a=&gt;4, b=&gt;2'::hstore</code></td><td><code class="literal">"a"=&gt;"1", "c"=&gt;"3"</code></td></tr><tr><td><code class="type">record</code> <code class="literal">#=</code> <code class="type">hstore</code></td><td>用来自<code class="type">hstore</code>的匹配值替换<code class="type">record</code>中的域</td><td>见示例小节</td><td> </td></tr><tr><td><code class="literal">%%</code> <code class="type">hstore</code></td><td>把<code class="type">hstore</code>转换成键和值交替出现的数组</td><td><code class="literal">%% 'a=&gt;foo, b=&gt;bar'::hstore</code></td><td><code class="literal">{a,foo,b,bar}</code></td></tr><tr><td><code class="literal">%#</code> <code class="type">hstore</code></td><td>把<code class="type">hstore</code>转换成二维的键值数组</td><td><code class="literal">%# 'a=&gt;foo, b=&gt;bar'::hstore</code></td><td><code class="literal">{{a,foo},{b,bar}}</code></td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注意</h3><p>
   在 PostgreSQL 8.2 之前，包含操作符<code class="literal">@&gt;</code>和<code class="literal">&lt;@</code>分别被称为<code class="literal">@</code>和<code class="literal">~</code>。这些名称仍然可用，但是已经被弃用并且最终将被移除。注意，旧名称和原来核心几何数据类型所遵循的习惯是相反的！
   </p></div><div class="table" id="HSTORE-FUNC-TABLE"><p class="title"><strong>表 F.8. <code class="type">hstore</code> 函数</strong></p><div class="table-contents"><table class="table" summary="hstore 函数" border="1"><colgroup><col /><col /><col /><col /><col /></colgroup><thead><tr><th>函数</th><th>返回类型</th><th>描述</th><th>例子</th><th>结果</th></tr></thead><tbody><tr><td><code class="function">hstore(record)</code><a id="id-1.11.7.25.5.5.2.2.1.1.2" class="indexterm"></a></td><td><code class="type">hstore</code></td><td>从一个记录或行构造一个<code class="type">hstore</code></td><td><code class="literal">hstore(ROW(1,2))</code></td><td><code class="literal">f1=&gt;1,f2=&gt;2</code></td></tr><tr><td><code class="function">hstore(text[])</code></td><td><code class="type">hstore</code></td><td>从一个数组构造一个<code class="type">hstore</code>，数组可以是一个键值数组或者一个二维数组</td><td><code class="literal">hstore(ARRAY['a','1','b','2']) || hstore(ARRAY[['c','3'],['d','4']])</code></td><td><code class="literal">a=&gt;1, b=&gt;2, c=&gt;3, d=&gt;4</code></td></tr><tr><td><code class="function">hstore(text[], text[])</code></td><td><code class="type">hstore</code></td><td>从独立的键和值数组构建一个<code class="type">hstore</code></td><td><code class="literal">hstore(ARRAY['a','b'], ARRAY['1','2'])</code></td><td><code class="literal">"a"=&gt;"1","b"=&gt;"2"</code></td></tr><tr><td><code class="function">hstore(text, text)</code></td><td><code class="type">hstore</code></td><td>构造单一项的<code class="type">hstore</code></td><td><code class="literal">hstore('a', 'b')</code></td><td><code class="literal">"a"=&gt;"b"</code></td></tr><tr><td><code class="function">akeys(hstore)</code><a id="id-1.11.7.25.5.5.2.2.5.1.2" class="indexterm"></a></td><td><code class="type">text[]</code></td><td>取得<code class="type">hstore</code>的键作为一个数组</td><td><code class="literal">akeys('a=&gt;1,b=&gt;2')</code></td><td><code class="literal">{a,b}</code></td></tr><tr><td><code class="function">skeys(hstore)</code><a id="id-1.11.7.25.5.5.2.2.6.1.2" class="indexterm"></a></td><td><code class="type">setof text</code></td><td>取得<code class="type">hstore</code>的键作为一个集合</td><td><code class="literal">skeys('a=&gt;1,b=&gt;2')</code></td><td>
<pre class="programlisting">
a
b
</pre></td></tr><tr><td><code class="function">avals(hstore)</code><a id="id-1.11.7.25.5.5.2.2.7.1.2" class="indexterm"></a></td><td><code class="type">text[]</code></td><td>取得<code class="type">hstore</code>的值作为一个数组</td><td><code class="literal">avals('a=&gt;1,b=&gt;2')</code></td><td><code class="literal">{1,2}</code></td></tr><tr><td><code class="function">svals(hstore)</code><a id="id-1.11.7.25.5.5.2.2.8.1.2" class="indexterm"></a></td><td><code class="type">setof text</code></td><td>取得<code class="type">hstore</code>的值作为一个集合</td><td><code class="literal">svals('a=&gt;1,b=&gt;2')</code></td><td>
<pre class="programlisting">
1
2
</pre></td></tr><tr><td><code class="function">hstore_to_array(hstore)</code><a id="id-1.11.7.25.5.5.2.2.9.1.2" class="indexterm"></a></td><td><code class="type">text[]</code></td><td>取得<code class="type">hstore</code>的键和值作为一个键和值交替出现的数组</td><td><code class="literal">hstore_to_array('a=&gt;1,b=&gt;2')</code></td><td><code class="literal">{a,1,b,2}</code></td></tr><tr><td><code class="function">hstore_to_matrix(hstore)</code><a id="id-1.11.7.25.5.5.2.2.10.1.2" class="indexterm"></a></td><td><code class="type">text[]</code></td><td>取得<code class="type">hstore</code>的键和值作为一个二维的数组</td><td><code class="literal">hstore_to_matrix('a=&gt;1,b=&gt;2')</code></td><td><code class="literal">{{a,1},{b,2}}</code></td></tr><tr><td><code class="function">hstore_to_json(hstore)</code><a id="id-1.11.7.25.5.5.2.2.11.1.2" class="indexterm"></a></td><td><code class="type">json</code></td><td>取得<code class="type">hstore</code>作为一个<code class="type">json</code>值，把所有非空值转换为 JSON 字符串</td><td><code class="literal">hstore_to_json('"a key"=&gt;1, b=&gt;t, c=&gt;null, d=&gt;12345, e=&gt;012345, f=&gt;1.234, g=&gt;2.345e+4')</code></td><td><code class="literal">{"a key": "1", "b": "t", "c": null, "d": "12345", "e": "012345", "f": "1.234", "g": "2.345e+4"}</code></td></tr><tr><td><code class="function">hstore_to_jsonb(hstore)</code><a id="id-1.11.7.25.5.5.2.2.12.1.2" class="indexterm"></a></td><td><code class="type">jsonb</code></td><td>取得<code class="type">hstore</code>作为一个<code class="type">jsonb</code>值，把把所有非空值转换为 JSON 字符串</td><td><code class="literal">hstore_to_jsonb('"a key"=&gt;1, b=&gt;t, c=&gt;null, d=&gt;12345, e=&gt;012345, f=&gt;1.234, g=&gt;2.345e+4')</code></td><td><code class="literal">{"a key": "1", "b": "t", "c": null, "d": "12345", "e": "012345", "f": "1.234", "g": "2.345e+4"}</code></td></tr><tr><td><code class="function">hstore_to_json_loose(hstore)</code><a id="id-1.11.7.25.5.5.2.2.13.1.2" class="indexterm"></a></td><td><code class="type">json</code></td><td>取得<code class="type">hstore</code>作为一个<code class="type">json</code>值，但是尝试区分数字值和布尔值这样它们在 JSON 中无需引用</td><td><code class="literal">hstore_to_json_loose('"a key"=&gt;1, b=&gt;t, c=&gt;null, d=&gt;12345, e=&gt;012345, f=&gt;1.234, g=&gt;2.345e+4')</code></td><td><code class="literal">{"a key": 1, "b": true, "c": null, "d": 12345, "e": "012345", "f": 1.234, "g": 2.345e+4}</code></td></tr><tr><td><code class="function">hstore_to_jsonb_loose(hstore)</code><a id="id-1.11.7.25.5.5.2.2.14.1.2" class="indexterm"></a></td><td><code class="type">jsonb</code></td><td>取得<code class="type">hstore</code>作为一个<code class="type">jsonb</code>值，但是尝试区分数字值和布尔值这样它们在 JSON 中无需引用</td><td><code class="literal">hstore_to_jsonb_loose('"a key"=&gt;1, b=&gt;t, c=&gt;null, d=&gt;12345, e=&gt;012345, f=&gt;1.234, g=&gt;2.345e+4')</code></td><td><code class="literal">{"a key": 1, "b": true, "c": null, "d": 12345, "e": "012345", "f": 1.234, "g": 2.345e+4}</code></td></tr><tr><td><code class="function">slice(hstore, text[])</code><a id="id-1.11.7.25.5.5.2.2.15.1.2" class="indexterm"></a></td><td><code class="type">hstore</code></td><td>从一个<code class="type">hstore</code>抽取一个子集</td><td><code class="literal">slice('a=&gt;1,b=&gt;2,c=&gt;3'::hstore, ARRAY['b','c','x'])</code></td><td><code class="literal">"b"=&gt;"2", "c"=&gt;"3"</code></td></tr><tr><td><code class="function">each(hstore)</code><a id="id-1.11.7.25.5.5.2.2.16.1.2" class="indexterm"></a></td><td><code class="type">setof(key text, value text)</code></td><td>取得<code class="type">hstore</code>的键和值作为一个集合</td><td><code class="literal">select * from each('a=&gt;1,b=&gt;2')</code></td><td>
<pre class="programlisting">
 key | value
-----+-------
 a   | 1
 b   | 2
</pre></td></tr><tr><td><code class="function">exist(hstore,text)</code><a id="id-1.11.7.25.5.5.2.2.17.1.2" class="indexterm"></a></td><td><code class="type">boolean</code></td><td><code class="type">hstore</code>是否包含键？</td><td><code class="literal">exist('a=&gt;1','a')</code></td><td><code class="literal">t</code></td></tr><tr><td><code class="function">defined(hstore,text)</code><a id="id-1.11.7.25.5.5.2.2.18.1.2" class="indexterm"></a></td><td><code class="type">boolean</code></td><td><code class="type">hstore</code>是否为键包含非<code class="literal">NULL</code>值？</td><td><code class="literal">defined('a=&gt;NULL','a')</code></td><td><code class="literal">f</code></td></tr><tr><td><code class="function">delete(hstore,text)</code><a id="id-1.11.7.25.5.5.2.2.19.1.2" class="indexterm"></a></td><td><code class="type">hstore</code></td><td>删除匹配键的对</td><td><code class="literal">delete('a=&gt;1,b=&gt;2','b')</code></td><td><code class="literal">"a"=&gt;"1"</code></td></tr><tr><td><code class="function">delete(hstore,text[])</code></td><td><code class="type">hstore</code></td><td>删除匹配多个键的多个对</td><td><code class="literal">delete('a=&gt;1,b=&gt;2,c=&gt;3',ARRAY['a','b'])</code></td><td><code class="literal">"c"=&gt;"3"</code></td></tr><tr><td><code class="function">delete(hstore,hstore)</code></td><td><code class="type">hstore</code></td><td>删除匹配第二个参数的对</td><td><code class="literal">delete('a=&gt;1,b=&gt;2','a=&gt;4,b=&gt;2'::hstore)</code></td><td><code class="literal">"a"=&gt;"1"</code></td></tr><tr><td><code class="function">populate_record(record,hstore)</code><a id="id-1.11.7.25.5.5.2.2.22.1.2" class="indexterm"></a></td><td><code class="type">record</code></td><td>用来自<code class="type">hstore</code>的匹配值替换<code class="type">record</code>中的域</td><td>见示例小节</td><td> </td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注意</h3><p>
     当一个<code class="type">hstore</code>值被造型成<code class="type">json</code>时，将使用函数<code class="function">hstore_to_json</code>。同样地，当一个<code class="type">hstore</code>值被造型成<code class="type">jsonb</code>时，将使用函数<code class="function">hstore_to_jsonb</code>。
   </p></div><div class="note"><h3 class="title">注意</h3><p>
    函数<code class="function">populate_record</code>实际上被声明为第一个参数为<code class="type">anyelement</code>而非<code class="type">record</code>，但是它将会用一个运行时错误拒绝非记录类型。
   </p></div></div><div class="sect2" id="id-1.11.7.25.6"><div class="titlepage"><div><div><h3 class="title">F.16.3. 索引</h3></div></div></div><p>
   <code class="type">hstore</code>有对<code class="literal">@&gt;</code>、<code class="literal">?</code>、<code class="literal">?&amp;</code>和<code class="literal">?|</code>操作符的 GiST 和 GIN 索引支持。例如：
  </p><pre class="programlisting">
CREATE INDEX hidx ON testhstore USING GIST (h);

CREATE INDEX hidx ON testhstore USING GIN (h);
</pre><p>
   <code class="type">hstore</code>也为<code class="literal">=</code>操作符支持<code class="type">btree</code>或<code class="type">hash</code>索引。这允许<code class="type">hstore</code>列被声明为<code class="literal">UNIQUE</code>或者被使用在<code class="literal">GROUP BY</code>、<code class="literal">ORDER BY</code>或<code class="literal">DISTINCT</code>表达式中。<code class="type">hstore</code>值的排序顺序不是特别有用，但是这些索引可能对等值查找有用。为<code class="literal">=</code>比较创建以下索引：
  </p><pre class="programlisting">
CREATE INDEX hidx ON testhstore USING BTREE (h);

CREATE INDEX hidx ON testhstore USING HASH (h);
</pre></div><div class="sect2" id="id-1.11.7.25.7"><div class="titlepage"><div><div><h3 class="title">F.16.4. 例子</h3></div></div></div><p>
   增加一个键，或者用一个新值更新一个现有的键：
</p><pre class="programlisting">
UPDATE tab SET h = h || hstore('c', '3');
</pre><p>
  </p><p>
   删除一个键：
</p><pre class="programlisting">
UPDATE tab SET h = delete(h, 'k1');
</pre><p>
  </p><p>
   将一个<code class="type">record</code>转换成一个<code class="type">hstore</code>：
</p><pre class="programlisting">
CREATE TABLE test (col1 integer, col2 text, col3 text);
INSERT INTO test VALUES (123, 'foo', 'bar');

SELECT hstore(t) FROM test AS t;
                   hstore                    
---------------------------------------------
 "col1"=&gt;"123", "col2"=&gt;"foo", "col3"=&gt;"bar"
(1 row)
</pre><p>
  </p><p>
   将一个<code class="type">hstore</code>转换成一个预定义的<code class="type">record</code>类型：
</p><pre class="programlisting">
CREATE TABLE test (col1 integer, col2 text, col3 text);

SELECT * FROM populate_record(null::test,
                              '"col1"=&gt;"456", "col2"=&gt;"zzz"');
 col1 | col2 | col3 
------+------+------
  456 | zzz  | 
(1 row)
</pre><p>
  </p><p>
   用来自于一个<code class="type">hstore</code>的值修改一个现有的记录：
</p><pre class="programlisting">
CREATE TABLE test (col1 integer, col2 text, col3 text);
INSERT INTO test VALUES (123, 'foo', 'bar');

SELECT (r).* FROM (SELECT t #= '"col3"=&gt;"baz"' AS r FROM test t) s;
 col1 | col2 | col3 
------+------+------
  123 | foo  | baz
(1 row)
</pre><p>
  </p></div><div class="sect2" id="id-1.11.7.25.8"><div class="titlepage"><div><div><h3 class="title">F.16.5. 统计</h3></div></div></div><p>
   由于<code class="type">hstore</code>类型本质的宽大性，它能够包含一些不同的键。检查合法键是应用的任务。下列例子验证了用于检查键以及获得统计的一些技术。
  </p><p>
   简单例子：
</p><pre class="programlisting">
SELECT * FROM each('aaa=&gt;bq, b=&gt;NULL, ""=&gt;1');
</pre><p>
  </p><p>
   使用一个表：
</p><pre class="programlisting">
SELECT (each(h)).key, (each(h)).value INTO stat FROM testhstore;
</pre><p>
  </p><p>
   在线统计：
</p><pre class="programlisting">
SELECT key, count(*) FROM
  (SELECT (each(h)).key FROM testhstore) AS stat
  GROUP BY key
  ORDER BY count DESC, key;
    key    | count
-----------+-------
 line      |   883
 query     |   207
 pos       |   203
 node      |   202
 space     |   197
 status    |   195
 public    |   194
 title     |   190
 org       |   189
...................
</pre><p>
  </p></div><div class="sect2" id="id-1.11.7.25.9"><div class="titlepage"><div><div><h3 class="title">F.16.6. 兼容性</h3></div></div></div><p>
   从 PostgreSQL 9.0 开始，<code class="type">hstore</code>使用了与之前版本不同的内部表示。这不会为转储/恢复升级造成障碍，因为文本表示（用于转储）没有改变。
  </p><p>
   在一次二进制升级中，通过让新代码识别旧格式数据来维持向上兼容。当处理还没有被新代码修改过的数据时，这会带来一定的性能惩罚。可以通过执行一个下面的<code class="literal">UPDATE</code>语句来强制升级表中的所有值：
</p><pre class="programlisting">
UPDATE tablename SET hstorecol = hstorecol || '';
</pre><p>
  </p><p>
   另一种方法：
</p><pre class="programlisting">
ALTER TABLE tablename ALTER hstorecol TYPE hstore USING hstorecol || '';
</pre><p>
   <code class="command">ALTER TABLE</code>方法要求表上的一个排他锁，但是不会导致表因为旧行版本而膨胀。
  </p></div><div class="sect2" id="id-1.11.7.25.10"><div class="titlepage"><div><div><h3 class="title">F.16.7. 转换</h3></div></div></div><p>
   有一些额外的扩展为语言 PL/Perl 和 PL/Python 实现了<code class="type">hstore</code>
   类型的转换。用于 PL/Perl 的扩展叫做<code class="literal">hstore_plperl</code>和
   <code class="literal">hstore_plperlu</code>，分别用于可信的和不可信的 PL/Perl。
   如果安装这些转换并且在创建函数时指定它们，<code class="type">hstore</code>值会被
   映射成 Perl 哈希。用于 PL/Python 的扩展是<code class="literal">hstore_plpythonu</code>、
   <code class="literal">hstore_plpython2u</code>和<code class="literal">hstore_plpython3u</code>（
   PL/Python 命名习惯见<a class="xref" href="plpython-python23.html" title="46.1. Python 2 vs. Python 3">第 46.1 节</a>）。如果使用它们，
   <code class="type">hstore</code>值会被映射成 Python 字典。
  </p></div><div class="sect2" id="id-1.11.7.25.11"><div class="titlepage"><div><div><h3 class="title">F.16.8. 作者</h3></div></div></div><p>
   Oleg Bartunov <code class="email">&lt;<a class="email" href="mailto:oleg@sai.msu.su">oleg@sai.msu.su</a>&gt;</code>，俄罗斯莫斯科大学
  </p><p>
   Teodor Sigaev <code class="email">&lt;<a class="email" href="mailto:teodor@sigaev.ru">teodor@sigaev.ru</a>&gt;</code>，俄罗斯德尔塔软件有限公司
  </p><p>
   额外的提升由英国的 Andrew Gierth <code class="email">&lt;<a class="email" href="mailto:andrew@tao11.riddles.org.uk">andrew@tao11.riddles.org.uk</a>&gt;</code> 提供
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="fuzzystrmatch.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="contrib.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="intagg.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">F.15. fuzzystrmatch </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> F.17. intagg</td></tr></table></div></body></html>