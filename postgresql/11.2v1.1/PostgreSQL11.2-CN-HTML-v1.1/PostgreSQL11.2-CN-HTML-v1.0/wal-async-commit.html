<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>30.3. 异步提交</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="wal-intro.html" title="30.2. 预写式日志（WAL）" /><link rel="next" href="wal-configuration.html" title="30.4. WAL配置" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">30.3. 异步提交</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="wal-intro.html" title="30.2. 预写式日志（WAL）">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="wal.html" title="第 30 章 可靠性和预写式日志">上一级</a></td><th width="60%" align="center">第 30 章 可靠性和预写式日志</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="wal-configuration.html" title="30.4. WAL配置">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="WAL-ASYNC-COMMIT"><div class="titlepage"><div><div><h2 class="title" style="clear: both">30.3. 异步提交</h2></div></div></div><a id="id-1.6.17.5.2" class="indexterm"></a><a id="id-1.6.17.5.3" class="indexterm"></a><p>
   <em class="firstterm">异步提交</em>是一个允许事务能更快完成的选项，代价是在数据库崩溃时最近的事务会丢失。在很多应用中这是一个可接受的交换。
  </p><p>
   如前一节所述，事务提交通常是<em class="firstterm">同步的</em>：服务器等到事务的<acronym class="acronym">WAL</acronym>记录被刷写到持久存储之后才向客户端返回成功指示。因此客户端可以确保那些报告已被提交的事务确会被保存，即便随后马上发生了一次服务器崩溃。但是，对于短事务来说这种延迟是其总执行时间的主要部分。选择异步提交模式意味着服务器将在事务被逻辑上提交后立刻返回成功，而此时由它生成的<acronym class="acronym">WAL</acronym>记录还没有被真正地写到磁盘上。这将为小型事务的生产力产生显著地提升。
  </p><p>
   异步提交会带来数据丢失的风险。在向客户端报告事务完成到事务真正被提交（即能保证服务器崩溃时它也不会被丢失）之间有一个短的时间窗口。因此如果客户端将会做一些要求其事务被记住的外部动作，就不应该用异步提交。例如，一个银行肯定不会使用异步提交事务来记录一台ATM的现金分发。但是在很多情境中不需要这种强的保证，例如事件日志。
  </p><p>
   使用异步提交带来的风险是数据丢失，而不是数据损坏。如果数据库可能崩溃，它会通过重放<acronym class="acronym">WAL</acronym>到被刷写的最后一个记录来进行恢复。数据库将因此被恢复到一个自身一致状态，但是任何还没有被刷写到磁盘的事务将不会反映在该状态中。因此其影响就是丢失了最后的少量事务。由于事务按照提交顺序被重放，所以不会出现任何不一致性 — 例如一个事务B按照前面一个事务A的效果来进行修改，则不会出现A的效果丢失而B的效果被保留的情况。
  </p><p>
   用户可以选择每一个事务的提交模式，这样可以有同步提交和异步提交的事务并行运行。这允许我们灵活地在性能和事务持久性之间进行权衡。提交模式由用户可设置的参数<a class="xref" href="runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT">synchronous_commit</a>控制，它可以使用任何一种修改配置参数的方法进行设置。一个事务真正使用的提交模式取决于当事务提交开始时<code class="varname">synchronous_commit</code>的值。
  </p><p>
   特定的实用命令，如<code class="command">DROP TABLE</code>，被强制按照同步提交而不考虑<code class="varname">synchronous_commit</code>的设定。这是为了确保服务器文件系统和数据库逻辑状态之间的一致性。支持两阶段提交的命令页总是同步提交的，如<code class="command">PREPARE TRANSACTION</code>。
  </p><p>
   如果数据库在异步提交和事务<acronym class="acronym">WAL</acronym>记录写入之间的风险窗口期间崩溃，在该事务期间所作的修改<span class="emphasis"><em>将</em></span>丢失。风险窗口的持续时间是有限制的，因为一个后台进程（<span class="quote">“<span class="quote">WAL写进程</span>”</span>）每<a class="xref" href="runtime-config-wal.html#GUC-WAL-WRITER-DELAY">wal_writer_delay</a>毫秒会把未写入的<acronym class="acronym">WAL</acronym>记录刷写到磁盘。风险窗口实际的最大持续时间是<code class="varname">wal_writer_delay</code>的3倍，因为WAL写进程被设计成倾向于在忙时一次写入所有页面。
  </p><div class="caution"><h3 class="title">小心</h3><p>
    一个立刻关闭等同于一次服务器崩溃，因此也将会导致未刷写的异步提交丢失。
   </p></div><p>
   异步提交提供的行为与配置<a class="xref" href="runtime-config-wal.html#GUC-FSYNC">fsync</a> = off不同。<code class="varname">fsync</code>是一个服务器范围的设置，它将会影响所有事务的行为。它禁用了<span class="productname">PostgreSQL</span>中所有尝试同步写入到数据库不同部分的逻辑，并且因此一次系统崩溃（即，一个硬件或操作系统崩溃，不是<span class="productname">PostgreSQL</span>本身的失败）可能造成数据库状态的任意损坏。在很多情境中，带来大部分性能提升的异步提交可以通过关闭<code class="varname">fsync</code>来获得，而且不会带来数据损坏的风险。
  </p><p>
   <a class="xref" href="runtime-config-wal.html#GUC-COMMIT-DELAY">commit_delay</a>也看起来很像异步提交，但它实际上是一种同步提交方法（事实上，<code class="varname">commit_delay</code>在异步提交时被忽略）。<code class="varname">commit_delay</code>会使事务在刷写<acronym class="acronym">WAL</acronym>到磁盘之前有一个延迟，它期望由一个这样的事务所执行的刷写能够也服务于其他同时提交的事务。该设置可以被看成是一种时间窗口，在其期间事务可以参与到一次单一的刷写中，这种方式用于在多个事务之间摊销刷写的开销。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="wal-intro.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="wal.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="wal-configuration.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">30.2. 预写式日志（<acronym class="acronym">WAL</acronym>） </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 30.4. <acronym class="acronym">WAL</acronym>配置</td></tr></table></div></body></html>