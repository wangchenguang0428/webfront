<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>65.4. 实现</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="spgist-extensibility.html" title="65.3. 可扩展性" /><link rel="next" href="spgist-examples.html" title="65.5. 例子" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">65.4. 实现</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="spgist-extensibility.html" title="65.3. 可扩展性">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="spgist.html" title="第 65 章 SP-GiST索引">上一级</a></td><th width="60%" align="center">第 65 章 SP-GiST索引</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="spgist-examples.html" title="65.5. 例子">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="SPGIST-IMPLEMENTATION"><div class="titlepage"><div><div><h2 class="title" style="clear: both">65.4. 实现</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="spgist-implementation.html#SPGIST-LIMITS">65.4.1. SP-GiST 限制</a></span></dt><dt><span class="sect2"><a href="spgist-implementation.html#SPGIST-NULL-LABELS">65.4.2. 无节点标签的 SP-GiST</a></span></dt><dt><span class="sect2"><a href="spgist-implementation.html#SPGIST-ALL-THE-SAME">65.4.3. <span class="quote">“<span class="quote">All-the-same</span>”</span>内部元组</a></span></dt></dl></div><p>
   这一节覆盖了实现细节以及<acronym class="acronym">SP-GiST</acronym>操作符类的实现者需要知道的有用的技巧。
  </p><div class="sect2" id="SPGIST-LIMITS"><div class="titlepage"><div><div><h3 class="title">65.4.1. SP-GiST 限制</h3></div></div></div><p>
   单独的叶子节点和内部节点必须能适合一个单一的索引页面（默认为 8kB）。因此，当索引值是一种变长数据类型时（长值只能由如 radix 树的方法所支持），树的每一层包含的前缀都足够短以适合一个页面，并且最终的叶子层包括的后缀也足够短以适合一个页面。如果操作符类准备好做这种事情，它应该将<code class="structfield">longValuesOK</code>设置为true。否则，<acronym class="acronym">SP-GiST</acronym>核心将拒绝任何要索引超过一个所以页面长度的值的请求。
  </p><p>
   同样，操作符类应该负责不要让内部元组增长到无法放在一个索引页面中。这限制了能在一个内部元组中使用的子节点的数目，以及一个前缀值的最大尺寸。
  </p><p>
   另一个限制是，当一个内部元组的节点指向一组叶子元组时，这些元组必须都在同一个索引页面中（这种设计是为了减少在这类元组构成链中进行定位的时间并且节省空间）。如果叶子元组集合增长到无法放在一个页面中，将执行一次分裂并且插入一个中间的内部元组。为此，新的内部元组<span class="emphasis"><em>必须</em></span>把叶子值的集合划分成多于一个节点分组。如果操作符类的<code class="function">picksplit</code>函数无法做到这一点，<acronym class="acronym">SP-GiST</acronym>核心只能求助于<a class="xref" href="spgist-implementation.html#SPGIST-ALL-THE-SAME" title="65.4.3. “All-the-same”内部元组">第 65.4.3 节</a>中所介绍的额外措施。
  </p></div><div class="sect2" id="SPGIST-NULL-LABELS"><div class="titlepage"><div><div><h3 class="title">65.4.2. 无节点标签的 SP-GiST</h3></div></div></div><p>
   某些树算法对每个内部元组都使用一种固定的节点集合。例如，在一个四叉树中总是正好有四个节点对应于围绕内部节点中心点的四个象限。在这种情况下，代码总是通过编号来处理节点，而不需要显式的节点标签。要抑制节点标签（因而节省一些空间），<code class="function">picksplit</code>函数可以为<code class="structfield">nodeLabels</code>数组返回NULL，同样<code class="function">choose</code>函数可以在一个<code class="literal">spgSplitTuple</code>动作期间为<code class="structfield">prefixNodeLabels</code>数组返回NULL。这将会导致后续对<code class="function">choose</code>和<code class="function">inner_consistent</code>调用时<code class="structfield">nodeLabels</code>也为 NULL。原则上，可以为同一个索引中的某些内部元组使用节点标签而对其他内部节点省略节点标签。
  </p><p>
   在处理具有无标签节点的内部元组时，让<code class="function">choose</code>返回<code class="literal">spgAddNode</code>是一种错误，因为该节点集合在这种情况下被假定为固定的集合。
  </p></div><div class="sect2" id="SPGIST-ALL-THE-SAME"><div class="titlepage"><div><div><h3 class="title">65.4.3. <span class="quote">“<span class="quote">All-the-same</span>”</span>内部元组</h3></div></div></div><p>
   当<code class="function">picksplit</code>无法把提供的叶子值划分成至少两个节点分类，<acronym class="acronym">SP-GiST</acronym>核心能推翻操作符类的<code class="function">picksplit</code>函数的结果。在发生这种情况时，会创建一个新的内部元组，其中有多个节点，每一个节点都有相同的标签（如果有标签），标签是由<code class="function">picksplit</code>之前给一个节点用的，并且叶子值会被随机地划分给这些等效的节点中。该内部元组上会设置<code class="literal">allTheSame</code>标志以警告<code class="function">choose</code>和<code class="function">inner_consistent</code>函数该元组不具有它们所期望的节点集合。
  </p><p>
   在处理<code class="literal">allTheSame</code>元组时，<code class="function">choose</code>函数的结果<code class="literal">spgMatchNode</code>会被解释为新值可以被赋值给任一等价的节点。核心代码将忽略提供的<code class="structfield">nodeN</code>值并且随机地下降到其中一个节点中（以便保持树平衡）。对<code class="function">choose</code>来说，返回<code class="literal">spgAddNode</code>是一种错误，因为那会让节点不全部等效。如果要被插入的值不匹配现有的节点，则必须使用<code class="literal">spgSplitTuple</code>动作。
  </p><p>
   在处理<code class="literal">allTheSame</code>元组时，为了继续索引搜索，<code class="function">inner_consistent</code>函数应该返回全部节点或者不返回节点作为目标，因为这些节点都是等效的。根据<code class="function">inner_consistent</code>函数对这些节点含义的假定程度，这可能会也可能不会要求任何处理特殊情况的代码。
  </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="spgist-extensibility.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="spgist.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="spgist-examples.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">65.3. 可扩展性 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 65.5. 例子</td></tr></table></div></body></html>