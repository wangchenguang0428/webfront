<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>18.2. 创建一个数据库集簇</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="postgres-user.html" title="18.1. PostgreSQL用户账户" /><link rel="next" href="server-start.html" title="18.3. 启动数据库服务器" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">18.2. 创建一个数据库集簇</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="postgres-user.html" title="18.1. PostgreSQL用户账户">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="runtime.html" title="第 18 章 服务器设置和操作">上一级</a></td><th width="60%" align="center">第 18 章 服务器设置和操作</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="server-start.html" title="18.3. 启动数据库服务器">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="CREATING-CLUSTER"><div class="titlepage"><div><div><h2 class="title" style="clear: both">18.2. 创建一个数据库集簇</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="creating-cluster.html#CREATING-CLUSTER-MOUNT-POINTS">18.2.1. 二级文件系统的使用</a></span></dt><dt><span class="sect2"><a href="creating-cluster.html#CREATING-CLUSTER-NFS">18.2.2. 网络文件系统的使用</a></span></dt></dl></div><a id="id-1.6.5.4.2" class="indexterm"></a><a id="id-1.6.5.4.3" class="indexterm"></a><p>
   在你能做任何事情之前，你必须在磁盘上初始化一个数据库存储区域。我们称之为一个<em class="firstterm">数据库集簇</em>（<acronym class="acronym">SQL</acronym>标准使用的术语是目录集簇）。一个数据库集簇是被一个运行数据库服务器的单一实例所管理的多个数据库的集合。在初始化之后，一个数据库集簇将包含一个名为<code class="literal">postgres</code>的数据库，它表示被功能、用户和第三方应用所使用的默认数据库。数据库服务器本身并不要求<code class="literal">postgres</code>数据库存在。另一个在初始化过程中为每一个集簇创建的数据库被称为<code class="literal">template1</code>。顾名思义，它将被用于创建后续数据库的模板；它不应该被用于实际工作（在集簇内创建新数据库的更多信息请见<a class="xref" href="managing-databases.html" title="第 22 章 管理数据库">第 22 章</a>）。
  </p><p>
   在文件系统术语中，一个数据库集簇是一个单一目录，所有数据都将被存储在其中。我们称它为<em class="firstterm">数据目录</em>或<em class="firstterm">数据区域</em>。在哪里存储你的数据完全由你选择。没有默认的位置，不过<code class="filename">/usr/local/pgsql/data</code>或<code class="filename">/var/lib/pgsql/data</code>位置比较流行。要初始化一个数据库集簇，使用和<span class="productname">PostgreSQL</span>一起安装的命令<a class="xref" href="app-initdb.html" title="initdb"><span class="refentrytitle">initdb</span></a>。<a id="id-1.6.5.4.5.7" class="indexterm"></a>你的数据库集簇的文件系统位置由<code class="option">-D</code>选项指定，例如：
</p><pre class="screen">
<code class="prompt">$</code> <strong class="userinput"><code>initdb -D /usr/local/pgsql/data</code></strong>
</pre><p>
   注意你必须在使用<span class="productname">PostgreSQL</span>用户账户（如前一节所示）登录后执行这个命令。
  </p><div class="tip"><h3 class="title">提示</h3><p>
    作为<code class="option">-D</code>选项的一种替换方案，你可以设置环境变量<code class="envar">PGDATA</code>。
    <a id="id-1.6.5.4.6.1.3" class="indexterm"></a>
   </p></div><p>
   另一种替代方案是，你可以通过<a class="xref" href="app-pg-ctl.html" title="pg_ctl"><span class="refentrytitle"><span class="application">pg_ctl</span></span></a><a id="id-1.6.5.4.7.2" class="indexterm"></a>程序来运行<code class="command">initdb</code>：
</p><pre class="screen">
<code class="prompt">$</code> <strong class="userinput"><code>pg_ctl -D /usr/local/pgsql/data initdb</code></strong>
</pre><p>
   如果你使用<code class="command">pg_ctl</code>来启停服务器（见<a class="xref" href="server-start.html" title="18.3. 启动数据库服务器">第 18.3 节</a>），这种方法可能更直观，以为这样<code class="command">pg_ctl</code>将是你用来管理数据库服务器实例的唯一命令。
  </p><p>
   如果你指定的目录还不存在，<code class="command">initdb</code>将尝试创建它。当然，如果<code class="command">initdb</code>没有在父目录中的写权限，这将会失败。通常推荐让<span class="productname">PostgreSQL</span>用户拥有数据目录及其父目录，这样就不存在上面的问题了。如果想要的父目录也不存在，你将需要先创建它，如果父父目录不可写则使用 root 特权。因此，该过程可能像这样：
</p><pre class="screen">
root# <strong class="userinput"><code>mkdir /usr/local/pgsql</code></strong>
root# <strong class="userinput"><code>chown postgres /usr/local/pgsql</code></strong>
root# <strong class="userinput"><code>su postgres</code></strong>
postgres$ <strong class="userinput"><code>initdb -D /usr/local/pgsql/data</code></strong>
</pre><p>
  </p><p>
   如果数据目录存在并且已经包含文件，<code class="command">initdb</code>将拒绝运行。这可以避免无意中覆盖一个已有的安装。</p><p>
   因为数据目录包含所有存储在数据库里的数据，所以最重要的是保护这个目录不受未授权的访问。因此，<code class="command">initdb</code>会回收禁止除<span class="productname">PostgreSQL</span>用户，也可以选择组，之外所有用户的访问权限。当组访问启用时，是只读的。它允许相同组中未被授权的用户作为集簇属主，备份集簇数据或者执行其他只需要读访问权限的操作。
  </p><p>
  注意在现有集群启用或禁用组访问时，需要关闭集群，且重新启动<span class="productname">PostgreSQL</span>之前设置所有的目录和文件到恰当的模式。否则，数据目录中会存在多种模式。集群仅可以被其属主访问，恰当的模式应该是，其目录设置为<code class="literal">0700</code>，普通文件设置为<code class="literal">0600</code>。允许集群被组可读，恰当的模式应该是，其目录设置为<code class="literal">0750</code>，普通文件设置为<code class="literal">0640</code>。
  </p><p>
   不过，虽然目录的内容是安全的，但默认的客户端认证设置允许任意本地用户连接到数据库甚至成为数据库超级用户。如果你不信任其他本地用户， 我们建议你使用<code class="command">initdb</code>的<code class="option">-W</code>、<code class="option">--pwprompt</code>或<code class="option">--pwfile</code>选项之一给数据库超级用户赋予一个口令。<a id="id-1.6.5.4.12.5" class="indexterm"></a>还可以指定<code class="option">-A md5</code>或<code class="option">-A password</code>，这样就不会使用默认的<code class="literal">trust</code> 身份认证。或者在执行<code class="command">initdb</code>之后、第一次启动服务器<span class="emphasis"><em>之前</em></span>修改生成的<code class="filename">pg_hba.conf</code>文件（另外一些可行的方法包括<code class="literal">peer</code>认证或者用文件系统权限限制连接。更多信息见<a class="xref" href="client-authentication.html" title="第 20 章 客户端认证">第 20 章</a>）。
  </p><p>
   <code class="command">initdb</code>同时也为数据库集簇初始化默认区域<a id="id-1.6.5.4.13.2" class="indexterm"></a>。 通常，它将只是使用环境中的区域设置并且把它们应用于被初始化的数据库。 可以为数据库指定一个不同的区域；有关于此的更多信息可以在<a class="xref" href="locale.html" title="23.1. 区域支持">第 23.1 节</a>中找到。 特定数据库集簇中使用的默认排序顺序是通过<code class="command">initdb</code>设置的， 虽然你可以创建使用不同排序顺序的新数据库，但在 initdb 创建的模板数据库中使用的顺序不能更改（除非删除并重建它们）。使用非<code class="literal">C</code>或<code class="literal">POSIX</code>的区域还会对性能造成影响。因此，第一次就正确地选择很重要。
  </p><p>
   <code class="command">initdb</code>还为数据库集簇设置默认的字符集编码。通常字符集编码应该选择与区域设置匹配。详见<a class="xref" href="multibyte.html" title="23.3. 字符集支持">第 23.3 节</a>。
  </p><p>
   非<code class="literal">C</code>以及非<code class="literal">POSIX</code>区域对于字符集排序依赖于操作系统的排序规则库。这控制着索引中存储的键的排序。为此，通过快照恢复、二进制流复制、更换不同的操作系统或者升级操作系统都不能把一个集簇切换到一种不兼容的排序规则库版本。
  </p><div class="sect2" id="CREATING-CLUSTER-MOUNT-POINTS"><div class="titlepage"><div><div><h3 class="title">18.2.1. 二级文件系统的使用</h3></div></div></div><a id="id-1.6.5.4.16.2" class="indexterm"></a><p>
    很多安装会在文件系统（卷）而不是机器的<span class="quote">“<span class="quote">根</span>”</span>卷上创建它们的数据库集簇。如果你选择这样做，我们不建议尝试使用二级卷的顶层目录（挂载点）作为数据目录。最好的做法是在<span class="productname">PostgreSQL</span>用户拥有的挂载点目录中创建一个目录，然后在其中创建数据目录。这可以避免权限问题，特别是对于<span class="application">pg_upgrade</span>这类操作，并且它也能在二级卷被断线后确保干净的失败。
   </p></div><div class="sect2" id="CREATING-CLUSTER-NFS"><div class="titlepage"><div><div><h3 class="title">18.2.2. 网络文件系统的使用</h3></div></div></div><a id="id-1.6.5.4.17.2" class="indexterm"></a><a id="id-1.6.5.4.17.3" class="indexterm"></a><a id="id-1.6.5.4.17.4" class="indexterm"></a><p>
    许多安装会在网络文件系统上创建它们的数据库集簇。有时直接通过<acronym class="acronym">NFS</acronym>， 或通过内部使用<acronym class="acronym">NFS</acronym>的网络附加存储设备（<acronym class="acronym">NAS</acronym>）完成。 <span class="productname">PostgreSQL</span>不对 <acronym class="acronym">NFS</acronym>文件系统做特殊处理，即它假定<acronym class="acronym">NFS</acronym>的行为和本地连接的设备完全一样。如果客户端或者服务器<acronym class="acronym">NFS</acronym>没有提供标准的文件系统语义，这将导致可靠性问题 （参阅<a class="ulink" href="https://www.time-travellers.org/shane/papers/NFS_considered_harmful.html" target="_top">https://www.time-travellers.org/shane/papers/NFS_considered_harmful.html</a>）。 具体来说，延迟（异步）写入到<acronym class="acronym">NFS</acronym>服务器可以导致数据损坏问题。 如果可能的话，把<acronym class="acronym">NFS</acronym>文件系统挂载为同步（无高速缓存）可以避免这种灾难。还有，我们不推荐软挂载的<acronym class="acronym">NFS</acronym>文件系统。
   </p><p>
    存储区域网络（<acronym class="acronym">SAN</acronym>）通常使用非<acronym class="acronym">NFS</acronym>的通讯协议，并且可能或者不可能遭受这类灾难。建议咨询供应商的文档来了解数据一致性保证。<span class="productname">PostgreSQL</span>无法做到比它所使用的文件系统更可靠。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="postgres-user.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="server-start.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">18.1. <span class="productname">PostgreSQL</span>用户账户 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 18.3. 启动数据库服务器</td></tr></table></div></body></html>