<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>28.2. 统计收集器</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="monitoring-ps.html" title="28.1. 标准 Unix 工具" /><link rel="next" href="monitoring-locks.html" title="28.3. 查看锁" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">28.2. 统计收集器</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="monitoring-ps.html" title="28.1. 标准 Unix 工具">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="monitoring.html" title="第 28 章 监控数据库活动">上一级</a></td><th width="60%" align="center">第 28 章 监控数据库活动</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="monitoring-locks.html" title="28.3. 查看锁">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="MONITORING-STATS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">28.2. 统计收集器</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="monitoring-stats.html#MONITORING-STATS-SETUP">28.2.1. 统计收集配置</a></span></dt><dt><span class="sect2"><a href="monitoring-stats.html#MONITORING-STATS-VIEWS">28.2.2. 查看统计信息</a></span></dt><dt><span class="sect2"><a href="monitoring-stats.html#MONITORING-STATS-FUNCTIONS">28.2.3. 统计函数</a></span></dt></dl></div><a id="id-1.6.15.7.2" class="indexterm"></a><p>
   <span class="productname">PostgreSQL</span>的<em class="firstterm">统计收集器</em>是一个支持收集和报告服务器活动信息的子系统。 目前，这个收集器可以对表和索引的访问计数，计数可以按磁盘块和个体行来进行。它还跟踪每个表中的总行数、每个表的清理和分析动作的信息。它也统计调用用户定义函数的次数以及在每次调用中花费的总时间。
  </p><p>
   <span class="productname">PostgreSQL</span>也支持报告有关系统正在干什么的
   动态信息，例如当前正在被其他服务器进程执行的命令以及系统中存在哪些其他连接。
   这个功能是独立于收集器进程存在的。
  </p><div class="sect2" id="MONITORING-STATS-SETUP"><div class="titlepage"><div><div><h3 class="title">28.2.1. 统计收集配置</h3></div></div></div><p>
   因为统计收集给查询执行增加了一些负荷，系统可以被配置为收集或不收集信息。这由配置参数控制，它们通常在<code class="filename">postgresql.conf</code>中设置（关于设置配置参数的细节请见<a class="xref" href="runtime-config.html" title="第 19 章 服务器配置">第 19 章</a>）。
  </p><p>
   参数<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-ACTIVITIES">track_activities</a>允许监控当前被任意服务器进程执行的命令。
  </p><p>
   参数<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-COUNTS">track_counts</a>控制是否收集关于表和索引访问的统计信息。
  </p><p>
   参数<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-FUNCTIONS">track_functions</a>启用对用户定义函数使用的跟踪。
  </p><p>
   参数<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-IO-TIMING">track_io_timing</a>启用对块读写次数的监控。
  </p><p>
   通常这些参数被设置在<code class="filename">postgresql.conf</code>中，这样它们会应用于所有服务器进程，但是可以在单个会话中使用<a class="xref" href="sql-set.html" title="SET"><span class="refentrytitle">SET</span></a>命令打开或关闭它们（为了阻止普通用户对管理员隐藏他们的活动，只有超级用户被允许使用<code class="command">SET</code>来改变这些参数）。
  </p><p>
   统计收集器通过临时文件将收集到的信息传送给其他<span class="productname">PostgreSQL</span>进程。这些文件被存储在名字由<a class="xref" href="runtime-config-statistics.html#GUC-STATS-TEMP-DIRECTORY">stats_temp_directory</a>参数指定的目录中，默认是<code class="filename">pg_stat_tmp</code>。为了得到更好的性能，<code class="varname">stats_temp_directory</code>可以被指向一个基于 RAM 的文件系统来降低物理 I/O 需求。当服务器被干净地关闭时，一份统计数据的永久拷贝被存储在<code class="filename">pg_stat</code>子目录中，这样在服务器重启后统计信息能被保持。当在服务器启动时执行恢复时（例如立即关闭、服务器崩溃以及时间点恢复之后），所有统计计数器会被重置。
  </p></div><div class="sect2" id="MONITORING-STATS-VIEWS"><div class="titlepage"><div><div><h3 class="title">28.2.2. 查看统计信息</h3></div></div></div><p>
   <a class="xref" href="monitoring-stats.html#MONITORING-STATS-DYNAMIC-VIEWS-TABLE" title="表 28.1. 动态统计视图">表 28.1</a>中列出了一些预定义视图
   可以用来显示系统的当前状态。
   <a class="xref" href="monitoring-stats.html#MONITORING-STATS-VIEWS-TABLE" title="表 28.2. 已收集统计信息的视图">表 28.2</a>中列出了另一些视图可以
   显示统计收集的结果。你也可以使用底层统计函数（在
   <a class="xref" href="monitoring-stats.html#MONITORING-STATS-FUNCTIONS" title="28.2.3. 统计函数">第 28.2.3 节</a>中讨论）来建立自定义的视图。
  </p><p>
   在使用统计信息监控收集到的数据时，你必须了解这些信息并非是实时更新的。每个独立的服务器进程只在进入闲置状态之前才向收集器传送新的统计计数；因此正在进行的查询或事务并不影响显示出来的总数。同样，收集器本身也最多每<code class="varname">PGSTAT_STAT_INTERVAL</code>毫秒（缺省为 500ms，除非在编译服务器的时候修改过）发送一 次新的报告。因此显示的信息总是落后于实际活动。但是由<code class="varname">track_activities</code>收集的当前查询信息总是最新的。
  </p><p>
   另一个重点是当一个服务器进程被要求显示任何这些统计信息时，它首先取得收集器进程最近发出的报告并且接着为所有统计视图和函数使用这个快照，直到它的当前事务的结尾。因此只要你继续当前事务，统计数据将会一直显示静态信息。相似地，当任何关于所有会话的当前查询的信息在一个事务中第一次被请求时，这样的信息将被收集。并且在整个事务期间将显示相同的信息。这是一种特性而非缺陷，因为它允许你在该统计信息上执行多个查询并且关联结果而不用担心那些数字会在你不知情的情况下改变。但是如果你希望用每个查询都看到新结果，要确保在任何事务块之外做那些查询。或者，你可以调用<code class="function">pg_stat_clear_snapshot</code>()，那将丢弃当前事务的统计快照（如果有）。下一次对统计性信息的使用将导致获取一个新的快照。
  </p><p>
   一个事务也可以在视图<code class="structname">pg_stat_xact_all_tables</code>、<code class="structname">pg_stat_xact_sys_tables</code>、<code class="structname">pg_stat_xact_user_tables</code>和<code class="structname">pg_stat_xact_user_functions</code>中看到它自己的统计信息（还没有被传送给收集器）。这些数字并不像上面所述的那样行动，相反它们在事务期间持续被更新。
  </p><div class="table" id="MONITORING-STATS-DYNAMIC-VIEWS-TABLE"><p class="title"><strong>表 28.1. 动态统计视图</strong></p><div class="table-contents"><table class="table" summary="动态统计视图" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>视图名称</th><th>描述</th></tr></thead><tbody><tr><td>
       <code class="structname">pg_stat_activity</code>
       <a id="id-1.6.15.7.6.6.2.2.1.1.2" class="indexterm"></a>
      </td><td>
       每个服务器进程一行，显示与那个进程的当前活动相关的信息，例如状态和当前查询。详见<a class="xref" href="monitoring-stats.html#PG-STAT-ACTIVITY-VIEW" title="表 28.3. pg_stat_activity 视图">pg_stat_activity</a>。
      </td></tr><tr><td><code class="structname">pg_stat_replication</code><a id="id-1.6.15.7.6.6.2.2.2.1.2" class="indexterm"></a></td><td>每一个 WAL 发送进程一行，显示有关到该发送进程
      连接的后备服务器的复制的统计信息。详见
      <a class="xref" href="monitoring-stats.html#PG-STAT-REPLICATION-VIEW" title="表 28.5. pg_stat_replication 视图">pg_stat_replication</a>。
      </td></tr><tr><td><code class="structname">pg_stat_wal_receiver</code><a id="id-1.6.15.7.6.6.2.2.3.1.2" class="indexterm"></a></td><td>只有一行，显示来自 WAL 接收器所连接服务器的有关该接收器的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-WAL-RECEIVER-VIEW" title="表 28.6. pg_stat_wal_receiver 视图">pg_stat_wal_receiver</a>。
      </td></tr><tr><td><code class="structname">pg_stat_subscription</code><a id="id-1.6.15.7.6.6.2.2.4.1.2" class="indexterm"></a></td><td>每个订阅至少一行，显示有关该订阅的工作者的信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-SUBSCRIPTION" title="表 28.7. pg_stat_subscription视图">pg_stat_subscription</a>。
      </td></tr><tr><td><code class="structname">pg_stat_ssl</code><a id="id-1.6.15.7.6.6.2.2.5.1.2" class="indexterm"></a></td><td>每个连接（常规的或者复制）一行，显示在这个连接上使用的SSL的信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-SSL-VIEW" title="表 28.8. pg_stat_ssl视图">pg_stat_ssl</a>。
      </td></tr><tr><td><code class="structname">pg_stat_progress_vacuum</code><a id="id-1.6.15.7.6.6.2.2.6.1.2" class="indexterm"></a></td><td>每个运行着<code class="command">VACUUM</code>的后端（包括autovacuum工作者进程）一行，显示当前的进度。详见<a class="xref" href="progress-reporting.html#VACUUM-PROGRESS-REPORTING" title="28.4.1. VACUUM进度报告">第 28.4.1 节</a>。
      </td></tr></tbody></table></div></div><br class="table-break" /><div class="table" id="MONITORING-STATS-VIEWS-TABLE"><p class="title"><strong>表 28.2. 已收集统计信息的视图</strong></p><div class="table-contents"><table class="table" summary="已收集统计信息的视图" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>视图名称</th><th>描述</th></tr></thead><tbody><tr><td><code class="structname">pg_stat_archiver</code><a id="id-1.6.15.7.6.7.2.2.1.1.2" class="indexterm"></a></td><td>只有一行，显示有关 WAL 归档进程活动的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-ARCHIVER-VIEW" title="表 28.9. pg_stat_archiver视图">pg_stat_archiver</a>。
      </td></tr><tr><td><code class="structname">pg_stat_bgwriter</code><a id="id-1.6.15.7.6.7.2.2.2.1.2" class="indexterm"></a></td><td>只有一行，显示有关后台写进程的活动的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-BGWRITER-VIEW" title="表 28.10. pg_stat_bgwriter视图">pg_stat_bgwriter</a>。
     </td></tr><tr><td><code class="structname">pg_stat_database</code><a id="id-1.6.15.7.6.7.2.2.3.1.2" class="indexterm"></a></td><td>每个数据库一行，显示数据库范围的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-DATABASE-VIEW" title="表 28.11. pg_stat_database视图">pg_stat_database</a>。
      </td></tr><tr><td><code class="structname">pg_stat_database_conflicts</code><a id="id-1.6.15.7.6.7.2.2.4.1.2" class="indexterm"></a></td><td>
       每个数据库一行，显示数据库范围的统计信息，
       这些信息的内容是关于由于与后备服务器的恢复过程
       发生冲突而被取消的查询。详见
       <a class="xref" href="monitoring-stats.html#PG-STAT-DATABASE-CONFLICTS-VIEW" title="表 28.12. pg_stat_database_conflicts视图">pg_stat_database_conflicts</a>。
      </td></tr><tr><td><code class="structname">pg_stat_all_tables</code><a id="id-1.6.15.7.6.7.2.2.5.1.2" class="indexterm"></a></td><td>
       当前数据库中每个表一行，显示有关访问指定表的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-ALL-TABLES-VIEW" title="表 28.13. pg_stat_all_tables视图">pg_stat_all_tables</a>。
      </td></tr><tr><td><code class="structname">pg_stat_sys_tables</code><a id="id-1.6.15.7.6.7.2.2.6.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_stat_all_tables</code>一样，但只显示系统表。</td></tr><tr><td><code class="structname">pg_stat_user_tables</code><a id="id-1.6.15.7.6.7.2.2.7.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_stat_all_tables</code>一样，但只显示用户表。</td></tr><tr><td><code class="structname">pg_stat_xact_all_tables</code><a id="id-1.6.15.7.6.7.2.2.8.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_stat_all_tables</code>相似，但计数动作只在当前事务内发生（还<span class="emphasis"><em>没有</em></span>被包括在<code class="structname">pg_stat_all_tables</code>和相关视图中）。用于生存和死亡行数量的列以及清理和分析动作在此视图中不出现。</td></tr><tr><td><code class="structname">pg_stat_xact_sys_tables</code><a id="id-1.6.15.7.6.7.2.2.9.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_stat_xact_all_tables</code>一样，但只显示系统表。</td></tr><tr><td><code class="structname">pg_stat_xact_user_tables</code><a id="id-1.6.15.7.6.7.2.2.10.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_stat_xact_all_tables</code>一样，但只显示用户表。</td></tr><tr><td><code class="structname">pg_stat_all_indexes</code><a id="id-1.6.15.7.6.7.2.2.11.1.2" class="indexterm"></a></td><td>
       当前数据库中的每个索引一行，显示：表OID、索引OID、模式名、表名、索引名、 使用了该索引的索引扫描总数、索引扫描返回的索引记录数、使用该索引的简 单索引扫描抓取的活表(livetable)中数据行数。
       当前数据库中的每个索引一行，显示与访问指定索引有关的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-ALL-INDEXES-VIEW" title="表 28.14. pg_stat_all_indexes视图">pg_stat_all_indexes</a>。
      </td></tr><tr><td><code class="structname">pg_stat_sys_indexes</code><a id="id-1.6.15.7.6.7.2.2.12.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_stat_all_indexes</code>一样，但只显示系统表上的索引。</td></tr><tr><td><code class="structname">pg_stat_user_indexes</code><a id="id-1.6.15.7.6.7.2.2.13.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_stat_all_indexes</code>一样，但只显示用户表上的索引。</td></tr><tr><td><code class="structname">pg_statio_all_tables</code><a id="id-1.6.15.7.6.7.2.2.14.1.2" class="indexterm"></a></td><td>
       当前数据库中每个表一行(包括TOAST表)，显示：表OID、模式名、表名、 从该表中读取的磁盘块总数、缓冲区命中次数、该表上所有索引的磁盘块读取总数、 该表上所有索引的缓冲区命中总数、在该表的辅助TOAST表(如果存在)上的磁盘块读取总数、 在该表的辅助TOAST表(如果存在)上的缓冲区命中总数、TOAST表的索引的磁盘块读 取总数、TOAST表的索引的缓冲区命中总数。
       当前数据库中的每个表一行，显示有关在指定表上 I/O 的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STATIO-ALL-TABLES-VIEW" title="表 28.15. pg_statio_all_tables视图">pg_statio_all_tables</a>。
      </td></tr><tr><td><code class="structname">pg_statio_sys_tables</code><a id="id-1.6.15.7.6.7.2.2.15.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_statio_all_tables</code>一样，但只显示系统表。</td></tr><tr><td><code class="structname">pg_statio_user_tables</code><a id="id-1.6.15.7.6.7.2.2.16.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_statio_all_tables</code>一样，但只显示用户表。</td></tr><tr><td><code class="structname">pg_statio_all_indexes</code><a id="id-1.6.15.7.6.7.2.2.17.1.2" class="indexterm"></a></td><td>
       当前数据库中每个索引一行，显示：表OID、索引OID、模式名、 表名、索引名、该索引的磁盘块读取总数、该索引的缓冲区命中总数。
       当前数据库中的每个索引一行，显示与指定索引上的 I/O 有关的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STATIO-ALL-INDEXES-VIEW" title="表 28.16. pg_statio_all_indexes视图">pg_statio_all_indexes</a>。
      </td></tr><tr><td><code class="structname">pg_statio_sys_indexes</code><a id="id-1.6.15.7.6.7.2.2.18.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_statio_all_indexes</code>一样，但只显示系统表上的索引。</td></tr><tr><td><code class="structname">pg_statio_user_indexes</code><a id="id-1.6.15.7.6.7.2.2.19.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_statio_all_indexes</code>一样，但只显示用户表上的索引。</td></tr><tr><td><code class="structname">pg_statio_all_sequences</code><a id="id-1.6.15.7.6.7.2.2.20.1.2" class="indexterm"></a></td><td>
       当前数据库中每个序列对象一行，显示：序列OID、模式名、序列名、序列的磁盘读取总数、序列的缓冲区命中总数。
       当前数据库中的每个序列一行，显示与指定序列上的 I/O 有关的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STATIO-ALL-SEQUENCES-VIEW" title="表 28.17. pg_statio_all_sequences视图">pg_statio_all_sequences</a>。
     </td></tr><tr><td><code class="structname">pg_statio_sys_sequences</code><a id="id-1.6.15.7.6.7.2.2.21.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_statio_all_sequences</code>一样，但只显示系统序列（目前没有定义系统序列，因此这个视图总是为空）。</td></tr><tr><td><code class="structname">pg_statio_user_sequences</code><a id="id-1.6.15.7.6.7.2.2.22.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_statio_all_sequences</code>一样，但只显示用户序列。</td></tr><tr><td><code class="structname">pg_stat_user_functions</code><a id="id-1.6.15.7.6.7.2.2.23.1.2" class="indexterm"></a></td><td>
       对于所有跟踪功能，函数的OID，模式，名称，数量 通话总时间，和自我的时间。自我时间是 在函数本身所花费的时间量，总时间包括 它调用函数所花费的时间。时间值以毫秒为单位。
       每一个被跟踪的函数一行，显示与执行该函数有关的统计信息。详见<a class="xref" href="monitoring-stats.html#PG-STAT-USER-FUNCTIONS-VIEW" title="表 28.18. pg_stat_user_functions视图">pg_stat_user_functions</a>。
      </td></tr><tr><td><code class="structname">pg_stat_xact_user_functions</code><a id="id-1.6.15.7.6.7.2.2.24.1.2" class="indexterm"></a></td><td>和<code class="structname">pg_stat_user_functions</code>相似，但是只统计在当前事务期间的调用（还<span class="emphasis"><em>没有</em></span>被包括在<code class="structname">pg_stat_user_functions</code>中）。</td></tr></tbody></table></div></div><br class="table-break" /><p>
   针对每个索引的统计信息对于判断哪个索引正被使用以及它们的效果特别有用。
  </p><p>
   <code class="structname">pg_statio_</code>系列视图主要用于判断缓冲区的效果。当实际磁盘读取数远小于缓冲区命中时，这个缓冲能满足大部分读请求而无需进行内核调用。但是，这些统计信息并没有给出所有的事情：由于<span class="productname">PostgreSQL</span>处理磁盘 I/O 的方式，不在<span class="productname">PostgreSQL</span>缓冲区中的数据库仍然驻留在内核的 I/O 缓存中，并且因此可以被再次读取而不需要物理磁盘读取。我们建议希望了解<span class="productname">PostgreSQL</span> I/O 行为更多细节的用户将<span class="productname">PostgreSQL</span>统计收集器和操作系统中允许观察内核处理 I/O 的工具一起使用。
  </p><div class="table" id="PG-STAT-ACTIVITY-VIEW"><p class="title"><strong>表 28.3. <code class="structname">pg_stat_activity</code> 视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_activity 视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">datid</code></td><td><code class="type">oid</code></td><td>这个后端连接到的数据库的OID</td></tr><tr><td><code class="structfield">datname</code></td><td><code class="type">name</code></td><td>这个后端连接到的数据库的名称</td></tr><tr><td><code class="structfield">pid</code></td><td><code class="type">integer</code></td><td>这个后端的进程 ID</td></tr><tr><td><code class="structfield">usesysid</code></td><td><code class="type">oid</code></td><td>登录到这个后端的用户的 OID</td></tr><tr><td><code class="structfield">usename</code></td><td><code class="type">name</code></td><td>登录到这个后端的用户的名称</td></tr><tr><td><code class="structfield">application_name</code></td><td><code class="type">text</code></td><td>连接到这个后端的应用的名称</td></tr><tr><td><code class="structfield">client_addr</code></td><td><code class="type">inet</code></td><td>连接到这个后端的客户端的 IP 地址。如果这个域为空，它表示客户端通过服务器机器上的一个 Unix 套接字连接或者这是一个内部进程（如自动清理）。
     </td></tr><tr><td><code class="structfield">client_hostname</code></td><td><code class="type">text</code></td><td>已连接的客户端的主机名，由<code class="structfield">client_addr</code>的反向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有<a class="xref" href="runtime-config-logging.html#GUC-LOG-HOSTNAME">log_hostname</a>被启用时才会非空。
     </td></tr><tr><td><code class="structfield">client_port</code></td><td><code class="type">integer</code></td><td>客户端用以和这个后端通信的 TCP 端口号，如果使用 Unix 套接字则为<code class="literal">-1</code>
     </td></tr><tr><td><code class="structfield">backend_start</code></td><td><code class="type">timestamp with time zone</code></td><td>这个进程被启动的时间。对客户端后端来说就是客户端连接到服务器的时间。
     </td></tr><tr><td><code class="structfield">xact_start</code></td><td><code class="type">timestamp with time zone</code></td><td>这个进程的当前事务被启动的时间，如果没有活动事务则为空。如果当前查询是它的第一个事务，这一列等于<code class="structfield">query_start</code>。
     </td></tr><tr><td><code class="structfield">query_start</code></td><td><code class="type">timestamp with time zone</code></td><td>当前活动查询被开始的时间，如果<code class="structfield">state</code>不是<code class="literal">active</code>，这个域为上一个查询被开始的时间
     </td></tr><tr><td><code class="structfield">state_change</code></td><td><code class="type">timestamp with time zone</code></td><td><code class="structfield">state</code>上一次被改变的时间</td></tr><tr><td><code class="structfield">wait_event_type</code></td><td><code class="type">text</code></td><td>后端正在等待的事件类型，如果不存在则为 NULL。可能的值有：
       <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
          <code class="literal">LWLock</code>：后端正在等待一个轻量级锁。每一个这样的锁保护着共享内存中的一个特殊数据结构。<code class="literal">wait_event</code>将含有一个标识该轻量级锁目的的名称（一些锁具有特定的名称，其他是一组具有类似目的的锁中的一部分）。
         </p></li><li class="listitem"><p>
          <code class="literal">Lock</code>：后端正在等待一个重量级锁。重量级锁，也称为锁管理器锁或者简单锁，主要保护 SQL 可见的对象，例如表。不过，它们也被用于确保特定内部操作的互斥，例如关系扩展。<code class="literal">wait_event</code>将标识等待的锁的类型。
         </p></li><li class="listitem"><p>
          <code class="literal">BufferPin</code>：服务器进程正在等待访问一个数据缓冲区，而此时没有其他进程正在检查该缓冲区。如果另一个进程持有一个最终从要访问的缓冲区中读取数据的打开的游标，缓冲区 pin 等待可能会被拖延。
         </p></li><li class="listitem"><p>
          <code class="literal">Activity</code>：服务器进程处于闲置状态。这被用于在其主处理循环中等待活动的系统进程。<code class="literal">wait_event</code>将标识特定的等待点。
         </p></li><li class="listitem"><p>
          <code class="literal">Extension</code>：服务器进程正在一个扩展模块中等待活动。这一个分类被用于要跟踪自定义等待点的模块。
         </p></li><li class="listitem"><p>
          <code class="literal">Client</code>：服务器进程正在一个套接字上等待来自用户应用的某种活动，并且该服务器预期某种与其内部处理无关的事情发生。<code class="literal">wait_event</code>将标识特定的等待点。
         </p></li><li class="listitem"><p>
          <code class="literal">IPC</code>：服务器进程正在等待来自服务器中另一个进程的某种活动。<code class="literal">wait_event</code>将标识特定的等待点。
         </p></li><li class="listitem"><p>
          <code class="literal">Timeout</code>：服务器进程正在等待一次超时发生。<code class="literal">wait_event</code>将标识特定的等待点。
         </p></li><li class="listitem"><p>
          <code class="literal">IO</code>：服务器进程正在等待一次IO完成。<code class="literal">wait_event</code>将标识特定的等待点。
         </p></li></ul></div>
      </td></tr><tr><td><code class="structfield">wait_event</code></td><td><code class="type">text</code></td><td>如果后端当前正在等待，则是等待事件的名称，否则为 NULL。详见<a class="xref" href="monitoring-stats.html#WAIT-EVENT-TABLE" title="表 28.4. wait_event 描述">表 28.4</a>。
     </td></tr><tr><td><code class="structfield">state</code></td><td><code class="type">text</code></td><td>这个后端的当前总体状态。可能的值是：
       <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
           <code class="literal">active</code>：后端正在执行一个查询。
          </p></li><li class="listitem"><p>
           <code class="literal">idle</code>：后端正在等待一个新的客户端命令。
          </p></li><li class="listitem"><p>
           <code class="literal">idle in transaction</code>：后端在一个事务中，但是当前没有正在执行一个查询。
          </p></li><li class="listitem"><p>
           <code class="literal">idle in transaction (aborted)</code>：这个状态与<code class="literal">idle in transaction</code>相似，不过在该事务中的一个语句导致了一个错误。
          </p></li><li class="listitem"><p>
           <code class="literal">fastpath function call</code>：后端正在执行一个 fast-path 函数。
          </p></li><li class="listitem"><p>
           <code class="literal">disabled</code>：如果在这个后端中<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-ACTIVITIES">track_activities</a>被禁用，则报告这个状态。
          </p></li></ul></div>
     </td></tr><tr><td><code class="structfield">backend_xid</code></td><td><code class="type">xid</code></td><td>这个后端的顶层事务标识符（如果存在）。</td></tr><tr><td><code class="structfield">backend_xmin</code></td><td><code class="type">xid</code></td><td>当前后端的<code class="literal">xmin</code>范围。</td></tr><tr><td><code class="structfield">query</code></td><td><code class="type">text</code></td><td>这个后端最近查询的文本。如果<code class="structfield">state</code>为<code class="literal">active</code>，这个域显示当前正在执行的查询。在所有其他状态下，它显示上一个被执行的查询。默认情况下，查询文本会被截断至1024个字符，这个值可以通过参数<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-ACTIVITY-QUERY-SIZE">track_activity_query_size</a>更改。
     </td></tr><tr><td><code class="structfield">backend_type</code></td><td><code class="type">text</code></td><td>当前后端的类型。可能的类型是
      <code class="literal">autovacuum launcher</code>, <code class="literal">autovacuum worker</code>,
      <code class="literal">logical replication launcher</code>,
      <code class="literal">logical replication worker</code>,
      <code class="literal">parallel worker</code>, <code class="literal">background writer</code>,
      <code class="literal">client backend</code>, <code class="literal">checkpointer</code>,
      <code class="literal">startup</code>, <code class="literal">walreceiver</code>,
      <code class="literal">walsender</code> 以及 <code class="literal">walwriter</code>。
      除此以外，由扩展注册的后台Worker可能有额外的类型。
     </td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_stat_activity</code>视图将为每一个服务器进程有一行，显示与该进程的当前活动相关的信息。
  </p><div class="note"><h3 class="title">注意</h3><p>
    <code class="structfield">wait_event</code>和<code class="structfield">state</code>列是独立的。如果一个后端处于<code class="literal">active</code>状态，它可能是也可能不是某个事件上的<code class="literal">waiting</code>。如果状态是<code class="literal">active</code>并且<code class="structfield">wait_event</code>为非空，它意味着一个查询正在被执行，但是它被阻塞在系统中某处。
   </p></div><div class="table" id="WAIT-EVENT-TABLE"><p class="title"><strong>表 28.4. <code class="structname">wait_event</code> 描述</strong></p><div class="table-contents"><table class="table" summary="wait_event 描述" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>等待事件类型</th><th>等待事件名称</th><th>描述</th></tr></thead><tbody><tr><td rowspan="65"><code class="literal">LWLock</code></td><td><code class="literal">ShmemIndexLock</code></td><td>正等待在共享内存中查找或者分配空间。</td></tr><tr><td><code class="literal">OidGenLock</code></td><td>正等待分配或者赋予一个 OID。</td></tr><tr><td><code class="literal">XidGenLock</code></td><td>正等待分配或者赋予一个事务 ID。</td></tr><tr><td><code class="literal">ProcArrayLock</code></td><td>正等待在事务结尾得到一个快照或者清除事务 ID。</td></tr><tr><td><code class="literal">SInvalReadLock</code></td><td>正等待从共享无效消息队列中检索或者移除消息。</td></tr><tr><td><code class="literal">SInvalWriteLock</code></td><td>正等待在共享无效消息队列中增加一个消息。</td></tr><tr><td><code class="literal">WALBufMappingLock</code></td><td>正等待在 WAL 缓冲区中替换一个页面。</td></tr><tr><td><code class="literal">WALWriteLock</code></td><td>正等待 WAL 缓冲区被写入到磁盘。</td></tr><tr><td><code class="literal">ControlFileLock</code></td><td>正等待读取或者更新控制文件或创建一个新的 WAL 文件。</td></tr><tr><td><code class="literal">CheckpointLock</code></td><td>正等待执行检查点。</td></tr><tr><td><code class="literal">CLogControlLock</code></td><td>正等待读取或者更新事务状态。</td></tr><tr><td><code class="literal">SubtransControlLock</code></td><td>正等待读取或者更新子事务信息。</td></tr><tr><td><code class="literal">MultiXactGenLock</code></td><td>正等待读取或者更新共享多事务状态。</td></tr><tr><td><code class="literal">MultiXactOffsetControlLock</code></td><td>正等待读取或者更新多事务偏移映射。</td></tr><tr><td><code class="literal">MultiXactMemberControlLock</code></td><td>正等待读取或者更新多事务成员映射。</td></tr><tr><td><code class="literal">RelCacheInitLock</code></td><td>正等待读取或者写入关系缓冲区初始化文件。</td></tr><tr><td><code class="literal">CheckpointerCommLock</code></td><td>正等待管理 fsync 请求。</td></tr><tr><td><code class="literal">TwoPhaseStateLock</code></td><td>正等待读取或者更新预备事务的状态。</td></tr><tr><td><code class="literal">TablespaceCreateLock</code></td><td>正等待创建或者删除表空间。</td></tr><tr><td><code class="literal">BtreeVacuumLock</code></td><td>正等待读取或者更新一个 B-树索引的 vacuum 相关的信息。</td></tr><tr><td><code class="literal">AddinShmemInitLock</code></td><td>正等待管理共享内存中的空间分配。</td></tr><tr><td><code class="literal">AutovacuumLock</code></td><td>自动清理工作者或者启动器正等待更新或者读取自动清理工作者的当前状态。</td></tr><tr><td><code class="literal">AutovacuumScheduleLock</code></td><td>正等待确认选中进行清理的表仍需要清理。
         </td></tr><tr><td><code class="literal">SyncScanLock</code></td><td>正等待为同步扫描得到一个表上扫描的开始位置。</td></tr><tr><td><code class="literal">RelationMappingLock</code></td><td>正等待更新用来存储目录到文件节点映射的关系映射文件。
         </td></tr><tr><td><code class="literal">AsyncCtlLock</code></td><td>正等待读取或者更新共享通知状态。</td></tr><tr><td><code class="literal">AsyncQueueLock</code></td><td>正等待读取或者更新通知消息。</td></tr><tr><td><code class="literal">SerializableXactHashLock</code></td><td>正等待检索或者存储有关可序列化事务的信息。</td></tr><tr><td><code class="literal">SerializableFinishedListLock</code></td><td>正等待访问已结束可序列化事务的列表。</td></tr><tr><td><code class="literal">SerializablePredicateLockListLock</code></td><td>正等待在由可序列化事务持有的所列表上执行一个操作。</td></tr><tr><td><code class="literal">OldSerXidLock</code></td><td>正等待读取或者记录冲突的可序列化事务。</td></tr><tr><td><code class="literal">SyncRepLock</code></td><td>正等待读取或者更新有关同步复制的信息。</td></tr><tr><td><code class="literal">BackgroundWorkerLock</code></td><td>正等待读取或者更新后台工作者状态。</td></tr><tr><td><code class="literal">DynamicSharedMemoryControlLock</code></td><td>正等待读取或者更新动态共享内存状态。</td></tr><tr><td><code class="literal">AutoFileLock</code></td><td>正等待更新<code class="filename">postgresql.auto.conf</code>文件。</td></tr><tr><td><code class="literal">ReplicationSlotAllocationLock</code></td><td>正等待分配或者释放一个复制槽。</td></tr><tr><td><code class="literal">ReplicationSlotControlLock</code></td><td>正等待读取或者更新复制槽状态。</td></tr><tr><td><code class="literal">CommitTsControlLock</code></td><td>正等待读取或者更新事务提交时间戳。</td></tr><tr><td><code class="literal">CommitTsLock</code></td><td>正等待读取或者更新事务时间戳的最新设置值。</td></tr><tr><td><code class="literal">ReplicationOriginLock</code></td><td>正等待设置、删除或者使用复制源头。</td></tr><tr><td><code class="literal">MultiXactTruncationLock</code></td><td>正等待读取或者阶段多事务信息。</td></tr><tr><td><code class="literal">OldSnapshotTimeMapLock</code></td><td>正等待读取或者更新旧的快照控制信息。</td></tr><tr><td><code class="literal">BackendRandomLock</code></td><td>正等待产生一个随机数。</td></tr><tr><td><code class="literal">LogicalRepWorkerLock</code></td><td>正等待逻辑复制工作者上的动作完成。</td></tr><tr><td><code class="literal">CLogTruncationLock</code></td><td>正等待截断预写式日志或者等待预写式日志截断操作完成。</td></tr><tr><td><code class="literal">clog</code></td><td>正在等地clog (事务状态)缓冲区上的I/O。</td></tr><tr><td><code class="literal">commit_timestamp</code></td><td>正等待提交时间戳缓冲区上的 I/O。</td></tr><tr><td><code class="literal">subtrans</code></td><td>正等待子事务缓冲区上的 I/O。</td></tr><tr><td><code class="literal">multixact_offset</code></td><td>正等待多事务偏移缓冲区上的 I/O。</td></tr><tr><td><code class="literal">multixact_member</code></td><td>正等待多事务成员缓冲区上的 I/O。</td></tr><tr><td><code class="literal">async</code></td><td>正等待 async（通知）缓冲区上的 I/O。</td></tr><tr><td><code class="literal">oldserxid</code></td><td>正等待 oldserxid 缓冲区上的 I/O。</td></tr><tr><td><code class="literal">wal_insert</code></td><td>正等待把 WAL 插入到一个内存缓冲区。</td></tr><tr><td><code class="literal">buffer_content</code></td><td>正等待读取或者写入内存中的一个数据页。</td></tr><tr><td><code class="literal">buffer_io</code></td><td>正等待一个数据页面上的 I/O。</td></tr><tr><td><code class="literal">replication_origin</code></td><td>正等待读取或者更新复制进度。</td></tr><tr><td><code class="literal">replication_slot_io</code></td><td>正等待一个复制槽上的 I/O。</td></tr><tr><td><code class="literal">proc</code></td><td>正等待读取或者更新 fast-path 锁信息。</td></tr><tr><td><code class="literal">buffer_mapping</code></td><td>正等待把一个数据块与缓冲池中的一个缓冲区关联。</td></tr><tr><td><code class="literal">lock_manager</code></td><td>正等待增加或者检查用于后端的锁，或者正等待加入或者退出一个锁定组（并行查询使用）。</td></tr><tr><td><code class="literal">predicate_lock_manager</code></td><td>正等待增加或者检查谓词锁信息。</td></tr><tr><td><code class="literal">parallel_query_dsa</code></td><td>正等待并行查询动态共享内存分配锁。</td></tr><tr><td><code class="literal">tbm</code></td><td>正等待TBM共享迭代器锁。</td></tr><tr><td><code class="literal">parallel_append</code></td><td>在Parallel Append计划执行期间等待选择下一个子计划。</td></tr><tr><td><code class="literal">parallel_hash_join</code></td><td>在Parallel Hash计划执行期间等待分配或交换一块内存或者更新计数器。</td></tr><tr><td rowspan="10"><code class="literal">Lock</code></td><td><code class="literal">relation</code></td><td>正等待获得一个关系上的锁。</td></tr><tr><td><code class="literal">extend</code></td><td>正等待扩展一个关系。</td></tr><tr><td><code class="literal">page</code></td><td>正等待获得一个关系上的页面的锁。</td></tr><tr><td><code class="literal">tuple</code></td><td>正等待获得一个元组上的锁。</td></tr><tr><td><code class="literal">transactionid</code></td><td>正等待一个事务结束。</td></tr><tr><td><code class="literal">virtualxid</code></td><td>正等待获得一个虚拟 xid 锁。</td></tr><tr><td><code class="literal">speculative token</code></td><td>正等待获取一个  speculative insertion lock。</td></tr><tr><td><code class="literal">object</code></td><td>正等待获得一个非关系数据库对象上的锁。</td></tr><tr><td><code class="literal">userlock</code></td><td>正等待获得一个用户锁。</td></tr><tr><td><code class="literal">advisory</code></td><td>正等待获得一个咨询用户锁。</td></tr><tr><td><code class="literal">BufferPin</code></td><td><code class="literal">BufferPin</code></td><td>正等待在一个缓冲区上加 pin。</td></tr><tr><td rowspan="14"><code class="literal">Activity</code></td><td><code class="literal">ArchiverMain</code></td><td>正在归档进程的主循环中等待。</td></tr><tr><td><code class="literal">AutoVacuumMain</code></td><td>正在autovacuum启动器进程的主循环中等待。</td></tr><tr><td><code class="literal">BgWriterHibernate</code></td><td>正在后台写入器进程中等待，休眠中。</td></tr><tr><td><code class="literal">BgWriterMain</code></td><td>正在后台写入器进程的后台工作者的主循环中等待。</td></tr><tr><td><code class="literal">CheckpointerMain</code></td><td>正在检查点进程的主循环中等待。</td></tr><tr><td><code class="literal">LogicalApplyMain</code></td><td>正在逻辑应用进程的主循环中等待。</td></tr><tr><td><code class="literal">LogicalLauncherMain</code></td><td>正在逻辑启动器进程的主循环中等待。</td></tr><tr><td><code class="literal">PgStatMain</code></td><td>正在统计收集器进程的主循环中等待。</td></tr><tr><td><code class="literal">RecoveryWalAll</code></td><td>在恢复时等待来自于任意类型来源（本地、归档或流）的WAL。</td></tr><tr><td><code class="literal">RecoveryWalStream</code></td><td>在恢复时等待来自于一个流的WAL。</td></tr><tr><td><code class="literal">SysLoggerMain</code></td><td>正在系统日志进程的主循环中等待。</td></tr><tr><td><code class="literal">WalReceiverMain</code></td><td>正在WAL接收器进程的主循环中等待。</td></tr><tr><td><code class="literal">WalSenderMain</code></td><td>正在WAL发送器进程的主循环中等待。</td></tr><tr><td><code class="literal">WalWriterMain</code></td><td>正在WAL写入器进程的主循环中等待。</td></tr><tr><td rowspan="8"><code class="literal">Client</code></td><td><code class="literal">ClientRead</code></td><td>正等待从客户端读取数据。</td></tr><tr><td><code class="literal">ClientWrite</code></td><td>正等待向客户端写入数据。</td></tr><tr><td><code class="literal">LibPQWalReceiverConnect</code></td><td>正在WAL接收器中等待建立与远程服务器的连接。</td></tr><tr><td><code class="literal">LibPQWalReceiverReceive</code></td><td>正在WAL接收器中等待从远程服务器接收数据。</td></tr><tr><td><code class="literal">SSLOpenServer</code></td><td>正在尝试连接期间等待SSL。</td></tr><tr><td><code class="literal">WalReceiverWaitStart</code></td><td>正等待startup进程发送流复制的初始数据。</td></tr><tr><td><code class="literal">WalSenderWaitForWAL</code></td><td>正在WAL发送器进程中等待WAL被刷写。</td></tr><tr><td><code class="literal">WalSenderWriteData</code></td><td>在WAL发送器进程中处理来自WAL接收器的回复时等待任意活动。</td></tr><tr><td><code class="literal">Extension</code></td><td><code class="literal">Extension</code></td><td>正在一个扩展中等待。</td></tr><tr><td rowspan="34"><code class="literal">IPC</code></td><td><code class="literal">BgWorkerShutdown</code></td><td>正等待后台工作者关闭。</td></tr><tr><td><code class="literal">BgWorkerStartup</code></td><td>正等待后台工作者启动。</td></tr><tr><td><code class="literal">BtreePage</code></td><td>正等待继续并行B-树扫描所需的页号变得可用。</td></tr><tr><td><code class="literal">ClogGroupUpdate</code></td><td>正等待组领袖在事务结束时更新事务状态。</td></tr><tr><td><code class="literal">ExecuteGather</code></td><td>在执行<code class="literal">Gather</code>节点时等待来自子进程的活动。</td></tr><tr><td><code class="literal">Hash/Batch/Allocating</code></td><td>正等待一个选出的Parallel Hash参与者分配哈希表。</td></tr><tr><td><code class="literal">Hash/Batch/Electing</code></td><td>正在选出一个Parallel Hash参与者来分配一个哈希表。</td></tr><tr><td><code class="literal">Hash/Batch/Loading</code></td><td>正等待其他Parallel Hash参与者完成装载哈希表。</td></tr><tr><td><code class="literal">Hash/Build/Allocating</code></td><td>正等待一个选出的Parallel Hash参与者分配初始哈希表。</td></tr><tr><td><code class="literal">Hash/Build/Electing</code></td><td>正在选出一个Parallel Hash参与者以分配初始哈希表。</td></tr><tr><td><code class="literal">Hash/Build/HashingInner</code></td><td>正等待其他Parallel Hash参与者完成对内关系的哈希操作。</td></tr><tr><td><code class="literal">Hash/Build/HashingOuter</code></td><td>正等待其他Parallel Hash参与者完成对外关系的哈希操作。</td></tr><tr><td><code class="literal">Hash/GrowBatches/Allocating</code></td><td>正等待一个选出的Parallel Hash参与者分配更多批次。</td></tr><tr><td><code class="literal">Hash/GrowBatches/Deciding</code></td><td>正在选出一个Parallel Hash参与者决定未来的批次增长。</td></tr><tr><td><code class="literal">Hash/GrowBatches/Electing</code></td><td>正在选出一个Parallel Hash参与者分配更多批次。</td></tr><tr><td><code class="literal">Hash/GrowBatches/Finishing</code></td><td>正在等待一个选出的Parallel Hash参与者决定未来的批次增长。</td></tr><tr><td><code class="literal">Hash/GrowBatches/Repartitioning</code></td><td>正等待其他Parallel Hash参与者完成重新分区。</td></tr><tr><td><code class="literal">Hash/GrowBuckets/Allocating</code></td><td>正等待一个选出的Parallel Hash参与者完成更多桶的分配。</td></tr><tr><td><code class="literal">Hash/GrowBuckets/Electing</code></td><td>正在选出一个Parallel Hash参与者分配更多桶。</td></tr><tr><td><code class="literal">Hash/GrowBuckets/Reinserting</code></td><td>正等待其他Parallel Hash参与者完成将元组插入到新桶的操作。</td></tr><tr><td><code class="literal">LogicalSyncData</code></td><td>正等待逻辑复制的远程服务器发送用于初始表同步的数据。</td></tr><tr><td><code class="literal">LogicalSyncStateChange</code></td><td>正等待逻辑复制的远程服务器更改状态。</td></tr><tr><td><code class="literal">MessageQueueInternal</code></td><td>正等待其他进程被挂接到共享消息队列。</td></tr><tr><td><code class="literal">MessageQueuePutMessage</code></td><td>正等待把一个协议消息写到一个共享消息队列。</td></tr><tr><td><code class="literal">MessageQueueReceive</code></td><td>正等待从一个共享消息队列接收字节。</td></tr><tr><td><code class="literal">MessageQueueSend</code></td><td>正等待向一个共享消息队列中发送字节。</td></tr><tr><td><code class="literal">ParallelBitmapScan</code></td><td>正等待并行位图扫描被初始化。</td></tr><tr><td><code class="literal">ParallelCreateIndexScan</code></td><td>正等待并行<code class="command">CREATE INDEX</code>工作者完成堆扫描。</td></tr><tr><td><code class="literal">ParallelFinish</code></td><td>正等待并行工作者完成计算。</td></tr><tr><td><code class="literal">ProcArrayGroupUpdate</code></td><td>正等待组领袖在事务结束时清除事务ID。</td></tr><tr><td><code class="literal">ReplicationOriginDrop</code></td><td>正等待一个复制源头变得不活跃以便被删除。</td></tr><tr><td><code class="literal">ReplicationSlotDrop</code></td><td>正等待一个复制槽变得不活跃以便被删除。</td></tr><tr><td><code class="literal">SafeSnapshot</code></td><td>正等待一个用于<code class="literal">READ ONLY DEFERRABLE</code>事务的快照。</td></tr><tr><td><code class="literal">SyncRep</code></td><td>正在同步复制期间等待来自远程服务器的确认。</td></tr><tr><td rowspan="3"><code class="literal">Timeout</code></td><td><code class="literal">BaseBackupThrottle</code></td><td>当有限流活动时在基础备份期间等待。</td></tr><tr><td><code class="literal">PgSleep</code></td><td>正在调用<code class="function">pg_sleep</code>的进程中等待。</td></tr><tr><td><code class="literal">RecoveryApplyDelay</code></td><td>在恢复时等待应用WAL，因为它被延迟了。</td></tr><tr><td rowspan="66"><code class="literal">IO</code></td><td><code class="literal">BufFileRead</code></td><td>正等待从一个缓存的文件中读取。</td></tr><tr><td><code class="literal">BufFileWrite</code></td><td>正等待向一个缓存的文件中写入。</td></tr><tr><td><code class="literal">ControlFileRead</code></td><td>正等待从控制文件中读取。</td></tr><tr><td><code class="literal">ControlFileSync</code></td><td>正等待控制文件到达稳定存储。</td></tr><tr><td><code class="literal">ControlFileSyncUpdate</code></td><td>正等待对控制文件的更新到达稳定存储。</td></tr><tr><td><code class="literal">ControlFileWrite</code></td><td>正等待一个对控制文件的写入。</td></tr><tr><td><code class="literal">ControlFileWriteUpdate</code></td><td>正等待一个写操作更新控制文件。</td></tr><tr><td><code class="literal">CopyFileRead</code></td><td>正在文件拷贝操作期间等待一个读操作。</td></tr><tr><td><code class="literal">CopyFileWrite</code></td><td>正在文件拷贝操作期间等待一个写操作。</td></tr><tr><td><code class="literal">DataFileExtend</code></td><td>正等待一个关系数据文件被扩充。</td></tr><tr><td><code class="literal">DataFileFlush</code></td><td>正等待一个关系数据文件到达稳定存储。</td></tr><tr><td><code class="literal">DataFileImmediateSync</code></td><td>正等待一个关系数据文件的立即同步到达稳定存储。</td></tr><tr><td><code class="literal">DataFilePrefetch</code></td><td>正等待从一个关系数据文件中的一次异步预取。</td></tr><tr><td><code class="literal">DataFileRead</code></td><td>正等待一次对一个关系数据文件的读操作。</td></tr><tr><td><code class="literal">DataFileSync</code></td><td>正等待对一个关系数据文件的更改到达稳定存储。</td></tr><tr><td><code class="literal">DataFileTruncate</code></td><td>正等待一个关系数据文件被截断。</td></tr><tr><td><code class="literal">DataFileWrite</code></td><td>正等待一次对一个关系数据文件的写操作。</td></tr><tr><td><code class="literal">DSMFillZeroWrite</code></td><td>等待向一个动态共享内存备份文件中写零字节。</td></tr><tr><td><code class="literal">LockFileAddToDataDirRead</code></td><td>在向数据目录锁文件中增加一行时等待一个读操作。</td></tr><tr><td><code class="literal">LockFileAddToDataDirSync</code></td><td>在向数据目录锁文件中增加一行时等待数据到达稳定存储。</td></tr><tr><td><code class="literal">LockFileAddToDataDirWrite</code></td><td>在向数据目录锁文件中增加一行时等待一个写操作。</td></tr><tr><td><code class="literal">LockFileCreateRead</code></td><td>在创建数据目录锁文件期间等待读取。</td></tr><tr><td><code class="literal">LockFileCreateSync</code></td><td>在创建数据目录锁文件期间等待数据到达稳定存储。</td></tr><tr><td><code class="literal">LockFileCreateWrite</code></td><td>在创建数据目录锁文件期间等待一个写操作。</td></tr><tr><td><code class="literal">LockFileReCheckDataDirRead</code></td><td>在重新检查数据目录锁文件的过程中等待一个读操作。</td></tr><tr><td><code class="literal">LogicalRewriteCheckpointSync</code></td><td>在一个检查点期间等待逻辑重写映射到达稳定存储。</td></tr><tr><td><code class="literal">LogicalRewriteMappingSync</code></td><td>在一次逻辑重写期间等待映射数据到达稳定存储。</td></tr><tr><td><code class="literal">LogicalRewriteMappingWrite</code></td><td>在一次逻辑重写期间等待对映射数据的写操作。</td></tr><tr><td><code class="literal">LogicalRewriteSync</code></td><td>正等待逻辑重写映射到达稳定存储。</td></tr><tr><td><code class="literal">LogicalRewriteWrite</code></td><td>正等待对逻辑重写映射的写操作。</td></tr><tr><td><code class="literal">RelationMapRead</code></td><td>正等待对关系映射文件的读操作。</td></tr><tr><td><code class="literal">RelationMapSync</code></td><td>正等待关系映射文件到达稳定存储。</td></tr><tr><td><code class="literal">RelationMapWrite</code></td><td>正等待对关系映射文件的写操作。</td></tr><tr><td><code class="literal">ReorderBufferRead</code></td><td>在重排序缓冲区管理期间等待一个读操作。</td></tr><tr><td><code class="literal">ReorderBufferWrite</code></td><td>在重排序缓冲区管理期间等待一个写操作。</td></tr><tr><td><code class="literal">ReorderLogicalMappingRead</code></td><td>在重排序缓冲区管理期间等待对一个逻辑映射的读操作。</td></tr><tr><td><code class="literal">ReplicationSlotRead</code></td><td>正等待对一个复制槽控制文件的读操作。</td></tr><tr><td><code class="literal">ReplicationSlotRestoreSync</code></td><td>在把一个复制槽控制文件恢复到内存的过程中等待它到达稳定存储。</td></tr><tr><td><code class="literal">ReplicationSlotSync</code></td><td>正等待一个复制槽控制文件到达稳定存储。</td></tr><tr><td><code class="literal">ReplicationSlotWrite</code></td><td>正等待对一个复制槽控制文件的写操作。</td></tr><tr><td><code class="literal">SLRUFlushSync</code></td><td>在检查点或者数据库关闭期间等待SLRU数据到达稳定存储。</td></tr><tr><td><code class="literal">SLRURead</code></td><td>正等待对一个SLRU页面的读操作。</td></tr><tr><td><code class="literal">SLRUSync</code></td><td>正等待SLRU数据在一个页面写之后到达稳定存储。</td></tr><tr><td><code class="literal">SLRUWrite</code></td><td>正等待一个SLRU页面上的写操作。</td></tr><tr><td><code class="literal">SnapbuildRead</code></td><td>正等待一个序列化历史目录快照的读操作。</td></tr><tr><td><code class="literal">SnapbuildSync</code></td><td>正等待一个序列化历史目录快照到达稳定存储。</td></tr><tr><td><code class="literal">SnapbuildWrite</code></td><td>正等待一个序列化历史目录快照的写操作。</td></tr><tr><td><code class="literal">TimelineHistoryFileSync</code></td><td>正等待一个通过流复制接收到的时间线历史文件到达稳定存储。</td></tr><tr><td><code class="literal">TimelineHistoryFileWrite</code></td><td>正等待一个通过流复制接收到的时间线历史文件的读操作。</td></tr><tr><td><code class="literal">TimelineHistoryRead</code></td><td>正等待一个时间线历史文件上的读操作。</td></tr><tr><td><code class="literal">TimelineHistorySync</code></td><td>正等待一个新创建的时间线历史文件达到稳定存储。</td></tr><tr><td><code class="literal">TimelineHistoryWrite</code></td><td>正等待一个新创建的时间线历史文件上的写操作。</td></tr><tr><td><code class="literal">TwophaseFileRead</code></td><td>正等待一个两阶段状态文件的读操作。</td></tr><tr><td><code class="literal">TwophaseFileSync</code></td><td>正等待一个两阶段状态文件到达稳定存储。</td></tr><tr><td><code class="literal">TwophaseFileWrite</code></td><td>正等待一个两阶段状态文件的写操作。</td></tr><tr><td><code class="literal">WALBootstrapSync</code></td><td>在自举期间等待WAL到达稳定存储。</td></tr><tr><td><code class="literal">WALBootstrapWrite</code></td><td>在自举期间等待一个WAL页面的写操作。</td></tr><tr><td><code class="literal">WALCopyRead</code></td><td>在通过拷贝一个已有WAL段创建一个新的WAL段时等待一个读操作。</td></tr><tr><td><code class="literal">WALCopySync</code></td><td>正等待一个通过拷贝已有WAL段创建的新WAL段到达稳定存储。</td></tr><tr><td><code class="literal">WALCopyWrite</code></td><td>在通过拷贝一个已有WAL段创建一个新的WAL段时等待一个写操作。</td></tr><tr><td><code class="literal">WALInitSync</code></td><td>正等待一个新初始化的WAL文件到达稳定存储。</td></tr><tr><td><code class="literal">WALInitWrite</code></td><td>在初始化一个新的WAL文件期间等待一个写操作。</td></tr><tr><td><code class="literal">WALRead</code></td><td>正等待一次对一个WAL文件的读操作。</td></tr><tr><td><code class="literal">WALSenderTimelineHistoryRead</code></td><td>在walsender的时间线命令期间等待对一个时间线历史文件的读操作。</td></tr><tr><td><code class="literal">WALSyncMethodAssign</code></td><td>在指派WAL同步方法时等待数据到达稳定存储。</td></tr><tr><td><code class="literal">WALWrite</code></td><td>正等待一次对一个WAL文件的写操作。</td></tr></tbody></table></div></div><br class="table-break" /><div class="note"><h3 class="title">注意</h3><p>
     对于扩展安装的切片（tranche），这个名称由扩展指定并且会被<code class="structfield">wait_event</code>显示出来。很有可能在其他后端不知道的情况下，用户在其中一个后端中注册了切片（通过在动态共享内存中分配），那么我们对这种情况会显示<code class="literal">extension</code>。
    </p></div><p>
     下面的例子展示了如何查看等待事件

</p><pre class="programlisting">
SELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;
 pid  | wait_event_type |  wait_event
------+-----------------+---------------
 2540 | Lock            | relation
 6644 | LWLock          | ProcArrayLock
(2 rows)
</pre><p>
   </p><div class="table" id="PG-STAT-REPLICATION-VIEW"><p class="title"><strong>表 28.5. <code class="structname">pg_stat_replication</code> 视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_replication 视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">pid</code></td><td><code class="type">integer</code></td><td>一个 WAL 发送进程的进程 ID</td></tr><tr><td><code class="structfield">usesysid</code></td><td><code class="type">oid</code></td><td>登录到这个 WAL 发送进程的用户的 OID</td></tr><tr><td><code class="structfield">usename</code></td><td><code class="type">name</code></td><td>登录到这个 WAL 发送进程的用户的名称</td></tr><tr><td><code class="structfield">application_name</code></td><td><code class="type">text</code></td><td>连接到这个 WAL 发送进程的应用的名称</td></tr><tr><td><code class="structfield">client_addr</code></td><td><code class="type">inet</code></td><td>连接到这个 WAL 发送进程的客户端的 IP 地址。
     如果这个域为空，它表示该客户端通过服务器机器上的一个
     Unix 套接字连接。
     </td></tr><tr><td><code class="structfield">client_hostname</code></td><td><code class="type">text</code></td><td>连接上的客户端的主机名，由一次对<code class="structfield">client_addr</code>
     的逆向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有在
     <a class="xref" href="runtime-config-logging.html#GUC-LOG-HOSTNAME">log_hostname</a>被启用时非空
     </td></tr><tr><td><code class="structfield">client_port</code></td><td><code class="type">integer</code></td><td>客户端用来与这个 WAL 发送进程通讯的 TCP 端口号，
     如果使用 Unix 套接字则为<code class="literal">-1</code>
     </td></tr><tr><td><code class="structfield">backend_start</code></td><td><code class="type">timestamp with time zone</code></td><td>这个进程开始的时间，即客户端是何时连接到这个
     WAL 发送进程的
     </td></tr><tr><td><code class="structfield">backend_xmin</code></td><td><code class="type">xid</code></td><td>由<a class="xref" href="runtime-config-replication.html#GUC-HOT-STANDBY-FEEDBACK">hot_standby_feedback</a>报告
     的这个后备机的<code class="literal">xmin</code>水平线。</td></tr><tr><td><code class="structfield">state</code></td><td><code class="type">text</code></td><td>当前的 WAL 发送进程状态。
       可能的值是：
       <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
           <code class="literal">startup</code>：这个WAL发送器正在启动。
          </p></li><li class="listitem"><p>
           <code class="literal">catchup</code>：这个WAL发送器连接的后备机正在追赶主服务器。
          </p></li><li class="listitem"><p>
           <code class="literal">streaming</code>：这个WAL发送器在它连接的后备服务器追上主服务器之后用流传送更改。
          </p></li><li class="listitem"><p>
           <code class="literal">backup</code>：这个WAL发送器正在发送一个备份。
          </p></li><li class="listitem"><p>
           <code class="literal">stopping</code>：这个WAL发送器正在停止。
          </p></li></ul></div>
     </td></tr><tr><td><code class="structfield">sent_lsn</code></td><td><code class="type">pg_lsn</code></td><td>在这个连接上发送的最后一个预写式日志的位置</td></tr><tr><td><code class="structfield">write_lsn</code></td><td><code class="type">pg_lsn</code></td><td>被这个后备服务器写入到磁盘的最后一个预写式日志的位置</td></tr><tr><td><code class="structfield">flush_lsn</code></td><td><code class="type">pg_lsn</code></td><td>被这个后备服务器刷入到磁盘的最后一个预写式日志的位置</td></tr><tr><td><code class="structfield">replay_lsn</code></td><td><code class="type">pg_lsn</code></td><td>被重放到这个后备服务器上的数据库中的最后一个预写式日志的位置</td></tr><tr><td><code class="structfield">write_lag</code></td><td><code class="type">interval</code></td><td>在本地刷写近期的WAL与接收到后备服务器已经写入它（但还没有刷写或者应用）的通知之间流逝的时间。如果这台服务器被配置为一个同步后备，这可以用来计量在提交时<code class="literal">synchronous_commit</code>的级别<code class="literal">remote_write</code>所导致的延迟。</td></tr><tr><td><code class="structfield">flush_lag</code></td><td><code class="type">interval</code></td><td>在本地刷写近期的WAL与接收到后备服务器已经写入并且刷写它（但还没有应用）的通知之间流逝的时间。如果这台服务器被配置为一个同步后备，这可以用来计量在提交时<code class="literal">synchronous_commit</code>的级别<code class="literal">on</code>所导致的延迟。</td></tr><tr><td><code class="structfield">replay_lag</code></td><td><code class="type">interval</code></td><td>在本地刷写近期的WAL与接收到后备服务器已经写入它、刷写它并且应用它的通知之间流逝的时间。如果这台服务器被配置为一个同步后备，这可以用来计量在提交时<code class="literal">synchronous_commit</code>的级别<code class="literal">remote_apply</code>所导致的延迟。</td></tr><tr><td><code class="structfield">sync_priority</code></td><td><code class="type">integer</code></td><td>在基于优先的同步复制中，这台后备服务器被选为同步后备的优先级。在基于规定数量的同步复制中，这个值没有效果。</td></tr><tr><td><code class="structfield">sync_state</code></td><td><code class="type">text</code></td><td>这一台后备服务器的同步状态。
       可能的值是：
       <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
           <code class="literal">async</code>：这台后备服务器是异步的。
          </p></li><li class="listitem"><p>
           <code class="literal">potential</code>：这台后备服务器现在是异步的，但可能在当前的同步后备失效时变成同步的。
          </p></li><li class="listitem"><p>
           <code class="literal">sync</code>：这台后备服务器是同步的。
          </p></li><li class="listitem"><p>
           <code class="literal">quorum</code>：这台后备服务器被当做规定数量后备服务器的候选。
          </p></li></ul></div>
     </td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_stat_replication</code>视图中将为每一个 WAL
   发送进程包含一行，用来显示与该发送进程连接的后备服务器的复制统计信息。
   这个视图中只会列出直接连接的后备机，下游后备服务器的信息不包含在此。
  </p><p>
   <code class="structname">pg_stat_replication</code>视图中报告的滞后时间近期的WAL被写入、刷写并且重放以及发送器知道这一切所花的时间的度量。如果远程服务器被配置为一台同步后备，这些时间表示由每一种同步提交级别所带来（或者是可能带来）的提交延迟。对于一台异步后备，<code class="structfield">replay_lag</code>列是最近的事务变得对查询可见的延迟时间的近似值。如果后备服务器已经完全追上了发送服务器并且没有WAL活动，在短时间内将继续显示最近测到的滞后时间，再然后就会显示为NULL。
  </p><p>
   对于物理复制会自动测量滞后时间。逻辑解码插件可能会选择性地发出跟踪消息，如果它们没有这样做，跟踪机制将把滞后显示为NULL。
  </p><div class="note"><h3 class="title">注意</h3><p>
    报告的滞后时间并非按照当前的重放速率该后备还有多久才能追上发送服务器的预测。在新的WAL被生成期间，这样一种系统将显示类似的时间，但是当发送器变为闲置时会显示不同的值。特别是当后备服务器完全追上时，<code class="structname">pg_stat_replication</code>显示的是写入、刷写及重放最近报告的WAL位置所花的时间而不是一些用户可能预期的零。这种做法与为近期的写事务测量同步提交和事务可见性延迟的目的一致。为了降低用户预期一种不同的滞后模型带来的混淆，在一个完全重放完的闲置系统上，lag列会在一段比较短的时间后回复成NULL。监控系统应该选择将这种情况表示为缺失数据、零或者继续显示最近的已知值。
   </p></div><div class="table" id="PG-STAT-WAL-RECEIVER-VIEW"><p class="title"><strong>表 28.6. <code class="structname">pg_stat_wal_receiver</code> 视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_wal_receiver 视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">pid</code></td><td><code class="type">integer</code></td><td>WAL 接收器进程的进程 ID</td></tr><tr><td><code class="structfield">status</code></td><td><code class="type">text</code></td><td>WAL 接收器进程的活动状态</td></tr><tr><td><code class="structfield">receive_start_lsn</code></td><td><code class="type">pg_lsn</code></td><td>WAL 接收器启动时使用的第一个预写式日志位置</td></tr><tr><td><code class="structfield">receive_start_tli</code></td><td><code class="type">integer</code></td><td>WAL 接收器启动时使用的第一个时间线编号</td></tr><tr><td><code class="structfield">received_lsn</code></td><td><code class="type">pg_lsn</code></td><td>已经接收到并且已经被杀入磁盘的最后一个预写式日志的位置，这个域的初始值是 WAL 接收器启动时使用的第一个日志位置</td></tr><tr><td><code class="structfield">received_tli</code></td><td><code class="type">integer</code></td><td>已经接收到并且已经被杀入磁盘的最后一个预写式日志的时间线编号，这个域的初始值是 WAL 接收器启动时使用的第一个日志所在的时间线编号
     </td></tr><tr><td><code class="structfield">last_msg_send_time</code></td><td><code class="type">timestamp with time zone</code></td><td>从源头 WAL 发送器接收到的最后一个消息的发送时间</td></tr><tr><td><code class="structfield">last_msg_receipt_time</code></td><td><code class="type">timestamp with time zone</code></td><td>从源头 WAL 发送器接收到的最后一个消息的接收时间</td></tr><tr><td><code class="structfield">latest_end_lsn</code></td><td><code class="type">pg_lsn</code></td><td>报告给源头 WAL 发送器的最后一个预写式日志位置</td></tr><tr><td><code class="structfield">latest_end_time</code></td><td><code class="type">timestamp with time zone</code></td><td>报告给源头 WAL 发送器最后一个事务日志位置的时间</td></tr><tr><td><code class="structfield">slot_name</code></td><td><code class="type">text</code></td><td>这个 WAL 接收器使用的复制槽的名称</td></tr><tr><td><code class="structfield">sender_host</code></td><td><code class="type">text</code></td><td>
      这个WAL接收器连接到的<span class="productname">PostgreSQL</span>实例的主机。这可以是一个主机名、一个IP地址，如果连接是通过Unix套接字则是一个目录路径（为目录的情况可以被辨别出来，因为路径将总是一个绝对路径并且以<code class="literal">/</code>开头）。
     </td></tr><tr><td><code class="structfield">sender_port</code></td><td><code class="type">integer</code></td><td>
      这个WAL接收器连接到的<span class="productname">PostgreSQL</span>实例的端口号。
     </td></tr><tr><td><code class="structfield">conninfo</code></td><td><code class="type">text</code></td><td>
      这个 WAL 接收器使用的连接串，安全相关的域会被隐去。
     </td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_stat_wal_receiver</code>事务只包含一行，它显示了从 WAL 接收器所连接的服务器得到的有关该接收器的统计信息。
  </p><div class="table" id="PG-STAT-SUBSCRIPTION"><p class="title"><strong>表 28.7. <code class="structname">pg_stat_subscription</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_subscription视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>介绍</th></tr></thead><tbody><tr><td><code class="structfield">subid</code></td><td><code class="type">oid</code></td><td>订阅的OID</td></tr><tr><td><code class="structfield">subname</code></td><td><code class="type">text</code></td><td>订阅的名称</td></tr><tr><td><code class="structfield">pid</code></td><td><code class="type">integer</code></td><td>订阅工作者进程的进程ID</td></tr><tr><td><code class="structfield">relid</code></td><td><code class="type">Oid</code></td><td>工作者正在同步的关系的OID，对于主应用工作者为空</td></tr><tr><td><code class="structfield">received_lsn</code></td><td><code class="type">pg_lsn</code></td><td>接收到的最后一个预写式日志位置，这个字段的初始值是0</td></tr><tr><td><code class="structfield">last_msg_send_time</code></td><td><code class="type">timestamp with time zone</code></td><td>从源头WAL发送器接收到的最后一个消息的发送时间</td></tr><tr><td><code class="structfield">last_msg_receipt_time</code></td><td><code class="type">timestamp with time zone</code></td><td>从源头WAL发送器接收到的最后一个消息的接收时间
     </td></tr><tr><td><code class="structfield">latest_end_lsn</code></td><td><code class="type">pg_lsn</code></td><td>最后一个报告给源头WAL发送器的预写式日志位置
     </td></tr><tr><td><code class="structfield">latest_end_time</code></td><td><code class="type">timestamp with time zone</code></td><td>报告给源头WAL发送器的最后一个预写式日志位置的时间</td></tr></tbody></table></div></div><br class="table-break" /><p>
   每一个订阅的主工作者都在<code class="structname">pg_stat_subscription</code>视图中有一行（如果工作者没有运行则PID为空），处理被订阅表的初始数据拷贝操作的工作者还会有额外的行。
  </p><div class="table" id="PG-STAT-SSL-VIEW"><p class="title"><strong>表 28.8. <code class="structname">pg_stat_ssl</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_ssl视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">pid</code></td><td><code class="type">integer</code></td><td>一个后端或者 WAL 发送进程的进程 ID</td></tr><tr><td><code class="structfield">ssl</code></td><td><code class="type">boolean</code></td><td>如果在这个连接上使用了 SSL 则为真</td></tr><tr><td><code class="structfield">version</code></td><td><code class="type">text</code></td><td>在用的 SSL 版本，如果这个连接上没有使用 SSL 则为 NULL</td></tr><tr><td><code class="structfield">cipher</code></td><td><code class="type">text</code></td><td>在用的 SSL 密码的名称，如果这个连接上没有使用 SSL 则为 NULL</td></tr><tr><td><code class="structfield">bits</code></td><td><code class="type">integer</code></td><td>使用的加密算法中的位数，如果这个连接上没有使用 SSL 则为 NULL</td></tr><tr><td><code class="structfield">compression</code></td><td><code class="type">boolean</code></td><td>如果使用了 SSL 压缩则为真，否则为假，
     如果这个连接上没有使用 SSL 则为 NULL</td></tr><tr><td><code class="structfield">clientdn</code></td><td><code class="type">text</code></td><td>来自所使用的客户端证书的识别名（DN）域，
     如果没有提供客户端证书或者这个连接上没有使用 SSL 
     则为 NULL。如果 DN 域长度超过
     <code class="symbol">NAMEDATALEN</code>（标准编译
     中是 64 个字符），则它会被截断。
     </td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_stat_ssl</code>视图将为每一个后端或者 WAL 发送进程
   包含一行，用来显示这个连接上的 SSL 使用情况。可以把它与
   <code class="structname">pg_stat_activity</code>或者
   <code class="structname">pg_stat_replication</code>通过
   <code class="structfield">pid</code>列连接来得到更多有关该连接的细节。
  </p><div class="table" id="PG-STAT-ARCHIVER-VIEW"><p class="title"><strong>表 28.9. <code class="structname">pg_stat_archiver</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_archiver视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">archived_count</code></td><td><code class="type">bigint</code></td><td>已被成功归档的 WAL 文件数量</td></tr><tr><td><code class="structfield">last_archived_wal</code></td><td><code class="type">text</code></td><td>最后一个被成功归档的 WAL 文件名称</td></tr><tr><td><code class="structfield">last_archived_time</code></td><td><code class="type">timestamp with time zone</code></td><td>最后一次成功归档操作的时间</td></tr><tr><td><code class="structfield">failed_count</code></td><td><code class="type">bigint</code></td><td>失败的归档 WAL 文件尝试的数量</td></tr><tr><td><code class="structfield">last_failed_wal</code></td><td><code class="type">text</code></td><td>最后一次失败的归档操作的 WAL 文件名称</td></tr><tr><td><code class="structfield">last_failed_time</code></td><td><code class="type">timestamp with time zone</code></td><td>最后一次失败的归档操作的时间</td></tr><tr><td><code class="structfield">stats_reset</code></td><td><code class="type">timestamp with time zone</code></td><td>这些统计信息最后一次被重置的时间</td></tr></tbody></table></div></div><br class="table-break" /><p>
   The <code class="structname">pg_stat_archiver</code>视图将总是一个单一的行，
   该行包含着有关集簇的归档进程的数据。
  </p><div class="table" id="PG-STAT-BGWRITER-VIEW"><p class="title"><strong>表 28.10. <code class="structname">pg_stat_bgwriter</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_bgwriter视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">checkpoints_timed</code></td><td><code class="type">bigint</code></td><td>已经被执行的计划中检查点的数量</td></tr><tr><td><code class="structfield">checkpoints_req</code></td><td><code class="type">bigint</code></td><td>已经被执行的请求检查点的数量</td></tr><tr><td><code class="structfield">checkpoint_write_time</code></td><td><code class="type">double precision</code></td><td>在文件被写入磁盘的检查点处理部分花费的总时间，以毫秒计
      </td></tr><tr><td><code class="structfield">checkpoint_sync_time</code></td><td><code class="type">double precision</code></td><td>在文件被同步到磁盘中的检查点处理部分花费的总时间，以毫秒计
      </td></tr><tr><td><code class="structfield">buffers_checkpoint</code></td><td><code class="type">bigint</code></td><td>在检查点期间被写的缓冲区数目</td></tr><tr><td><code class="structfield">buffers_clean</code></td><td><code class="type">bigint</code></td><td>被后台写进程写的缓冲区数目</td></tr><tr><td><code class="structfield">maxwritten_clean</code></td><td><code class="type">bigint</code></td><td>后台写进程由于已经写了太多缓冲区而停止清洁扫描的次数</td></tr><tr><td><code class="structfield">buffers_backend</code></td><td><code class="type">bigint</code></td><td>被一个后端直接写的缓冲区数量</td></tr><tr><td><code class="structfield">buffers_backend_fsync</code></td><td><code class="type">bigint</code></td><td>一个后端不得不自己执行<code class="function">fsync</code>调用的次数（通常即使后端自己进行写操作，后台写进程也会处理这些）</td></tr><tr><td><code class="structfield">buffers_alloc</code></td><td><code class="type">bigint</code></td><td>被分配的缓冲区数量</td></tr><tr><td><code class="structfield">stats_reset</code></td><td><code class="type">timestamp with time zone</code></td><td>这些统计信息上次被重置的时间</td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_stat_bgwriter</code>视图将总是只有单独的一行，它包含集簇的全局数据。
  </p><div class="table" id="PG-STAT-DATABASE-VIEW"><p class="title"><strong>表 28.11. <code class="structname">pg_stat_database</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_database视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">datid</code></td><td><code class="type">oid</code></td><td>一个数据库的 OID</td></tr><tr><td><code class="structfield">datname</code></td><td><code class="type">name</code></td><td>这个数据库的名称</td></tr><tr><td><code class="structfield">numbackends</code></td><td><code class="type">integer</code></td><td>当前连接到这个数据库的后端数量。这是在这个视图中唯一一个返回反映当前状态值的列。所有其他列返回从上次重置以来积累的值。</td></tr><tr><td><code class="structfield">xact_commit</code></td><td><code class="type">bigint</code></td><td>在这个数据库中已经被提交的事务的数量</td></tr><tr><td><code class="structfield">xact_rollback</code></td><td><code class="type">bigint</code></td><td>在这个数据库中已经被回滚的事务的数量</td></tr><tr><td><code class="structfield">blks_read</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被读取的磁盘块的数量</td></tr><tr><td><code class="structfield">blks_hit</code></td><td><code class="type">bigint</code></td><td>磁盘块被发现已经在缓冲区中的次数，这样不需要一次读取（这只包括 PostgreSQL 缓冲区中的命中，而不包括在操作系统文件系统缓冲区中的命中）
     </td></tr><tr><td><code class="structfield">tup_returned</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询返回的行数</td></tr><tr><td><code class="structfield">tup_fetched</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询取出的行数</td></tr><tr><td><code class="structfield">tup_inserted</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询插入的行数</td></tr><tr><td><code class="structfield">tup_updated</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询更新的行数</td></tr><tr><td><code class="structfield">tup_deleted</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询删除的行数</td></tr><tr><td><code class="structfield">conflicts</code></td><td><code class="type">bigint</code></td><td>由于与恢复冲突而在这个数据库中被取消的查询的数目（冲突只发生在后备服务器上，详见<a class="xref" href="monitoring-stats.html#PG-STAT-DATABASE-CONFLICTS-VIEW" title="表 28.12. pg_stat_database_conflicts视图">pg_stat_database_conflicts</a>）。
     </td></tr><tr><td><code class="structfield">temp_files</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询创建的临时文件的数量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管<a class="xref" href="runtime-config-logging.html#GUC-LOG-TEMP-FILES">log_temp_files</a>设置。
     </td></tr><tr><td><code class="structfield">temp_bytes</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被查询写到临时文件中的数据总量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管<a class="xref" href="runtime-config-logging.html#GUC-LOG-TEMP-FILES">log_temp_files</a>设置。
     </td></tr><tr><td><code class="structfield">deadlocks</code></td><td><code class="type">bigint</code></td><td>在这个数据库中被检测到的死锁数</td></tr><tr><td><code class="structfield">blk_read_time</code></td><td><code class="type">double precision</code></td><td>在这个数据库中后端花费在读取数据文件块的时间，以毫秒计</td></tr><tr><td><code class="structfield">blk_write_time</code></td><td><code class="type">double precision</code></td><td>在这个数据库中后端花费在写数据文件块的时间，以毫秒计</td></tr><tr><td><code class="structfield">stats_reset</code></td><td><code class="type">timestamp with time zone</code></td><td>这些统计信息上次被重置的时间</td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_stat_database</code>视图将为集簇中的每一个数据库包含有一行，每一行显示数据库范围的统计信息。
  </p><div class="table" id="PG-STAT-DATABASE-CONFLICTS-VIEW"><p class="title"><strong>表 28.12. <code class="structname">pg_stat_database_conflicts</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_database_conflicts视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">datid</code></td><td><code class="type">oid</code></td><td>一个数据库的 OID</td></tr><tr><td><code class="structfield">datname</code></td><td><code class="type">name</code></td><td>这个数据库的名称</td></tr><tr><td><code class="structfield">confl_tablespace</code></td><td><code class="type">bigint</code></td><td>这个数据库中由于表空间被删掉而取消的查询数量</td></tr><tr><td><code class="structfield">confl_lock</code></td><td><code class="type">bigint</code></td><td>这个数据库中由于锁超时而取消的查询数量</td></tr><tr><td><code class="structfield">confl_snapshot</code></td><td><code class="type">bigint</code></td><td>这个数据库中由于旧快照而取消的查询数量</td></tr><tr><td><code class="structfield">confl_bufferpin</code></td><td><code class="type">bigint</code></td><td>这个数据库中由于被占用的缓冲区而取消的查询数量</td></tr><tr><td><code class="structfield">confl_deadlock</code></td><td><code class="type">bigint</code></td><td>这个数据库中由于死锁而取消的查询数量</td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_stat_database_conflicts</code>视图为每一个
   数据库包含一行，用来显示数据库范围内由于与后备服务器上的恢复过程
   冲突而被取消的查询的统计信息。 这个视图将只包含后备服务器上的信息，
   因为冲突会不发生在主服务器上。
  </p><div class="table" id="PG-STAT-ALL-TABLES-VIEW"><p class="title"><strong>表 28.13. <code class="structname">pg_stat_all_tables</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_all_tables视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">relid</code></td><td><code class="type">oid</code></td><td>一个表的 OID</td></tr><tr><td><code class="structfield">schemaname</code></td><td><code class="type">name</code></td><td>这个表所在的模式的名称</td></tr><tr><td><code class="structfield">relname</code></td><td><code class="type">name</code></td><td>这个表的名称</td></tr><tr><td><code class="structfield">seq_scan</code></td><td><code class="type">bigint</code></td><td>在这个表上发起的顺序扫描的次数</td></tr><tr><td><code class="structfield">seq_tup_read</code></td><td><code class="type">bigint</code></td><td>被顺序扫描取得的活着的行的数量</td></tr><tr><td><code class="structfield">idx_scan</code></td><td><code class="type">bigint</code></td><td>在这个表上发起的索引扫描的次数</td></tr><tr><td><code class="structfield">idx_tup_fetch</code></td><td><code class="type">bigint</code></td><td>被索引扫描取得的活着的行的数量</td></tr><tr><td><code class="structfield">n_tup_ins</code></td><td><code class="type">bigint</code></td><td>被插入的行数</td></tr><tr><td><code class="structfield">n_tup_upd</code></td><td><code class="type">bigint</code></td><td>被更新的行数（包括 HOT 更新的行）</td></tr><tr><td><code class="structfield">n_tup_del</code></td><td><code class="type">bigint</code></td><td>被删除的行数</td></tr><tr><td><code class="structfield">n_tup_hot_upd</code></td><td><code class="type">bigint</code></td><td>被更新的 HOT 行数（即不要求独立索引更新的行更新）</td></tr><tr><td><code class="structfield">n_live_tup</code></td><td><code class="type">bigint</code></td><td>活着的行的估计数量</td></tr><tr><td><code class="structfield">n_dead_tup</code></td><td><code class="type">bigint</code></td><td>死亡行的估计数量</td></tr><tr><td><code class="structfield">n_mod_since_analyze</code></td><td><code class="type">bigint</code></td><td>从这个表最后一次被分析后备修改的行的估计数量</td></tr><tr><td><code class="structfield">last_vacuum</code></td><td><code class="type">timestamp with time zone</code></td><td>上次这个表被手动清理的时间（不统计<code class="command">VACUUM FULL</code>）</td></tr><tr><td><code class="structfield">last_autovacuum</code></td><td><code class="type">timestamp with time zone</code></td><td>上次这个表被自动清理守护进程清理的时间</td></tr><tr><td><code class="structfield">last_analyze</code></td><td><code class="type">timestamp with time zone</code></td><td>上次这个表被手动分析的时间</td></tr><tr><td><code class="structfield">last_autoanalyze</code></td><td><code class="type">timestamp with time zone</code></td><td>上次这个表被自动清理守护进程分析的时间</td></tr><tr><td><code class="structfield">vacuum_count</code></td><td><code class="type">bigint</code></td><td>这个表已被手工清理的次数（不统计<code class="command">VACUUM FULL</code>）</td></tr><tr><td><code class="structfield">autovacuum_count</code></td><td><code class="type">bigint</code></td><td>这个表已被自动清理守护进程清理的次数</td></tr><tr><td><code class="structfield">analyze_count</code></td><td><code class="type">bigint</code></td><td>这个表已被手工分析的次数</td></tr><tr><td><code class="structfield">autoanalyze_count</code></td><td><code class="type">bigint</code></td><td>这个表已被自动清理守护进程分析的次数</td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_stat_all_tables</code>视图将为当前数据库中的每一个表（包括 TOAST 表）包含一行，该行显示与对该表的访问相关的统计信息。<code class="structname">pg_stat_user_tables</code>和<code class="structname">pg_stat_sys_tables</code>视图包含相同的信息，但是被过滤得分别只显示用户和系统表。
  </p><div class="table" id="PG-STAT-ALL-INDEXES-VIEW"><p class="title"><strong>表 28.14. <code class="structname">pg_stat_all_indexes</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_all_indexes视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">relid</code></td><td><code class="type">oid</code></td><td>这个索引的基表的 OID</td></tr><tr><td><code class="structfield">indexrelid</code></td><td><code class="type">oid</code></td><td>这个索引的 OID</td></tr><tr><td><code class="structfield">schemaname</code></td><td><code class="type">name</code></td><td>这个索引所在的模式的名称</td></tr><tr><td><code class="structfield">relname</code></td><td><code class="type">name</code></td><td>这个索引的基表的名称</td></tr><tr><td><code class="structfield">indexrelname</code></td><td><code class="type">name</code></td><td>这个索引的名称</td></tr><tr><td><code class="structfield">idx_scan</code></td><td><code class="type">bigint</code></td><td>在这个索引上发起的索引扫描次数</td></tr><tr><td><code class="structfield">idx_tup_read</code></td><td><code class="type">bigint</code></td><td>在这个索引上由扫描返回的索引项数量</td></tr><tr><td><code class="structfield">idx_tup_fetch</code></td><td><code class="type">bigint</code></td><td>被使用这个索引的简单索引扫描取得的活着的表行数量</td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_stat_all_indexes</code>视图将为当前数据库中的每个索引包含一行，该行显示关于对该索引访问的统计信息。<code class="structname">pg_stat_user_indexes</code>和<code class="structname">pg_stat_sys_indexes</code>视图包含相同的信息，但是被过滤得只分别显示用户和系统索引。
  </p><p>
   索引可以被简单索引扫描、<span class="quote">“<span class="quote">位图</span>”</span>索引扫描以及优化器使用。在一次位图扫描中，多个索引的输出可以被通过 AND 或 OR 规则组合，因此当使用一次位图扫描时难以将取得的个体堆行与特定的索引关联起来。因此，一次位图扫描会增加它使用的索引的<code class="structname">pg_stat_all_indexes</code>.<code class="structfield">idx_tup_read</code>计数，并且为每个表增加<code class="structname">pg_stat_all_tables</code>.<code class="structfield">idx_tup_fetch</code>计数，但是它不影响<code class="structname">pg_stat_all_indexes</code>.<code class="structfield">idx_tup_fetch</code>。如果所提供的常量值不在优化器统计信息记录的范围之内，优化器也会访问索引来检查，因为优化器统计信息可能已经“不新鲜”了。
  </p><div class="note"><h3 class="title">注意</h3><p>
    即使不用位图扫描，<code class="structfield">idx_tup_read</code>和<code class="structfield">idx_tup_fetch</code>计数也可能不同，因为<code class="structfield">idx_tup_read</code>统计从该索引取得的索引项而<code class="structfield">idx_tup_fetch</code>统计从表取得的或者的行。如果使用该索引取得了任何死亡行或还未提交的行，或者如果通过一次只用索引扫描的方式避免了任何堆获取，后者将较小。
   </p></div><div class="table" id="PG-STATIO-ALL-TABLES-VIEW"><p class="title"><strong>表 28.15. <code class="structname">pg_statio_all_tables</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_statio_all_tables视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">relid</code></td><td><code class="type">oid</code></td><td>一个表的 OID</td></tr><tr><td><code class="structfield">schemaname</code></td><td><code class="type">name</code></td><td>这个表所在的模式的名称</td></tr><tr><td><code class="structfield">relname</code></td><td><code class="type">name</code></td><td>这个表的名称</td></tr><tr><td><code class="structfield">heap_blks_read</code></td><td><code class="type">bigint</code></td><td>从这个表读取的磁盘块数量</td></tr><tr><td><code class="structfield">heap_blks_hit</code></td><td><code class="type">bigint</code></td><td>在这个表中的缓冲区命中数量</td></tr><tr><td><code class="structfield">idx_blks_read</code></td><td><code class="type">bigint</code></td><td>从这个表上所有索引中读取的磁盘块数</td></tr><tr><td><code class="structfield">idx_blks_hit</code></td><td><code class="type">bigint</code></td><td>在这个表上的所有索引中的缓冲区命中数量</td></tr><tr><td><code class="structfield">toast_blks_read</code></td><td><code class="type">bigint</code></td><td>从这个表的 TOAST 表（如果有）读取的磁盘块数</td></tr><tr><td><code class="structfield">toast_blks_hit</code></td><td><code class="type">bigint</code></td><td>在这个表的 TOAST 表（如果有）中的缓冲区命中数量</td></tr><tr><td><code class="structfield">tidx_blks_read</code></td><td><code class="type">bigint</code></td><td>从这个表的 TOAST 表索引（如果有）中读取的磁盘块数</td></tr><tr><td><code class="structfield">tidx_blks_hit</code></td><td><code class="type">bigint</code></td><td>在这个表的 TOAST 表索引（如果有）中的缓冲区命中数量</td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_statio_all_tables</code>视图将为当前数据库中的每个表（包括 TOAST 表）包含一行，该行显示指定表上有关 I/O 的统计信息。<code class="structname">pg_statio_user_tables</code>和<code class="structname">pg_statio_sys_tables</code>视图包含相同的信息，但是被过滤得分别只显示用户表和系统表。
  </p><div class="table" id="PG-STATIO-ALL-INDEXES-VIEW"><p class="title"><strong>表 28.16. <code class="structname">pg_statio_all_indexes</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_statio_all_indexes视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">relid</code></td><td><code class="type">oid</code></td><td>这个索引的基表的 OID</td></tr><tr><td><code class="structfield">indexrelid</code></td><td><code class="type">oid</code></td><td>这个索引的 OID</td></tr><tr><td><code class="structfield">schemaname</code></td><td><code class="type">name</code></td><td>这个索引所在的模式的名称</td></tr><tr><td><code class="structfield">relname</code></td><td><code class="type">name</code></td><td>这个索引的基表的名称</td></tr><tr><td><code class="structfield">indexrelname</code></td><td><code class="type">name</code></td><td>这个索引的名称</td></tr><tr><td><code class="structfield">idx_blks_read</code></td><td><code class="type">bigint</code></td><td>从这个索引读取的磁盘块数</td></tr><tr><td><code class="structfield">idx_blks_hit</code></td><td><code class="type">bigint</code></td><td>在这个索引中的缓冲区命中数量</td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_statio_all_indexes</code>视图将为当前数据库中的每个索引包含一行，该行显示指定索引上有关 I/O 的统计信息。<code class="structname">pg_statio_user_indexes</code>和<code class="structname">pg_statio_sys_indexes</code>视图包含相同的信息，但是被过滤得分别只显示用户索引和系统索引。
  </p><div class="table" id="PG-STATIO-ALL-SEQUENCES-VIEW"><p class="title"><strong>表 28.17. <code class="structname">pg_statio_all_sequences</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_statio_all_sequences视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">relid</code></td><td><code class="type">oid</code></td><td>一个序列的 OID</td></tr><tr><td><code class="structfield">schemaname</code></td><td><code class="type">name</code></td><td>这个序列所在的模式的名称</td></tr><tr><td><code class="structfield">relname</code></td><td><code class="type">name</code></td><td>这个序列的名称</td></tr><tr><td><code class="structfield">blks_read</code></td><td><code class="type">bigint</code></td><td>从这个序列中读取的磁盘块数</td></tr><tr><td><code class="structfield">blks_hit</code></td><td><code class="type">bigint</code></td><td>在这个序列中的缓冲区命中数量</td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_statio_all_sequences</code>视图将为当前数据库中的每个序列包含一行，该行显示在指定序列上有关 I/O 的统计信息。
  </p><div class="table" id="PG-STAT-USER-FUNCTIONS-VIEW"><p class="title"><strong>表 28.18. <code class="structname">pg_stat_user_functions</code>视图</strong></p><div class="table-contents"><table class="table" summary="pg_stat_user_functions视图" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>列</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">funcid</code></td><td><code class="type">oid</code></td><td>一个函数的 OID</td></tr><tr><td><code class="structfield">schemaname</code></td><td><code class="type">name</code></td><td>这个函数所在的模式的名称</td></tr><tr><td><code class="structfield">funcname</code></td><td><code class="type">name</code></td><td>这个函数的名称</td></tr><tr><td><code class="structfield">calls</code></td><td><code class="type">bigint</code></td><td>这个函数已经被调用的次数</td></tr><tr><td><code class="structfield">total_time</code></td><td><code class="type">double precision</code></td><td>在这个函数以及它所调用的其他函数中花费的总时间，以毫秒计</td></tr><tr><td><code class="structfield">self_time</code></td><td><code class="type">double precision</code></td><td>在这个函数本身花费的总时间，不包括被它调用的其他函数，以毫秒计</td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="structname">pg_stat_user_functions</code>视图将为每一个被追踪的函数包含一行，该行显示有关该函数执行的统计信息。<a class="xref" href="runtime-config-statistics.html#GUC-TRACK-FUNCTIONS">track_functions</a>参数控制到底哪些函数被跟踪。
  </p></div><div class="sect2" id="MONITORING-STATS-FUNCTIONS"><div class="titlepage"><div><div><h3 class="title">28.2.3. 统计函数</h3></div></div></div><p>
   其他查看统计信息的方法是直接使用查询，这些查询使用上述标准视图用到的底层统计信息访问函数。如要了解如函数名等细节，可参考标准视图的定义（例如，在<span class="application">psql</span>中你可以发出<code class="literal">\d+ pg_stat_activity</code>）。针对每一个数据库统计信息的访问函数把一个数据库 OID 作为参数来标识要报告哪个数据库。而针对每个表和每个索引的函数要求表或索引 OID。针对每个函数统计信息的函数用一个函数 OID。注意只有在当前数据库中的表、索引和函数才能被这些函数看到。
  </p><p>
   与统计收集相关的额外函数被列举在<a class="xref" href="monitoring-stats.html#MONITORING-STATS-FUNCS-TABLE" title="表 28.19. 额外统计函数">表 28.19</a>中。
  </p><div class="table" id="MONITORING-STATS-FUNCS-TABLE"><p class="title"><strong>表 28.19. 额外统计函数</strong></p><div class="table-contents"><table class="table" summary="额外统计函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>函数</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">pg_backend_pid()</code></code></td><td><code class="type">integer</code></td><td>
       处理当前会话的服务器进程的进程 ID
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_activity</code>(<code class="type">integer</code>)</code><a id="id-1.6.15.7.7.4.2.2.2.1.2" class="indexterm"></a></td><td><code class="type">setof record</code></td><td>
       返回具有指定 PID 的后端相关的一个记录，或者在指定<code class="symbol">NULL</code>的情况下为系统中每一个活动后端返回一个记录。被返回的域是<code class="structname">pg_stat_activity</code>视图中的那些域的一个子集。
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_snapshot_timestamp()</code></code><a id="id-1.6.15.7.7.4.2.2.3.1.2" class="indexterm"></a></td><td><code class="type">带时区的时间戳</code></td><td>
       返回当前统计信息快照的时间戳
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_clear_snapshot()</code></code><a id="id-1.6.15.7.7.4.2.2.4.1.2" class="indexterm"></a></td><td><code class="type">void</code></td><td>
       抛弃当前的统计快照
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_reset()</code></code><a id="id-1.6.15.7.7.4.2.2.5.1.2" class="indexterm"></a></td><td><code class="type">void</code></td><td>
       把用于当前数据库的所有统计计数器重置为零（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）。
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_reset_shared</code>(text)</code><a id="id-1.6.15.7.7.4.2.2.6.1.2" class="indexterm"></a></td><td><code class="type">void</code></td><td>
       把某些集簇范围的统计计数器重置为零，具体哪些取决于参数（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）。
       调用<code class="literal">pg_stat_reset_shared('bgwriter')</code>把<code class="structname">pg_stat_bgwriter</code>
       视图中显示的所有计数器清零。调用<code class="literal">pg_stat_reset_shared('archiver')</code>
       将会把<code class="structname">pg_stat_archiver</code>视图中展示的所有计数器清零。
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_reset_single_table_counters</code>(oid)</code><a id="id-1.6.15.7.7.4.2.2.7.1.2" class="indexterm"></a></td><td><code class="type">void</code></td><td>
       把当前数据库中用于单个表或索引的统计数据重置为零（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）
      </td></tr><tr><td><code class="literal"><code class="function">pg_stat_reset_single_function_counters</code>(oid)</code><a id="id-1.6.15.7.7.4.2.2.8.1.2" class="indexterm"></a></td><td><code class="type">void</code></td><td>
       把当前数据库中用于单个函数的统计信息重置为零（默认要求超级用户权限，但这个函数的 EXECUTE 可以被授予给其他人）
      </td></tr></tbody></table></div></div><br class="table-break" /><p>
   <code class="function">pg_stat_get_activity</code>是<code class="structname">pg_stat_activity</code>视图的底层函数，它返回一个行集合，其中包含有关每个后端进程所有可用的信息。有时只获得该信息的一个子集可能会更方便。在那些情况中，可以使用一组更老的针对每个后端的统计访问函数，这些显示在<a class="xref" href="monitoring-stats.html#MONITORING-STATS-BACKEND-FUNCS-TABLE" title="表 28.20. 针对每个后端的统计函数">表 28.20</a>中。这些访问函数使用一个后端 ID 号，范围从 1 到当前活动后端数目。函数<code class="function">pg_stat_get_backend_idset</code>提供了一种方便的方法为每个活动后端产生一行来调用这些函数。例如，要显示<acronym class="acronym">PID</acronym>以及所有后端当前的查询：

</p><pre class="programlisting">
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</pre><p>
  </p><div class="table" id="MONITORING-STATS-BACKEND-FUNCS-TABLE"><p class="title"><strong>表 28.20. 针对每个后端的统计函数</strong></p><div class="table-contents"><table class="table" summary="针对每个后端的统计函数" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>函数</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td><code class="literal"><code class="function">pg_stat_get_backend_idset()</code></code></td><td><code class="type">setof integer</code></td><td>当前活动后端 ID 号的集合（从 1 到活动后端数目）</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_activity(integer)</code></code></td><td><code class="type">text</code></td><td>这个后端最近查询的文本</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_activity_start(integer)</code></code></td><td><code class="type">timestamp with time zone</code></td><td>最近查询被开始的时间</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_client_addr(integer)</code></code></td><td><code class="type">inet</code></td><td>该客户端连接到这个后端的 IP 地址</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_client_port(integer)</code></code></td><td><code class="type">integer</code></td><td>该客户端用来通信的 TCP 端口号</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_dbid(integer)</code></code></td><td><code class="type">oid</code></td><td>这个后端连接到的数据库的 OID</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_pid(integer)</code></code></td><td><code class="type">integer</code></td><td>这个后端的进程 ID</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_start(integer)</code></code></td><td><code class="type">timestamp with time zone</code></td><td>这个进程被开始的时间</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_userid(integer)</code></code></td><td><code class="type">oid</code></td><td>登录到这个后端的用户的 OID</td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_wait_event_type(integer)</code></code></td><td><code class="type">text</code></td><td>如果后端正在等待，则是等待事件类型的名称，否则为 NULL。详见<a class="xref" href="monitoring-stats.html#WAIT-EVENT-TABLE" title="表 28.4. wait_event 描述">表 28.4</a>。
        </td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_wait_event(integer)</code></code></td><td><code class="type">text</code></td><td>如果后端正在等待，则是等待事件的名称，否则为 NULL。详见<a class="xref" href="monitoring-stats.html#WAIT-EVENT-TABLE" title="表 28.4. wait_event 描述">表 28.4</a>。
       </td></tr><tr><td><code class="literal"><code class="function">pg_stat_get_backend_xact_start(integer)</code></code></td><td><code class="type">timestamp with time zone</code></td><td>当前事务被开始的时间</td></tr></tbody></table></div></div><br class="table-break" /></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="monitoring-ps.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="monitoring.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="monitoring-locks.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">28.1. 标准 Unix 工具 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 28.3. 查看锁</td></tr></table></div></body></html>