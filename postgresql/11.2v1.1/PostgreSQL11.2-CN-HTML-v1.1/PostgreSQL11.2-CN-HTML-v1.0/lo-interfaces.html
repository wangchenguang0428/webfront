<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>35.3. 客户端接口</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="lo-implementation.html" title="35.2. 实现特性" /><link rel="next" href="lo-funcs.html" title="35.4. 服务器端函数" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">35.3. 客户端接口</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="lo-implementation.html" title="35.2. 实现特性">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="largeobjects.html" title="第 35 章 大对象">上一级</a></td><th width="60%" align="center">第 35 章 大对象</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="lo-funcs.html" title="35.4. 服务器端函数">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="LO-INTERFACES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">35.3. 客户端接口</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="lo-interfaces.html#LO-CREATE">35.3.1. 创建一个大对象</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-IMPORT">35.3.2. 导入一个大对象</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-EXPORT">35.3.3. 导出一个大对象</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-OPEN">35.3.4. 打开一个现有的大对象</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-WRITE">35.3.5. 向一个大对象写入数据</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-READ">35.3.6. 从一个大对象读取数据</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-SEEK">35.3.7. 在一个大对象中查找</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-TELL">35.3.8. 获取一个大对象的查找位置</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-TRUNCATE">35.3.9. 截断一个大对象</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-CLOSE">35.3.10. 关闭一个大对象描述符</a></span></dt><dt><span class="sect2"><a href="lo-interfaces.html#LO-UNLINK">35.3.11. 移除一个大对象</a></span></dt></dl></div><p>
    本节描述<span class="productname">PostgreSQL</span>的<span class="application">libpq</span>客户端接口为访问大对象所提供的功能。<span class="productname">PostgreSQL</span>的大对象接口按照<acronym class="acronym">Unix</acronym>文件系统的接口建模，也有相似的<code class="function">open</code>、<code class="function">read</code>、<code class="function">write</code>、<code class="function">lseek</code>等。
   </p><p>
    所有使用这些函数对大对象的操作都<span class="emphasis"><em>必须</em></span>发生在一个SQL事务块中，因为大对象文件描述符只在事务期间有效。
   </p><p>
    在执行任何一个这种函数期间如果发生一个错误，该函数将会返回一个其他的不可能值，典型的是0或-1。一个关于该错误的消息亦会被保存在连接对象中，可以通过<code class="function">PQerrorMessage</code>检索到。
   </p><p>
    使用这些函数的客户端应用应该包括头文件<code class="filename">libpq/libpq-fs.h</code>并链接<span class="application">libpq</span>库。
   </p><div class="sect2" id="LO-CREATE"><div class="titlepage"><div><div><h3 class="title">35.3.1. 创建一个大对象</h3></div></div></div><p>
     <a id="id-1.7.4.8.6.2.1" class="indexterm"></a>
     函数
</p><pre class="synopsis">
Oid lo_creat(PGconn *conn, int mode);
</pre><p>
     创建一个新的大对象。其返回值是分配给这个新大对象的OID或者<code class="symbol">InvalidOid</code>（0）表示失败。

     <em class="replaceable"><code>mode</code></em>自<span class="productname">PostgreSQL</span> 8.1就不再使用且会被忽略。但是，为了和以前的发行兼容，它最好被设置为<code class="symbol">INV_READ</code>、<code class="symbol">INV_WRITE</code>或<code class="symbol">INV_READ</code> <code class="literal">|</code> <code class="symbol">INV_WRITE</code>（这些符号常量定义在头文件<code class="filename">libpq/libpq-fs.h</code>中）。
    </p><p>
     一个例子：
</p><pre class="programlisting">
inv_oid = lo_creat(conn, INV_READ|INV_WRITE);
</pre><p>
    </p><p>
     <a id="id-1.7.4.8.6.4.1" class="indexterm"></a>
     函数
</p><pre class="synopsis">
Oid lo_create(PGconn *conn, Oid lobjId);
</pre><p>
     也创建一个新的大对象。分配给该大对象的OID可以通过<em class="replaceable"><code>lobjId</code></em>指定，如果这样做，该OID已经被某个大对象使用时会产生错误。如果<em class="replaceable"><code>lobjId</code></em>是<code class="symbol">InvalidOid</code>（0），则<code class="function">lo_create</code>会分配一个未使用的OID（这时和<code class="function">lo_creat</code>的行为相同）。返回值是分配给新大对象的OID或<code class="symbol">InvalidOid</code>（0）表示发生错误。
    </p><p>
     <code class="function">lo_create</code>在从<span class="productname">PostgreSQL</span> 8.1开始的版本中是新的，如果该函数在旧服务器版本上运行，它将失败并返回<code class="symbol">InvalidOid</code>。
    </p><p>
     一个例子：
</p><pre class="programlisting">
inv_oid = lo_create(conn, desired_oid);
</pre><p>
    </p></div><div class="sect2" id="LO-IMPORT"><div class="titlepage"><div><div><h3 class="title">35.3.2. 导入一个大对象</h3></div></div></div><p>
     <a id="id-1.7.4.8.7.2.1" class="indexterm"></a>
     要将一个操作系统文件导入成一个大对象，调用：
</p><pre class="synopsis">
Oid lo_import(PGconn *conn, const char *filename);
</pre><p>
     <em class="replaceable"><code>filename</code></em>指定了要导入为大对象的操作系统文件名。返回值是分配给新大对象的OID或<code class="symbol">InvalidOid</code>（0）表示发生错误。注意该文件是被客户端接口库而不是服务器所读取，因此它必须存在于客户端文件系统中并且对于客户端应用是可读的。
    </p><p>
     <a id="id-1.7.4.8.7.3.1" class="indexterm"></a>
     函数
</p><pre class="synopsis">
Oid lo_import_with_oid(PGconn *conn, const char *filename, Oid lobjId);
</pre><p>
     也可以导入一个新大对象。分配给新大对象的OID可以用<em class="replaceable"><code>lobjId</code></em>指定，如果这样做，该OID已经被某个大对象使用时会产生错误。如果<em class="replaceable"><code>lobjId</code></em>是<code class="symbol">InvalidOid</code>（0），则<code class="function">lo_import_with_oid</code>会分配一个未使用的OID（这和<code class="function">lo_import</code>的行为相同）。返回值是分配给新大对象的OID或<code class="symbol">InvalidOid</code>（0）表示发生错误。
    </p><p>
     <code class="function">lo_import_with_oid</code>在从<span class="productname">PostgreSQL</span> 8.1开始的版本中是新的并且在内部使用了<code class="function">lo_create</code>（在8.1中也是新的），如果该函数在旧服务器版本上运行，它将失败并返回<code class="symbol">InvalidOid</code>。
    </p></div><div class="sect2" id="LO-EXPORT"><div class="titlepage"><div><div><h3 class="title">35.3.3. 导出一个大对象</h3></div></div></div><p>
     <a id="id-1.7.4.8.8.2.1" class="indexterm"></a>
     要把一个大对象导出到一个操作系统文件，调用：
</p><pre class="synopsis">
int lo_export(PGconn *conn, Oid lobjId, const char *filename);
</pre><p>
     <em class="parameter"><code>lobjId</code></em>参数指定要导出的大对象的OID，<em class="parameter"><code>filename</code></em>参数指定操作系统文件名。注意该文件是被客户端接口库而不是服务器写入。成功返回1，错误返回-1。
    </p></div><div class="sect2" id="LO-OPEN"><div class="titlepage"><div><div><h3 class="title">35.3.4. 打开一个现有的大对象</h3></div></div></div><p>
     <a id="id-1.7.4.8.9.2.1" class="indexterm"></a>
     要打开一个现有的大对象进行读写，调用：
</p><pre class="synopsis">
int lo_open(PGconn *conn, Oid lobjId, int mode);
</pre><p>
     <em class="parameter"><code>lobjId</code></em>参数指定要打开的大对象的OID。<em class="parameter"><code>mode</code></em>位控制着打开对象是为了只读（<code class="symbol">INV_READ</code>）、只写（<code class="symbol">INV_WRITE</code>）或者读写（这些符号常量定义在头文件<code class="filename">libpq/libpq-fs.h</code>中）。<code class="function">lo_open</code>返回一个（非负）大对象描述符以便后面用于<code class="function">lo_read</code>、<code class="function">lo_write</code>、<code class="function">lo_lseek</code>、<code class="function">lo_lseek64</code>、<code class="function">lo_tell</code>、<code class="function">lo_tell64</code>、<code class="function">lo_truncate</code>、<code class="function">lo_truncate64</code>以及<code class="function">lo_close</code>。该描述符只在当前事务期间有效。如果打开错误将会返回-1。
    </p><p>
     服务器目前并不区分模式<code class="symbol">INV_WRITE</code>和<code class="symbol">INV_READ</code> <code class="literal">|</code><code class="symbol">INV_WRITE</code>：在两种情况中都允许从描述符读取。但是在这些模式和单独的<code class="symbol">INV_READ</code>之间有明显的区别：使用<code class="symbol">INV_READ</code>我们不能向描述符写入，从中读取的数据则反映了该大对象在活动事务快照时刻的内容（该快照在<code class="function">lo_open</code>被执行时创建），而不管之后被该事务或其他事务写入的内容。从一个以<code class="symbol">INV_WRITE</code>模式打开的描述符读取的数据所有其他已提交事务以及当前事务所作的写入。这与普通SQL命令 <code class="command">SELECT</code>的<code class="literal">REPEATABLE READ</code>和<code class="literal">READ COMMITTED</code>事务模式之间的区别相似。
    </p><p>
     如果大对象的<code class="literal">SELECT</code>特权不可用，或者如果在指定了<code class="symbol">INV_WRITE</code>时<code class="literal">UPDATE</code>特权不可用，则<code class="function">lo_open</code>将会失败（在<span class="productname">PostgreSQL</span> 11之前，这些特权的检查是在使用该描述符的第一次实际读取或写入时进行）。这些特权检查可以用<a class="xref" href="runtime-config-compatible.html#GUC-LO-COMPAT-PRIVILEGES">lo_compat_privileges</a>运行时参数禁用。
    </p><p>
     一个例子：
</p><pre class="programlisting">
inv_fd = lo_open(conn, inv_oid, INV_READ|INV_WRITE);
</pre><p>
    </p></div><div class="sect2" id="LO-WRITE"><div class="titlepage"><div><div><h3 class="title">35.3.5. 向一个大对象写入数据</h3></div></div></div><p>
     <a id="id-1.7.4.8.10.2.1" class="indexterm"></a>
     函数
</p><pre class="synopsis">
int lo_write(PGconn *conn, int fd, const char *buf, size_t len);
</pre><p>
     从<em class="parameter"><code>buf</code></em>（大小必须是 <em class="parameter"><code>len</code></em>）中写出<em class="parameter"><code>len</code></em>字节到大对象描述符<em class="parameter"><code>fd</code></em>。参数<em class="parameter"><code>fd</code></em>必须是已经由前面的<code class="function">lo_open</code>返回的大对象描述符。函数将返回实际写入的字节数（在当前的实现中，除非出错，返回的字节数总是等于<em class="parameter"><code>len</code></em>）。在出错时，返回值为-1。
</p><p>
     尽管参数<em class="parameter"><code>len</code></em>被声明为类型<code class="type">size_t</code>，该函数会拒绝超过<code class="literal">INT_MAX</code>的长度值。在实际中，被传送的数据最好是每块最多数兆字节。
</p></div><div class="sect2" id="LO-READ"><div class="titlepage"><div><div><h3 class="title">35.3.6. 从一个大对象读取数据</h3></div></div></div><p>
     <a id="id-1.7.4.8.11.2.1" class="indexterm"></a>
     函数
</p><pre class="synopsis">
int lo_read(PGconn *conn, int fd, char *buf, size_t len);
</pre><p>
     从大对象描述符<em class="parameter"><code>fd</code></em>中读取最多<em class="parameter"><code>len</code></em>字节到<em class="parameter"><code>buf</code></em> （大小必须是<em class="parameter"><code>len</code></em>）中。参数<em class="parameter"><code>fd</code></em>必须是已经由前面的<code class="function">lo_open</code>返回的大对象描述符。实际读出的字节数将被返回，如果先到达了大对象的末尾返回值可能会小于<em class="parameter"><code>len</code></em>。出错时返回值为-1。
</p><p>
     尽管参数<em class="parameter"><code>len</code></em>被声明为类型<code class="type">size_t</code>，该函数会拒绝超过<code class="literal">INT_MAX</code>的长度值。在实际中，被传送的数据最好是每块最多数兆字节。
</p></div><div class="sect2" id="LO-SEEK"><div class="titlepage"><div><div><h3 class="title">35.3.7. 在一个大对象中查找</h3></div></div></div><p>
     <a id="id-1.7.4.8.12.2.1" class="indexterm"></a>
     要改变一个大对象描述符的当前读或写位置，调用：
</p><pre class="synopsis">
int lo_lseek(PGconn *conn, int fd, int offset, int whence);
</pre><p>
     该函数将大对象文件描述符<em class="parameter"><code>fd</code></em>的当前位置指针移动到由<em class="parameter"><code>offset</code></em>指定的新位置。<em class="parameter"><code>whence</code></em>的可用值是<code class="symbol">SEEK_SET</code>（从对象开头定位）、<code class="symbol">SEEK_CUR</code> （从当前位置定位）以及<code class="symbol">SEEK_END</code>（从对象末尾定位）。返回值是新位置的指针，或者是-1表示出错。
</p><p>
     <a id="id-1.7.4.8.12.3.1" class="indexterm"></a>
     在处理可能超过2GB大小的大对象时，换用
</p><pre class="synopsis">
pg_int64 lo_lseek64(PGconn *conn, int fd, pg_int64 offset, int whence);
</pre><p>
     该函数的行为和<code class="function">lo_lseek</code>相同，但是它能接受一个超过2GB的<em class="parameter"><code>offset</code></em>并/或传送一个超过2GB的结果。注意如果新位置的指针超过2GB，<code class="function">lo_lseek</code>会失败。
</p><p>
     <code class="function">lo_lseek64</code>是从 <span class="productname">PostgreSQL</span> 9.3开始增加的新函数。如果该函数在一个旧服务器版本上执行，将会失败并返回-1。
</p></div><div class="sect2" id="LO-TELL"><div class="titlepage"><div><div><h3 class="title">35.3.8. 获取一个大对象的查找位置</h3></div></div></div><p>
     <a id="id-1.7.4.8.13.2.1" class="indexterm"></a>
     要得到一个大对象描述符的当前读或写位置，调用：
</p><pre class="synopsis">
int lo_tell(PGconn *conn, int fd);
</pre><p>
     如果出现错误，返回值是-1。
</p><p>
     <a id="id-1.7.4.8.13.3.1" class="indexterm"></a>
     在处理可能超过2GB大小的大对象时，换用：
</p><pre class="synopsis">
pg_int64 lo_tell64(PGconn *conn, int fd);
</pre><p>
     该函数和<code class="function">lo_tell</code>的行为相同，但是它能传递超过2GB的结果。注意如果当前读/写位置超过2GB，<code class="function">lo_tell</code>将会失败。
</p><p>
     <code class="function">lo_tell64</code>是从<span class="productname">PostgreSQL</span> 9.3开始新增的函数。如果该函数在旧服务器版本上运行，将会失败并返回-1。
</p></div><div class="sect2" id="LO-TRUNCATE"><div class="titlepage"><div><div><h3 class="title">35.3.9. 截断一个大对象</h3></div></div></div><p>
     <a id="id-1.7.4.8.14.2.1" class="indexterm"></a>
     要将一个大对象截断成一个给定长度，调用：
</p><pre class="synopsis">
int lo_truncate(PGcon *conn, int fd, size_t len);
</pre><p>
     该函数将大对象描述符<em class="parameter"><code>fd</code></em>截断为长度<em class="parameter"><code>len</code></em>。参数<em class="parameter"><code>fd</code></em>必须是已经由前面的<code class="function">lo_open</code>返回的大对象描述符。如果<em class="parameter"><code>len</code></em>超过了大对象的当前长度，大对象将会被使用空字节（'\0'）扩展到指定长度。成功时<code class="function">lo_truncate</code>返回0，失败时返回值为-1。
</p><p>
     描述<em class="parameter"><code>fd</code></em>的读/写位置不变。
</p><p>
     尽管参数<em class="parameter"><code>len</code></em>被声明为类型<code class="type">size_t</code>，<code class="function">lo_truncate</code>会拒绝超过<code class="literal">INT_MAX</code>的长度值。
</p><p>
     <a id="id-1.7.4.8.14.5.1" class="indexterm"></a>
     在处理可能超过2GB大小的大对象时，换用：
</p><pre class="synopsis">
int lo_truncate64(PGcon *conn, int fd, pg_int64 len);
</pre><p>
     该函数和<code class="function">lo_truncate</code>的行为相同，但它能够接受超过2GB的<em class="parameter"><code>len</code></em>值。
</p><p>
     <code class="function">lo_truncate</code>是从<span class="productname">PostgreSQL</span> 8.3开始新的函数，如果该函数运行在一个旧服务器版本上，它将失败并返回-1。
</p><p>
     <code class="function">lo_truncate64</code>是从<span class="productname">PostgreSQL</span> 9.3开始新的函数，如果该函数运行在一个旧服务器版本上，它将失败并返回-1。
</p></div><div class="sect2" id="LO-CLOSE"><div class="titlepage"><div><div><h3 class="title">35.3.10. 关闭一个大对象描述符</h3></div></div></div><p>
     <a id="id-1.7.4.8.15.2.1" class="indexterm"></a>
     要关闭一个大对象描述符，调用：
</p><pre class="synopsis">
int lo_close(PGconn *conn, int fd);
</pre><p>
     其中<em class="parameter"><code>fd</code></em>是由<code class="function">lo_open</code>返回的大对象描述符。成功时，<code class="function">lo_close</code>返回0，失败时返回-1。
</p><p>
     在事务末尾仍然保持打开的任何大对象描述符都会自动被关闭。
</p></div><div class="sect2" id="LO-UNLINK"><div class="titlepage"><div><div><h3 class="title">35.3.11. 移除一个大对象</h3></div></div></div><p>
     <a id="id-1.7.4.8.16.2.1" class="indexterm"></a>
     要从数据库中移除一个大对象，调用：
</p><pre class="synopsis">
int lo_unlink(PGconn *conn, Oid lobjId);
</pre><p>
     <em class="parameter"><code>lobjId</code></em>参数指定要移除的大对象的OID。成功时返回1，失败时返回-1。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="lo-implementation.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="largeobjects.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="lo-funcs.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">35.2. 实现特性 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 35.4. 服务器端函数</td></tr></table></div></body></html>