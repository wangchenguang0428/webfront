<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>SELECT</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="sql-security-label.html" title="SECURITY LABEL" /><link rel="next" href="sql-selectinto.html" title="SELECT INTO" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">SELECT</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="sql-security-label.html" title="SECURITY LABEL">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="sql-commands.html" title="SQL 命令">上一级</a></td><th width="60%" align="center">SQL 命令</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="sql-selectinto.html" title="SELECT INTO">下一页</a></td></tr></table><hr></hr></div><div class="refentry" id="SQL-SELECT"><div class="titlepage"></div><a id="id-1.9.3.171.1" class="indexterm"></a><a id="id-1.9.3.171.2" class="indexterm"></a><a id="id-1.9.3.171.3" class="indexterm"></a><div class="refnamediv"><h2><span class="refentrytitle">SELECT</span></h2><p>SELECT, TABLE, WITH — 从一个表或视图检索行</p></div><div class="refsynopsisdiv"><h2>大纲</h2><pre class="synopsis">
[ WITH [ RECURSIVE ] <em class="replaceable"><code>with_query</code></em> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <em class="replaceable"><code>expression</code></em> [, ...] ) ] ]
    [ * | <em class="replaceable"><code>expression</code></em> [ [ AS ] <em class="replaceable"><code>output_name</code></em> ] [, ...] ]
    [ FROM <em class="replaceable"><code>from_item</code></em> [, ...] ]
    [ WHERE <em class="replaceable"><code>condition</code></em> ]
    [ GROUP BY <em class="replaceable"><code>grouping_element</code></em> [, ...] ]
    [ HAVING <em class="replaceable"><code>condition</code></em> [, ...] ]
    [ WINDOW <em class="replaceable"><code>window_name</code></em> AS ( <em class="replaceable"><code>window_definition</code></em> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <em class="replaceable"><code>select</code></em> ]
    [ ORDER BY <em class="replaceable"><code>expression</code></em> [ ASC | DESC | USING <em class="replaceable"><code>operator</code></em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <em class="replaceable"><code>count</code></em> | ALL } ]
    [ OFFSET <em class="replaceable"><code>start</code></em> [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <em class="replaceable"><code>count</code></em> ] { ROW | ROWS } ONLY ]
    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <em class="replaceable"><code>table_name</code></em> [, ...] ] [ NOWAIT ] [...] ]

<span class="phrase">其中 <em class="replaceable"><code>from_item</code></em> 可以是以下之一：</span>

    [ ONLY ] <em class="replaceable"><code>table_name</code></em> [ * ] [ [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ] ]
                [ TABLESAMPLE <em class="replaceable"><code>sampling_method</code></em> ( <em class="replaceable"><code>argument</code></em> [, ...] ) [ REPEATABLE ( <em class="replaceable"><code>seed</code></em> ) ] ]

    [ LATERAL ] ( <em class="replaceable"><code>select</code></em> ) [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ]
    <em class="replaceable"><code>with_query_name</code></em> [ [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ] ]
    [ LATERAL ] <em class="replaceable"><code>function_name</code></em> ( [ <em class="replaceable"><code>argument</code></em> [, ...] ] )
                [ WITH ORDINALITY ] [ [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ] ]
    [ LATERAL ] <em class="replaceable"><code>function_name</code></em> ( [ <em class="replaceable"><code>argument</code></em> [, ...] ] ) [ AS ] <em class="replaceable"><code>alias</code></em> ( <em class="replaceable"><code>column_definition</code></em> [, ...] )
    [ LATERAL ] <em class="replaceable"><code>function_name</code></em> ( [ <em class="replaceable"><code>argument</code></em> [, ...] ] ) AS ( <em class="replaceable"><code>column_definition</code></em> [, ...] )
    [ LATERAL ] ROWS FROM( <em class="replaceable"><code>function_name</code></em> ( [ <em class="replaceable"><code>argument</code></em> [, ...] ] ) [ AS ( <em class="replaceable"><code>column_definition</code></em> [, ...] ) ] [, ...] )
                [ WITH ORDINALITY ] [ [ AS ] <em class="replaceable"><code>alias</code></em> [ ( <em class="replaceable"><code>column_alias</code></em> [, ...] ) ] ]
    <em class="replaceable"><code>from_item</code></em> [ NATURAL ] <em class="replaceable"><code>join_type</code></em> <em class="replaceable"><code>from_item</code></em> [ ON <em class="replaceable"><code>join_condition</code></em> | USING ( <em class="replaceable"><code>join_column</code></em> [, ...] ) ]

<span class="phrase">并且 <em class="replaceable"><code>grouping_element</code></em> 可以是以下之一：</span>

    ( )
    <em class="replaceable"><code>expression</code></em>
    ( <em class="replaceable"><code>expression</code></em> [, ...] )
    ROLLUP ( { <em class="replaceable"><code>expression</code></em> | ( <em class="replaceable"><code>expression</code></em> [, ...] ) } [, ...] )
    CUBE ( { <em class="replaceable"><code>expression</code></em> | ( <em class="replaceable"><code>expression</code></em> [, ...] ) } [, ...] )
    GROUPING SETS ( <em class="replaceable"><code>grouping_element</code></em> [, ...] )
    
<span class="phrase">并且 <em class="replaceable"><code>with_query</code></em> 是：</span>

    <em class="replaceable"><code>with_query_name</code></em> [ ( <em class="replaceable"><code>column_name</code></em> [, ...] ) ] AS ( <em class="replaceable"><code>select</code></em> | <em class="replaceable"><code>values</code></em> | <em class="replaceable"><code>insert</code></em> | <em class="replaceable"><code>update</code></em> | <em class="replaceable"><code>delete</code></em> )

TABLE [ ONLY ] <em class="replaceable"><code>table_name</code></em> [ * ]
</pre></div><div class="refsect1" id="id-1.9.3.171.7"><h2>描述</h2><p>
   <code class="command">SELECT</code>从零或更多表中检索行。
   <code class="command">SELECT</code>的通常处理如下：

   </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
      <code class="literal">WITH</code>列表中的所有查询都会被计算。这些查询实际
      充当了在<code class="literal">FROM</code>列表中可以引用的临时表。在
      <code class="literal">FROM</code>中被引用多次的<code class="literal">WITH</code>查
      询只会被计算一次（见下文的
      <a class="xref" href="sql-select.html#SQL-WITH" title="WITH 子句"><code class="literal">WITH</code> 子句</a>）。
     </p></li><li class="listitem"><p>
      <code class="literal">FROM</code>列表中的所有元素都会被计算（
      <code class="literal">FROM</code>中的每一个元素都是一个真实表或者虚拟表）。
      如果在<code class="literal">FROM</code>列表中指定了多于一个元素，它们会被
      交叉连接在一起（见下文的
      <a class="xref" href="sql-select.html#SQL-FROM" title="FROM 子句"><code class="literal">FROM</code> 子句</a>）。
     </p></li><li class="listitem"><p>
      如果指定了<code class="literal">WHERE</code>子句，所有不满足该条件的行都会
      被从输出中消除（见下文的<a class="xref" href="sql-select.html#SQL-WHERE" title="WHERE 子句"><code class="literal">WHERE</code> 子句</a>）。
     </p></li><li class="listitem"><p>
      如果指定了<code class="literal">GROUP BY</code>子句或者如果有聚集函数，输出
      会被组合成由在一个或者多个值上匹配的行构成的分组，并且在其上计算聚
      集函数的结果。如果出现了<code class="literal">HAVING</code>子句，它会消除不
      满足给定条件的分组（见下文的
      <a class="xref" href="sql-select.html#SQL-GROUPBY" title="GROUP BY 子句"><code class="literal">GROUP BY</code> 子句</a>以及
      <a class="xref" href="sql-select.html#SQL-HAVING" title="HAVING 子句"><code class="literal">HAVING</code> 子句</a>）。
     </p></li><li class="listitem"><p>
      对于每一个被选中的行或者行组，会使用<code class="command">SELECT</code>
      输出表达式计算实际的输出行（见下文的
      <a class="xref" href="sql-select.html#SQL-SELECT-LIST" title="SELECT 列表"><code class="command">SELECT</code> 列表</a>）。
     </p></li><li class="listitem"><p><code class="literal">SELECT DISTINCT</code>从结果中消除重复的行。
      <code class="literal">SELECT DISTINCT ON</code>消除在所有指定表达式上匹
      配的行。<code class="literal">SELECT ALL</code>（默认）将返回所有候选行，
      包括重复的行（见下文的<a class="xref" href="sql-select.html#SQL-DISTINCT" title="DISTINCT 子句"><code class="literal">DISTINCT</code> 子句</a>）。
     </p></li><li class="listitem"><p>
      通过使用操作符<code class="literal">UNION</code>、
      <code class="literal">INTERSECT</code>和<code class="literal">EXCEPT</code>，多于
      一个<code class="command">SELECT</code>语句的输出可以被整合形成
      一个结果集。<code class="literal">UNION</code>操作符返回位于一个或者两
      个结果集中的全部行。<code class="literal">INTERSECT</code>操作符返回同时
      位于两个结果集中的所有行。<code class="literal">EXCEPT</code>操作符返回
      位于第一个结果集但不在第二个结果集中的行。在所有三种情况下，
      重复行都会被消除（除非指定<code class="literal">ALL</code>）。可以增加噪
      声词<code class="literal">DISTINCT</code>来显式地消除重复行。注意虽然
      <code class="literal">ALL</code>是<code class="command">SELECT</code>自身的默认行为，
      但这里<code class="literal">DISTINCT</code>是默认行为（见下文的
      <a class="xref" href="sql-select.html#SQL-UNION" title="UNION 子句"><code class="literal">UNION</code> 子句</a>、<a class="xref" href="sql-select.html#SQL-INTERSECT" title="INTERSECT 子句"><code class="literal">INTERSECT</code> 子句</a>以及
      <a class="xref" href="sql-select.html#SQL-EXCEPT" title="EXCEPT 子句"><code class="literal">EXCEPT</code> 子句</a>）。
     </p></li><li class="listitem"><p>
      如果指定了<code class="literal">ORDER BY</code>子句，被返回的行会以指定的
      顺序排序。如果没有给定<code class="literal">ORDER BY</code>，系统会以能最
      快产生行的顺序返回它们（见下文的
      <a class="xref" href="sql-select.html#SQL-ORDERBY" title="ORDER BY 子句"><code class="literal">ORDER BY</code> 子句</a>）。
     </p></li><li class="listitem"><p>
      如果指定了<code class="literal">LIMIT</code>（或<code class="literal">FETCH FIRST</code>）
      或者<code class="literal">OFFSET</code>子句，<code class="command">SELECT</code>
      语句只返回结果行的一个子集（见下文的<a class="xref" href="sql-select.html#SQL-LIMIT" title="LIMIT 子句"><code class="literal">LIMIT</code> 子句</a>）。
     </p></li><li class="listitem"><p>
      如果指定了<code class="literal">FOR UPDATE</code>、
      <code class="literal">FOR NO KEY UPDATE</code>、
      <code class="literal">FOR SHARE</code>
      或者<code class="literal">FOR KEY SHARE</code>，
      <code class="command">SELECT</code>语句会把被选中的行锁定而不让并发
      更新访问它们（见下文的<a class="xref" href="sql-select.html#SQL-FOR-UPDATE-SHARE" title="锁定子句">锁定子句</a>）。
     </p></li></ol></div><p>
  </p><p>
   你必须拥有在一个<code class="command">SELECT</code>命令中使用的每一列上的
   <code class="literal">SELECT</code>特权。<code class="literal">FOR NO KEY UPDATE</code>、
   <code class="literal">FOR UPDATE</code>、
   <code class="literal">FOR SHARE</code>或者<code class="literal">FOR KEY SHARE</code>
   还要求（对这样选中的每一个表至少一列的）<code class="literal">UPDATE</code>
   特权。
  </p></div><div class="refsect1" id="id-1.9.3.171.8"><h2>参数</h2><div class="refsect2" id="SQL-WITH"><h3><code class="literal">WITH</code> 子句</h3><p>
    <code class="literal">WITH</code>子句允许你指定一个或者多个在主查询中可以
    其名称引用的子查询。在主查询期间子查询实际扮演了临时表或者视图
    的角色。每一个子查询都可以是一个<code class="command">SELECT</code>、
    <code class="command">TABLE</code>、<code class="command">VALUES</code>、
    <code class="command">INSERT</code>、
    <code class="command">UPDATE</code>或者
    <code class="command">DELETE</code>语句。在<code class="literal">WITH</code>中书写
    一个数据修改语句（<code class="command">INSERT</code>、
    <code class="command">UPDATE</code>或者
    <code class="command">DELETE</code>）时，通常要包括一个
    <code class="literal">RETURNING</code>子句。构成被主查询读取的临时表的是
    <code class="literal">RETURNING</code>的输出，而<span class="emphasis"><em>不是</em></span>该语句修改的
    底层表。如果省略<code class="literal">RETURNING</code>，该语句仍会被执行，但是它
    不会产生输出，因此它不能作为一个表从主查询引用。
   </p><p>
    对于每一个<code class="literal">WITH</code>查询，都必须指定一个名称（无需模
    式限定）。可选地，可以指定一个列名列表。如果省略该列表，会从该子查
    询中推导列名。
   </p><p>
    如果指定了<code class="literal">RECURSIVE</code>，则允许一个
    <code class="command">SELECT</code>子查询使用名称引用自身。
    这样一个子查询的形式必须是
</p><pre class="synopsis">
<em class="replaceable"><code>non_recursive_term</code></em> UNION [ ALL | DISTINCT ] <em class="replaceable"><code>recursive_term</code></em>
</pre><p>
    其中递归自引用必须出现在<code class="literal">UNION</code>的右手边。每个
    查询中只允许一个递归自引用。不支持递归数据修改语句，但是
    可以在一个数据查询语句中使用一个递归
    <code class="command">SELECT</code>查询的结果。例子可见
    <a class="xref" href="queries-with.html" title="7.8. WITH查询（公共表表达式）">第 7.8 节</a>。
   </p><p>
    <code class="literal">RECURSIVE</code>的另一个效果是
    <code class="literal">WITH</code>查询不需要被排序：一个查询可以引用另一个
    在列表中比它靠后的查询（不过，循环引用或者互递归没有实现）。
    如果没有<code class="literal">RECURSIVE</code>，<code class="literal">WITH</code>
    查询只能引用在<code class="literal">WITH</code>列表中位置更前面的兄弟
    <code class="literal">WITH</code>查询。
   </p><p>
    <code class="literal">WITH</code>查询的一个关键特性是，对主查询的每次
    查询它们都只计算一次，即使该主查询引用它们多次也是如此。特别
    是，不管主查询读取数据修改语句的多少输出，数据修改语句都被保
    证仅执行一次。
   </p><p>
    主查询以及<code class="literal">WITH</code>查询全部（理论上）在同一时间
    被执行。这意味着从该查询的任何部分都无法看到
    <code class="literal">WITH</code>中的一个数据修改语句的效果，不过可以读
    取其<code class="literal">RETURNING</code>输出。如果两个这样的数据修改语句
    尝试修改相同的行，结果将无法确定。
   </p><p>
    更多信息请见<a class="xref" href="queries-with.html" title="7.8. WITH查询（公共表表达式）">第 7.8 节</a>。
   </p></div><div class="refsect2" id="SQL-FROM"><h3><code class="literal">FROM</code> 子句</h3><p>
    <code class="literal">FROM</code>子句为<code class="command">SELECT</code>
    指定一个或者更多源表。如果指定了多个源表，结果将是所有源表的
    笛卡尔积（交叉连接）。但是通常会增加限定条件（通过
    <code class="literal">WHERE</code>）来把返回的行限制为该笛卡尔积的一个小子集。
   </p><p>
    <code class="literal">FROM</code>子句可以包含下列元素：

    </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><em class="replaceable"><code>table_name</code></em></span></dt><dd><p>
        一个现有表或视图的名称（可以是模式限定的）。如果在表名前指定了
        <code class="literal">ONLY</code>，则只会扫描该表。如果没有指定
        <code class="literal">ONLY</code>，该表及其所有后代表（如果有）都会被扫描。可
        选地，可以在表名后指定<code class="literal">*</code>来显式地指示包括后代表。
       </p></dd><dt><span class="term"><em class="replaceable"><code>alias</code></em></span></dt><dd><p>
        一个包含别名的<code class="literal">FROM</code>项的替代名称。别名被用于
        让书写简洁或者消除自连接中的混淆（其中同一个表会被扫描多
        次）。当提供一个别名时，表或者函数的实际名称会被隐藏。例
        如，给定<code class="literal">FROM foo AS f</code>，
        <code class="command">SELECT</code>的剩余部分就必须以
        <code class="literal">f</code>而不是<code class="literal">foo</code>来引用这个
        <code class="literal">FROM</code>项。如果写了一个别名，还可以写一个列别
        名列表来为该表的一个或者多个列提供替代名称。
       </p></dd><dt><span class="term"><code class="literal">TABLESAMPLE <em class="replaceable"><code>sampling_method</code></em> ( <em class="replaceable"><code>argument</code></em> [, ...] ) [ REPEATABLE ( <em class="replaceable"><code>seed</code></em> ) ]</code></span></dt><dd><p>
        <em class="replaceable"><code>table_name</code></em>之后的
        <code class="literal">TABLESAMPLE</code>子句表示应该用指定的
        <em class="replaceable"><code>sampling_method</code></em>
        来检索表中行的子集。这种采样优先于任何其他过滤器（例如
        <code class="literal">WHERE</code>子句）。标准
        <span class="productname">PostgreSQL</span>发布包括两种采样
        方法：<code class="literal">BERNOULLI</code>和<code class="literal">SYSTEM</code>，
        其他采样方法可以通过扩展安装在数据库中。
       </p><p>
        <code class="literal">BERNOULLI</code>以及<code class="literal">SYSTEM</code>采样方法都接受
        一个<em class="replaceable"><code>参数</code></em>，它表示要采样的表
        的分数，表示为一个 0 到 100 之间的百分数。这个参数可以是任意的
        <code class="type">实数值</code>表达式（其他的采样方法可能接受更多或者不同的
        参数）。这两种方法都返回一个随机选取的该表采样，其中包含了指定
        百分数的表行。<code class="literal">BERNOULLI</code>方法扫描整个表并且
        用指定的几率选择或者忽略行。<code class="literal">SYSTEM</code>方法会做
        块层的采样，每个块都有指定的机会能被选中，被选中块中的所有行都
        会被返回。在指定较小的采样百分数时，<code class="literal">SYSTEM</code>
        方法要比<code class="literal">BERNOULLI</code>方法快很多，但是前者可能
        由于聚簇效应返回随机性较差的表采样。
       </p><p>
        可选的<code class="literal">REPEATABLE</code>子句指定一个用于产生采样方法中随机数的<em class="replaceable"><code>种子</code></em>数或表达式。种子值可以是任何非空浮点值。如果查询时表没有被更改，指定相同种子和<em class="replaceable"><code>argument</code></em>值的两个查询将会选择该表相同的采样。但是不同的种子值通常将会产生不同的采样。如果没有给出<code class="literal">REPEATABLE</code>，则会基于一个系统产生的种子为每一个查询选择一个新的随机采样。注意有些扩展采样方法不接受<code class="literal">REPEATABLE</code>，并且将总是为每一次使用产生新的采样。
       </p></dd><dt><span class="term"><em class="replaceable"><code>select</code></em></span></dt><dd><p>
        一个子-<code class="command">SELECT</code>可以出现在
        <code class="literal">FROM</code>子句中。这就好像把它的输出创建为一个
        存在于该<code class="command">SELECT</code>命令期间的临时表。注意
        子-<code class="command">SELECT</code>必须用圆括号包围，并且
        <span class="emphasis"><em>必须</em></span>为它提供一个别名。也可以在这里
        使用一个<a class="xref" href="sql-values.html" title="VALUES"><span class="refentrytitle">VALUES</span></a>命令。
       </p></dd><dt><span class="term"><em class="replaceable"><code>with_query_name</code></em></span></dt><dd><p>
        可以通过写一个<code class="literal">WITH</code>查询的名称来引用它，就好像
        该查询的名称是一个表名（实际上，该<code class="literal">WITH</code>查询会
        为主查询隐藏任何具有相同名称的真实表。如果必要，你可以使用
        带模式限定的方式以相同的名称来引用真实表）。可以像表一样，
        以同样的方式提供一个别名。
       </p></dd><dt><span class="term"><em class="replaceable"><code>function_name</code></em></span></dt><dd><p>
        函数调用可以出现在<code class="literal">FROM</code>子句中（对于返回结果
        集合的函数特别有用，但是可以使用任何函数）。这就好像把该函数的
        输出创建为一个存在于该<code class="command">SELECT</code>命令期
        间的临时表。当为该函数调用增加可选的
        <code class="command">WITH ORDINALITY</code>子句时，会在该函数
        的输出列之后追加一个新的列来为每一行编号。
       </p><p>
        可以用和表一样的方式提供一个别名。如果写了一个别名，还可以写一个
        列别名列表来为该函数的组合返回类型的一个或者多个属性提供替代名称，
        包括由<code class="literal">ORDINALITY</code>（如果有）增加的新列。
       </p><p>
        通过把多个函数调用包围在<code class="literal">ROWS FROM( ... )</code>中可以把它们
        整合在单个<code class="literal">FROM</code>-子句项中。这样一个项的输出是把每一个
        函数的第一行串接起来，然后是每个函数的第二行，以此类推。如果有些
        函数产生的行比其他函数少，则在缺失数据的地方放上空值，这样被返回
        的总行数总是和产生最多行的函数一样。
       </p><p>
        如果函数被定义为返回<code class="type">record</code>数据类型，那么必须出现一个
        别名或者关键词<code class="literal">AS</code>，后面跟上形为
        <code class="literal">( <em class="replaceable"><code>column_name</code></em> <em class="replaceable"><code>data_type</code></em> [<span class="optional">, ...
        </span>])</code>的列定义列表。列定义列表必须匹配该函数返回的列的实际
        数量和类型。
       </p><p>
        在使用<code class="literal">ROWS FROM( ... )</code>语法时，如果函数之一要求一个列
        定义列表，最好把该列定义列表放在<code class="literal">ROWS FROM( ... )</code>中该
        函数的调用之后。当且仅当正好只有一个函数并且没有
        <code class="literal">WITH ORDINALITY</code>子句时，才能把列定义列表放在
        <code class="literal">ROWS FROM( ... )</code>结构后面。
       </p><p>
        要把<code class="literal">ORDINALITY</code>和列定义列表一起使用，你必须使用
        <code class="literal">ROWS FROM( ... )</code>语法，并且把列定义列表放在
        <code class="literal">ROWS FROM( ... )</code>里面。
       </p></dd><dt><span class="term"><em class="replaceable"><code>join_type</code></em></span></dt><dd><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">[ INNER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">LEFT [ OUTER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">RIGHT [ OUTER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">FULL [ OUTER ] JOIN</code></p></li><li class="listitem"><p><code class="literal">CROSS JOIN</code></p></li></ul></div><p>
        之一。

        对于<code class="literal">INNER</code>和<code class="literal">OUTER</code>连接类型，必须指定
        一个连接条件，即
        <code class="literal">NATURAL</code>、<code class="literal">ON <em class="replaceable"><code>join_condition</code></em></code>或者
        <code class="literal">USING (<em class="replaceable"><code>join_column</code></em> [, ...])</code>
        之一（只能有一种）。其含义见下文。对于
        <code class="literal">CROSS JOIN</code>，上述子句不能出现。
       </p><p>
        一个<code class="literal">JOIN</code>子句联合两个<code class="literal">FROM</code>项（
        为了方便我们称之为<span class="quote">“<span class="quote">表</span>”</span>，尽管实际上它们可以是任何类型
        的<code class="literal">FROM</code>项）。如有必要可以使用圆括号确定嵌套的顺序。
        在没有圆括号时，<code class="literal">JOIN</code>会从左至右嵌套。在任何情
        况下，<code class="literal">JOIN</code>的联合比分隔<code class="literal">FROM</code>-列表
        项的逗号更强。
       </p><p><code class="literal">CROSS JOIN</code>和<code class="literal">INNER JOIN</code>
       会产生简单的笛卡尔积，也就是与在<code class="literal">FROM</code>的顶层列出两个
       表得到的结果相同，但是要用连接条件（如果有）约束该结果。
        <code class="literal">CROSS JOIN</code>与<code class="literal">INNER JOIN ON
        (TRUE)</code>等效，也就是说条件不会移除任何行。这些连接类型只是一种
        记号上的方便，因为没有什么是你用纯粹的<code class="literal">FROM</code>和
        <code class="literal">WHERE</code>能做而它们不能做的。
       </p><p><code class="literal">LEFT OUTER JOIN</code>返回被限制过的笛卡尔积
       中的所有行（即所有通过了其连接条件的组合行），外加左手表中
       没有相应的通过了连接条件的右手行的每一行的拷贝。通过在右手
       列中插入空值，这种左手行会被扩展为连接表的完整行。注意在决
       定哪些行匹配时，只考虑<code class="literal">JOIN</code>子句自身的条件。之后
       才应用外条件。
       </p><p>
        相反，<code class="literal">RIGHT OUTER JOIN</code>返回所有连接行，外加每
        一个没有匹配上的右手行（在左端用空值扩展）。这只是为了记号
        上的方便，因为你可以通过交换左右表把它转换成一个<code class="literal">LEFT
        OUTER JOIN</code>。
       </p><p><code class="literal">FULL OUTER JOIN</code>返回所有连接行，外加每
       一个没有匹配上的左手行（在右端用空值扩展），再外加每一个没有
       匹配上的右手行（在左端用空值扩展）。
       </p></dd><dt><span class="term"><code class="literal">ON <em class="replaceable"><code>join_condition</code></em></code></span></dt><dd><p><em class="replaceable"><code>join_condition</code></em>
       是一个会得到<code class="type">boolean</code>类型值的表达式（类似于一个
       <code class="literal">WHERE</code>子句），它说明一次连接中哪些行被认为
       相匹配。
       </p></dd><dt><span class="term"><code class="literal">USING ( <em class="replaceable"><code>join_column</code></em> [, ...] )</code></span></dt><dd><p>
        形式<code class="literal">USING ( a, b, ... )</code>的子句是
        <code class="literal">ON left_table.a = right_table.a AND
        left_table.b = right_table.b ...</code>的简写。还有，
        <code class="literal">USING</code>表示每一对相等列中只有一个会被
        包括在连接输出中。
       </p></dd><dt><span class="term"><code class="literal">NATURAL</code></span></dt><dd><p>
        <code class="literal">NATURAL</code>是一个<code class="literal">USING</code>列表的速记，该列表中提到两个表中具有匹配名称的所有的列。如果没有公共列名，则<code class="literal">NATURAL</code>等效于<code class="literal">ON TRUE</code>。
       </p></dd><dt><span class="term"><code class="literal">LATERAL</code></span></dt><dd><p>
        <code class="literal">LATERAL</code>关键词可以放在一个
        子-<code class="command">SELECT</code> <code class="literal">FROM</code>项前面。这允许该
        子-<code class="command">SELECT</code>引用<code class="literal">FROM</code>列表中在它之
        前的<code class="literal">FROM</code>项的列（如果没有<code class="literal">LATERAL</code>，每一
        个子-<code class="command">SELECT</code>会被独立计算并且因此不能交叉引用
        任何其他的<code class="literal">FROM</code>项）。
       </p><p><code class="literal">LATERAL</code>也可以放在一个函数调用
        <code class="literal">FROM</code>项前面，但是在这种情况下它只是一个噪声
        词，因为在任何情况下函数表达式都可以引用在它之前的
        <code class="literal">FROM</code>项。
       </p><p>
        <code class="literal">LATERAL</code>项可以出现在<code class="literal">FROM</code>列表
        顶层，或者一个<code class="literal">JOIN</code>中。在后一种情况中，它也可以引
        用其作为右手端的<code class="literal">JOIN</code>左手端上的任何项。
       </p><p>
        当一个<code class="literal">FROM</code>项包含<code class="literal">LATERAL</code>交叉引用
        时，计算会如此进行：对提供被交叉引用列的<code class="literal">FROM</code>项的每
        一行或者提供那些列的多个<code class="literal">FROM</code>项的每一个行集，使用该
        行或者行集的那些列值计算<code class="literal">LATERAL</code>项。结果行会与
        计算得到它们的行进行通常的连接。对来自哪些列的源表的每一行或者行
        集都会重复这样的步骤。
       </p><p>
        列的源表必须以<code class="literal">INNER</code>或者<code class="literal">LEFT</code>的方式连接到
        <code class="literal">LATERAL</code>项，否则就没有用于为
        <code class="literal">LATERAL</code>项计算每一个行集的良定行集。尽管
        <code class="literal"><em class="replaceable"><code>X</code></em> RIGHT JOIN
        LATERAL <em class="replaceable"><code>Y</code></em></code>这样的结构在语法上是合法的，
        但实际上不允许用于在<em class="replaceable"><code>Y</code></em>中引用
        <em class="replaceable"><code>X</code></em>。
       </p></dd></dl></div><p>
   </p></div><div class="refsect2" id="SQL-WHERE"><h3><code class="literal">WHERE</code> 子句</h3><p>
    可选的<code class="literal">WHERE</code>子句的形式
</p><pre class="synopsis">
WHERE <em class="replaceable"><code>condition</code></em>
</pre><p>
    其中<em class="replaceable"><code>condition</code></em>
    是任一计算得到<code class="type">布尔</code>类型结果的表达式。任何不满足
    这个条件的行都会从输出中被消除。如果用一行的实际值替换其中的
    变量引用后，该表达式返回真，则该行符合条件。
   </p></div><div class="refsect2" id="SQL-GROUPBY"><h3><code class="literal">GROUP BY</code> 子句</h3><p>
    可选的<code class="literal">GROUP BY</code>子句的形式
</p><pre class="synopsis">
GROUP BY <em class="replaceable"><code>grouping_element</code></em> [, ...]
</pre><p>
   </p><p>
    <code class="literal">GROUP BY</code>将会把所有被选择的行中共享相同分组表达式
    值的那些行压缩成一个行。一个被用在
    <em class="replaceable"><code>grouping_element</code></em>中的
    <em class="replaceable"><code>expression</code></em>可以是输入列名、输出列
    （<code class="command">SELECT</code>列表项）的名称或序号或者由输入列
    值构成的任意表达式。在出现歧义时，<code class="literal">GROUP BY</code>名称
    将被解释为输入列名而不是输出列名。
   </p><p>
    如果任何<code class="literal">GROUPING SETS</code>、<code class="literal">ROLLUP</code>或者
    <code class="literal">CUBE</code>作为分组元素存在，则<code class="literal">GROUP BY</code>子句
    整体上定义了数个独立的<em class="replaceable"><code>分组集</code></em>。其效果等效于在子
    查询间构建一个<code class="literal">UNION ALL</code>，子查询带有分组集作为它们
    的<code class="literal">GROUP BY</code>子句。处理分组集的进一步细节请见
    <a class="xref" href="queries-table-expressions.html#QUERIES-GROUPING-SETS" title="7.2.4. GROUPING SETS、CUBE和ROLLUP">第 7.2.4 节</a>。
   </p><p>
    聚集函数（如果使用）会在组成每一个分组的所有行上进行计算，从而为每
    一个分组产生一个单独的值（如果有聚集函数但是没有
    <code class="literal">GROUP BY</code>子句，则查询会被当成是由所有选中行构成
    的一个单一分组）。传递给每一个聚集函数的行集合可以通过在聚集函数调
    用附加一个<code class="literal">FILTER</code>子句来进一步过滤，详见
    <a class="xref" href="sql-expressions.html#SYNTAX-AGGREGATES" title="4.2.7. 聚集表达式">第 4.2.7 节</a>。当存在一个
    <code class="literal">FILTER</code>子句时，只有那些匹配它的行才会被包括在该聚
    集函数的输入中。
   </p><p>
    当存在<code class="literal">GROUP BY</code>子句或者任何聚集函数时，
    <code class="command">SELECT</code>列表表达式不能引用非分组列（除非它
    出现在聚集函数中或者它函数依赖于分组列），因为这样做会导致返回
    非分组列的值时会有多种可能的值。如果分组列是包含非分组列的表的主键（
    或者主键的子集），则存在函数依赖。
   </p><p>
    记住所有的聚集函数都是在<code class="literal">HAVING</code>子句或者
    <code class="literal">SELECT</code>列表中的任何<span class="quote">“<span class="quote">标量</span>”</span>表达式之前被计算。
    这意味着一个<code class="literal">CASE</code>表达式不能被用来跳过一个聚集表达式的
    计算，见<a class="xref" href="sql-expressions.html#SYNTAX-EXPRESS-EVAL" title="4.2.14. 表达式计算规则">第 4.2.14 节</a>。
   </p><p>
    当前，<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、
    <code class="literal">FOR SHARE</code>和<code class="literal">FOR KEY SHARE</code>不能和
    <code class="literal">GROUP BY</code>一起指定。
   </p></div><div class="refsect2" id="SQL-HAVING"><h3><code class="literal">HAVING</code> 子句</h3><p>
    可选的<code class="literal">HAVING</code>子句的形式
</p><pre class="synopsis">
HAVING <em class="replaceable"><code>condition</code></em>
</pre><p>
    其中<em class="replaceable"><code>condition</code></em>与
    <code class="literal">WHERE</code>子句中指定的条件相同。
   </p><p>
    <code class="literal">HAVING</code>消除不满足该条件的分组行。
    <code class="literal">HAVING</code>与<code class="literal">WHERE</code>不同：
    <code class="literal">WHERE</code>会在应用<code class="literal">GROUP
    BY</code>之前过滤个体行，而<code class="literal">HAVING</code>过滤由
    <code class="literal">GROUP BY</code>创建的分组行。
    <em class="replaceable"><code>condition</code></em>中引用
    的每一个列必须无歧义地引用一个分组列（除非该引用出现在一个聚集
    函数中或者该非分组列函数依赖于分组列。
   </p><p>
    即使没有<code class="literal">GROUP BY</code>子句，<code class="literal">HAVING</code>
    的存在也会把一个查询转变成一个分组查询。这和查询中包含聚集函数但没有
    <code class="literal">GROUP BY</code>子句时的情况相同。所有被选择的行都被认为是一个
    单一分组，并且<code class="command">SELECT</code>列表和
    <code class="literal">HAVING</code>子句只能引用聚集函数中的表列。如果该
    <code class="literal">HAVING</code>条件为真，这样一个查询将会发出一个单一行；
    否则不返回行。
   </p><p>
    当前，<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、
    <code class="literal">FOR SHARE</code>和<code class="literal">FOR KEY SHARE</code>不能与
    <code class="literal">HAVING</code>一起指定。
   </p></div><div class="refsect2" id="SQL-WINDOW"><h3><code class="literal">WINDOW</code> 子句</h3><p>
    可选的<code class="literal">WINDOW</code>子句的形式
</p><pre class="synopsis">
WINDOW <em class="replaceable"><code>window_name</code></em> AS ( <em class="replaceable"><code>window_definition</code></em> ) [, ...]
</pre><p>
    其中<em class="replaceable"><code>window_name</code></em>
    是一个可以从<code class="literal">OVER</code>子句或者后续窗口定义中引用的名称。
    <em class="replaceable"><code>window_definition</code></em>是
</p><pre class="synopsis">
[ <em class="replaceable"><code>existing_window_name</code></em> ]
[ PARTITION BY <em class="replaceable"><code>expression</code></em> [, ...] ]
[ ORDER BY <em class="replaceable"><code>expression</code></em> [ ASC | DESC | USING <em class="replaceable"><code>operator</code></em> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <em class="replaceable"><code>frame_clause</code></em> ]
</pre><p>
   </p><p>
    如果指定了一个<em class="replaceable"><code>existing_window_name</code></em>，
    它必须引用<code class="literal">WINDOW</code>列表中一个更早出现的项。新窗口将从
    该项中复制它的划分子句以及排序子句（如果有）。在这种情况下，新窗口
    不能指定它自己的<code class="literal">PARTITION BY</code>子句，并且它只能在被复制
    窗口没有<code class="literal">ORDER BY</code>的情况下指定该子句。新窗口总是使用它
    自己的帧子句，被复制的窗口不必指定一个帧子句。
   </p><p>
    <code class="literal">PARTITION BY</code>列表元素的解释以
    <a class="xref" href="sql-select.html#SQL-GROUPBY" title="GROUP BY 子句"><code class="literal">GROUP BY</code> 子句</a>元素的方式
    进行，不过它们总是简单表达式并且绝不能是输出列的名称或编号。另一个区
    别是这些表达式可以包含聚集函数调用，而这在常规<code class="literal">GROUP BY</code>
    子句中是不被允许的。它们被允许的原因是窗口是出现在分组和聚集之后的。
   </p><p>
    类似地，<code class="literal">ORDER BY</code>列表元素的解释也以
    <a class="xref" href="sql-select.html#SQL-ORDERBY" title="ORDER BY 子句"><code class="literal">ORDER BY</code> 子句</a>元素的方式进行，
    不过该表达式总是被当做简单表达式并且绝不会是输出列的名称或编号。
   </p><p>
    可选的<em class="replaceable"><code>frame_clause</code></em>为依赖帧的窗口函数
    定义<em class="firstterm">窗口帧</em>（并非所有窗口函数都依赖于帧）。窗口帧是查询中
    每一样（称为<em class="firstterm">当前行</em>）的相关行的集合。 
    <em class="replaceable"><code>frame_clause</code></em>可以是

</p><pre class="synopsis">
{ RANGE | ROWS | GROUPS } <em class="replaceable"><code>frame_start</code></em> [ <em class="replaceable"><code>frame_exclusion</code></em> ]
{ RANGE | ROWS | GROUPS } BETWEEN <em class="replaceable"><code>frame_start</code></em> AND <em class="replaceable"><code>frame_end</code></em> [ <em class="replaceable"><code>frame_exclusion</code></em> ]
</pre><p>

    之一，其中<em class="replaceable"><code>frame_start</code></em>和<em class="replaceable"><code>frame_end</code></em>可以是

</p><pre class="synopsis">
UNBOUNDED PRECEDING
<em class="replaceable"><code>offset</code></em> PRECEDING
CURRENT ROW
<em class="replaceable"><code>offset</code></em> FOLLOWING
UNBOUNDED FOLLOWING
</pre><p>

    之一，并且<em class="replaceable"><code>frame_exclusion</code></em>可以是

</p><pre class="synopsis">
EXCLUDE CURRENT ROW
EXCLUDE GROUP
EXCLUDE TIES
EXCLUDE NO OTHERS
</pre><p>

    之一。如果省略<em class="replaceable"><code>frame_end</code></em>，它会被默认为<code class="literal">CURRENT
    ROW</code>。限制是：
    <em class="replaceable"><code>frame_start</code></em>不能是<code class="literal">UNBOUNDED FOLLOWING</code>，
    <em class="replaceable"><code>frame_end</code></em>不能是<code class="literal">UNBOUNDED PRECEDING</code>，
    并且<em class="replaceable"><code>frame_end</code></em>的选择在上面of <em class="replaceable"><code>frame_start</code></em>以及<em class="replaceable"><code>frame_end</code></em> 选项的列表中不能早于
    <em class="replaceable"><code>frame_start</code></em>的选择 — 例如
    <code class="literal">RANGE BETWEEN CURRENT ROW AND <em class="replaceable"><code>offset</code></em>
    PRECEDING</code>是不被允许的。
   </p><p>
    默认的帧选项是<code class="literal">RANGE UNBOUNDED PRECEDING</code>，它和
    <code class="literal">RANGE BETWEEN UNBOUNDED PRECEDING AND
    CURRENT ROW</code>相同。它把帧设置为从分区开始直到当前行的最后一个<em class="firstterm">平级</em>行（被该窗口的<code class="literal">ORDER BY</code>子句认为等价于当前行的行，如果没有<code class="literal">ORDER BY</code>则所有的行都是平级的）。通常，
    <code class="literal">UNBOUNDED PRECEDING</code>表示从分区第一行开始的帧，类似地
    <code class="literal">UNBOUNDED FOLLOWING</code>表示以分区最后一行结束的帧，不论是处于<code class="literal">RANGE</code>、<code class="literal">ROWS</code>或者<code class="literal">GROUPS</code>模式中。在<code class="literal">ROWS</code>模式中，
     <code class="literal">CURRENT ROW</code>表示以当前行开始或者结束的帧。而在
    <code class="literal">RANGE</code>或者<code class="literal">GROUPS</code>模式中它表示当前行在<code class="literal">ORDER BY</code>排序中的第一个
    或者最后一个平级行开始或者结束的帧。
    <em class="replaceable"><code>offset</code></em> <code class="literal">PRECEDING</code>和<em class="replaceable"><code>offset</code></em> <code class="literal">FOLLOWING</code>选项的含义会随着帧模式而变化。在<code class="literal">ROWS</code>模式中，<em class="replaceable"><code>offset</code></em>是一个整数，表示帧开始或者结束于当前行之前或者之后的那么多行处。在<code class="literal">GROUPS</code>模式中，<em class="replaceable"><code>offset</code></em>是一个整数，表示真开始或者结束于当前行的平级组之前或者之后那么多个平级组处，其中<em class="firstterm">平级组</em>是一组根据窗口的<code class="literal">ORDER BY</code>子句等效的行。在<code class="literal">RANGE</code>模式中，<em class="replaceable"><code>offset</code></em>选项的使用要求在窗口定义中正好有一个<code class="literal">ORDER BY</code>列。那么该帧包含的行的排序列值不超过<em class="replaceable"><code>offset</code></em>且小于（对于<code class="literal">PRECEDING</code>）或者大于（对于<code class="literal">FOLLOWING</code>）当前行的排序列值。在这些情况中，<em class="replaceable"><code>offset</code></em>表达式的数据类型取决于排序列的数据类型。对于数字排序列，它通常与排序列是相同类型，但对于datetime类型的排序列它是<code class="type">interval</code>。在所有这些情况中，<em class="replaceable"><code>offset</code></em>的值必须是非空和非负。此外，虽然<em class="replaceable"><code>offset</code></em>并非必须是简单常量，但它不能包含变量、聚集函数或者窗口函数。
   </p><p>
    <em class="replaceable"><code>frame_exclusion</code></em>选项允许从帧中排除当前行周围的行，即便根据帧的起始选项来说它们应该被包含在帧中。<code class="literal">EXCLUDE CURRENT ROW</code>把当前行从帧中排除。<code class="literal">EXCLUDE GROUP</code>把当前行和它在排序上的平级行从帧中排除。<code class="literal">EXCLUDE TIES</code>从帧中排除当前行的任何平级行，但是不排除当前行本身。<code class="literal">EXCLUDE NO OTHERS</code>只是明确地指定不排除当前行或其平级行的默认行为。
   </p><p>
    注意，如果<code class="literal">ORDER BY</code>排序无法把行唯一地排序，则<code class="literal">ROWS</code>模式可能产生不可预测的结果。<code class="literal">RANGE</code>以及<code class="literal">GROUPS</code>模式的目的是确保在<code class="literal">ORDER BY</code>顺序中平等的行被同样对待：一个给定平级组中的所有行将在一个帧中或者被从帧中排除。
   </p><p>
    <code class="literal">WINDOW</code>子句的目的是指定出现在查询的
    <a class="xref" href="sql-select.html#SQL-SELECT-LIST" title="SELECT 列表"><code class="command">SELECT</code> 列表</a>或
    <a class="xref" href="sql-select.html#SQL-ORDERBY" title="ORDER BY 子句"><code class="literal">ORDER BY</code> 子句</a>中的
    <em class="firstterm">窗口函数</em>的行为。这些函数可以在它们的
    <code class="literal">OVER</code>子句中用名称引用<code class="literal">WINDOW</code>
    子句项。不过，<code class="literal">WINDOW</code>子句项不是必须被引用。
    如果在查询中没有用到它，它会被简单地忽略。可以使用根本没有任何
    <code class="literal">WINDOW</code>子句的窗口函数，因为窗口函数调用可
    以直接在其<code class="literal">OVER</code>子句中指定它的窗口定义。不过，当多
    个窗口函数都需要相同的窗口定义时，
    <code class="literal">WINDOW</code>子句能够减少输入。
   </p><p>
    当前，<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、
    <code class="literal">FOR SHARE</code>和<code class="literal">FOR KEY SHARE</code>不能和
    <code class="literal">WINDOW</code>一起被指定。
   </p><p>
    窗口函数的详细描述在
    <a class="xref" href="tutorial-window.html" title="3.5. 窗口函数">第 3.5 节</a>、
    <a class="xref" href="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS" title="4.2.8. 窗口函数调用">第 4.2.8 节</a>以及
    <a class="xref" href="queries-table-expressions.html#QUERIES-WINDOW" title="7.2.5. 窗口函数处理">第 7.2.5 节</a>中。
   </p></div><div class="refsect2" id="SQL-SELECT-LIST"><h3><code class="command">SELECT</code> 列表</h3><p>
    <code class="command">SELECT</code>列表（位于关键词
    <code class="literal">SELECT</code>和<code class="literal">FROM</code>之间）指定构成
    <code class="command">SELECT</code>语句输出行的表达式。这些表达式
    可以（并且通常确实会）引用<code class="literal">FROM</code>子句中计算得到的列。
   </p><p>
    正如在表中一样，<code class="command">SELECT</code>的每一个输出列都有一个名称。
    在一个简单的<code class="command">SELECT</code>中，这个名称只是被用来标记要显
    示的列，但是当<code class="command">SELECT</code>是一个大型查询的一个子查询时，大型查询
    会把该名称看做子查询产生的虚表的列名。要指定用于输出列的名称，在该列的表达式
    后面写上
    <code class="literal">AS</code> <em class="replaceable"><code>output_name</code></em>（
    你可以省略<code class="literal">AS</code>，但只能在期望的输出名称不匹配任何
    <span class="productname">PostgreSQL</span>关键词（见<a class="xref" href="sql-keywords-appendix.html" title="附录 C. SQL关键词">附录 C</a>）时省略。为了避免和未来增加的关键词冲突，
    推荐总是写上<code class="literal">AS</code>或者用双引号引用输出名称）。如果你不指定列名，
    <span class="productname">PostgreSQL</span>会自动选择一个名称。如果列的表达式
    是一个简单的列引用，那么被选择的名称就和该列的名称相同。在使用函数或者类型名称
    的更复杂的情况中，系统可能会生成诸如
    <code class="literal">?column?</code>之类的名称。
   </p><p>
    一个输出列的名称可以被用来在<code class="literal">ORDER BY</code>以及
    <code class="literal">GROUP BY</code>子句中引用该列的值，但是不能用于
    <code class="literal">WHERE</code>和<code class="literal">HAVING</code>子句（在其中
    必须写出表达式）。
   </p><p>
    可以在输出列表中写<code class="literal">*</code>来取代表达式，它是被选中
    行的所有列的一种简写方式。还可以写
    <code class="literal"><em class="replaceable"><code>table_name</code></em>.*</code>，它
    是只来自那个表的所有列的简写形式。在这些情况中无法用
    <code class="literal">AS</code>指定新的名称，输出行的名称将和表列的名称相同。
   </p><p>
    根据 SQL 标准，输出列表中的表达式应该在应用<code class="literal">DISTINCT</code>、<code class="literal">ORDER BY</code>或者<code class="literal">LIMIT</code>之前计算。在使用<code class="literal">DISTINCT</code>时显然必须这样做，否则就无法搞清到底在区分什么值。不过，在很多情况下如果先计算<code class="literal">ORDER BY</code>和<code class="literal">LIMIT</code>再计算输出表达式会很方便，特别是如果输出列表中包含任何 volatile 函数或者代价昂贵的函数时尤其如此。通过这种行为，函数计算的顺序更加直观并且对于从未出现在输出中的行将不会进行计算。只要输出表达式没有被<code class="literal">DISTINCT</code>、<code class="literal">ORDER BY</code>或者<code class="literal">GROUP BY</code>引用，<span class="productname">PostgreSQL</span>实际将在排序和限制行数之后计算输出表达式（作为一个反例，<code class="literal">SELECT f(x) FROM tab ORDER BY 1</code>显然必须在排序之前计算<code class="function">f(x)</code>）。包含有集合返回函数的输出表达式实际是在排序之后和限制行数之前被计算，这样<code class="literal">LIMIT</code>才能切断来自集合返回函数的输出。
   </p><div class="note"><h3 class="title">注意</h3><p>
     9.6 版本之前的<span class="productname">PostgreSQL</span>不对执行输出表达式、排序、限制行数的时间顺序做任何保证，那将取决于被选中的查询计划的形式。
    </p></div></div><div class="refsect2" id="SQL-DISTINCT"><h3><code class="literal">DISTINCT</code> 子句</h3><p>
    如果指定了<code class="literal">SELECT DISTINCT</code>，所有重复的行会被从结果
    集中移除（为每一组重复的行保留一行）。<code class="literal">SELECT ALL</code>则
    指定相反的行为：所有行都会被保留，这也是默认情况。
   </p><p>
    <code class="literal">SELECT DISTINCT ON ( <em class="replaceable"><code>expression</code></em> [, ...] )</code>
    只保留在给定表达式上计算相等的行集合中的第一行。
    <code class="literal">DISTINCT ON</code>表达式使用和
    <code class="literal">ORDER BY</code>相同的规则（见上文）解释。注意，除非用
    <code class="literal">ORDER BY</code>来确保所期望的行出现在第一位，每一个集
    合的<span class="quote">“<span class="quote">第一行</span>”</span>是不可预测的。例如：
</p><pre class="programlisting">
SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;
</pre><p>
    为每个地点检索最近的天气报告。但是如果我们不使用
    <code class="literal">ORDER BY</code>来强制对每个地点的时间值进行降序排序，
    我们为每个地点得到的报告的时间可能是无法预测的。
   </p><p>
    <code class="literal">DISTINCT ON</code>表达式必须匹配最左边的
    <code class="literal">ORDER BY</code>表达式。<code class="literal">ORDER BY</code>子句通常
    将包含额外的表达式，这些额外的表达式用于决定在每一个
    <code class="literal">DISTINCT ON</code>分组内行的优先级。
   </p><p>
    当前，<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、
    <code class="literal">FOR SHARE</code>和<code class="literal">FOR KEY SHARE</code>不能和
    <code class="literal">DISTINCT</code>一起使用。
   </p></div><div class="refsect2" id="SQL-UNION"><h3><code class="literal">UNION</code> 子句</h3><p>
    <code class="literal">UNION</code>子句具有下面的形式：
</p><pre class="synopsis">
<em class="replaceable"><code>select_statement</code></em> UNION [ ALL | DISTINCT ] <em class="replaceable"><code>select_statement</code></em>
</pre><p><em class="replaceable"><code>select_statement</code></em>
    是任何没有<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、
    <code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、
    <code class="literal">FOR SHARE</code>和<code class="literal">FOR KEY SHARE</code>子句的
    <code class="command">SELECT</code>语句（如果子表达式被包围在圆括号内，
    <code class="literal">ORDER BY</code>和<code class="literal">LIMIT</code>可以被附着到其上。如果没有
    圆括号，这些子句将被应用到<code class="literal">UNION</code>的结果而不是右手边
    的表达式上）。
   </p><p>
    <code class="literal">UNION</code>操作符计算所涉及的
    <code class="command">SELECT</code>语句所返回的行的并集。如果一行
    至少出现在两个结果集中的一个内，它就会在并集中。作为
    <code class="literal">UNION</code>两个操作数的
    <code class="command">SELECT</code>语句必须产生相同数量的列并且
    对应位置上的列必须具有兼容的数据类型。
   </p><p>
    <code class="literal">UNION</code>的结果不会包含重复行，除非指定了
    <code class="literal">ALL</code>选项。<code class="literal">ALL</code>会阻止消除重复（因此，
    <code class="literal">UNION ALL</code>通常显著地快于<code class="literal">UNION</code>，
    尽量使用<code class="literal">ALL</code>）。可以写<code class="literal">DISTINCT</code>来
    显式地指定消除重复行的行为。
   </p><p>
    除非用圆括号指定计算顺序，
    同一个<code class="command">SELECT</code>语句中的多个
    <code class="literal">UNION</code>操作符会从左至右计算。
   </p><p>
    当前，<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、
    <code class="literal">FOR SHARE</code>和
    <code class="literal">FOR KEY SHARE</code>不能用于<code class="literal">UNION</code>结果或者
    <code class="literal">UNION</code>的任何输入。
   </p></div><div class="refsect2" id="SQL-INTERSECT"><h3><code class="literal">INTERSECT</code> 子句</h3><p>
    <code class="literal">INTERSECT</code>子句具有下面的形式：
</p><pre class="synopsis">
<em class="replaceable"><code>select_statement</code></em> INTERSECT [ ALL | DISTINCT ] <em class="replaceable"><code>select_statement</code></em>
</pre><p><em class="replaceable"><code>select_statement</code></em>
    是任何没有<code class="literal">ORDER
    BY</code>, <code class="literal">LIMIT</code>、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、
    <code class="literal">FOR SHARE</code>以及<code class="literal">FOR KEY SHARE</code>子句的
    <code class="command">SELECT</code>语句。
   </p><p>
    <code class="literal">INTERSECT</code>操作符计算所涉及的
    <code class="command">SELECT</code>语句返回的行的交集。如果
    一行同时出现在两个结果集中，它就在交集中。
   </p><p>
    <code class="literal">INTERSECT</code>的结果不会包含重复行，除非指定了
    <code class="literal">ALL</code>选项。如果有<code class="literal">ALL</code>，一个在左表中有
    <em class="replaceable"><code>m</code></em>次重复并且在右表中有<em class="replaceable"><code>n</code></em>
    次重复的行将会在结果中出现
    min(<em class="replaceable"><code>m</code></em>,<em class="replaceable"><code>n</code></em>) 次。
    <code class="literal">DISTINCT</code>可以写<code class="literal">DISTINCT</code>来
    显式地指定消除重复行的行为。
   </p><p>
    除非用圆括号指定计算顺序，
    同一个<code class="command">SELECT</code>语句中的多个
    <code class="literal">INTERSECT</code>操作符会从左至右计算。
    <code class="literal">INTERSECT</code>的优先级比
    <code class="literal">UNION</code>更高。也就是说，
    <code class="literal">A UNION B INTERSECT
    C</code>将被读成<code class="literal">A UNION (B INTERSECT
    C)</code>。
   </p><p>
    当前，<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、
    <code class="literal">FOR SHARE</code>和
    <code class="literal">FOR KEY SHARE</code>不能用于<code class="literal">INTERSECT</code>结果或者
    <code class="literal">INTERSECT</code>的任何输入。
   </p></div><div class="refsect2" id="SQL-EXCEPT"><h3><code class="literal">EXCEPT</code> 子句</h3><p>
    <code class="literal">EXCEPT</code>子句具有下面的形式：
</p><pre class="synopsis">
<em class="replaceable"><code>select_statement</code></em> EXCEPT [ ALL | DISTINCT ] <em class="replaceable"><code>select_statement</code></em>
</pre><p><em class="replaceable"><code>select_statement</code></em>
    是任何没有<code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、
    <code class="literal">FOR SHARE</code>以及<code class="literal">FOR KEY SHARE</code>子句的
    <code class="command">SELECT</code>语句。
   </p><p>
    <code class="literal">EXCEPT</code>操作符计算位于左
    <code class="command">SELECT</code>语句的结果中但不在右
    <code class="command">SELECT</code>语句结果中的行集合。
   </p><p>
    <code class="literal">EXCEPT</code>的结果不会包含重复行，除非指定了
    <code class="literal">ALL</code>选项。如果有<code class="literal">ALL</code>，一个在左表中有
    <em class="replaceable"><code>m</code></em>次重复并且在右表中有
    <em class="replaceable"><code>n</code></em>次重复的行将会在结果集中出现
    max(<em class="replaceable"><code>m</code></em>-<em class="replaceable"><code>n</code></em>,0) 次。
    <code class="literal">DISTINCT</code>可以写<code class="literal">DISTINCT</code>来
    显式地指定消除重复行的行为。
   </p><p>
    除非用圆括号指定计算顺序，
    同一个<code class="command">SELECT</code>语句中的多个
    <code class="literal">EXCEPT</code>操作符会从左至右计算。
    <code class="literal">EXCEPT</code>的优先级与
    <code class="literal">UNION</code>相同。
   </p><p>
    当前，<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、
    <code class="literal">FOR SHARE</code>和
    <code class="literal">FOR KEY SHARE</code>不能用于<code class="literal">EXCEPT</code>结果或者
    <code class="literal">EXCEPT</code>的任何输入。
   </p></div><div class="refsect2" id="SQL-ORDERBY"><h3><code class="literal">ORDER BY</code> 子句</h3><p>
    可选的<code class="literal">ORDER BY</code>子句的形式如下：
</p><pre class="synopsis">
ORDER BY <em class="replaceable"><code>expression</code></em> [ ASC | DESC | USING <em class="replaceable"><code>operator</code></em> ] [ NULLS { FIRST | LAST } ] [, ...]
</pre><p>
    <code class="literal">ORDER BY</code>子句导致结果行被按照指定的表达式排序。
    如果两行按照最左边的表达式是相等的，则会根据下一个表达式比较它们，
    依次类推。如果按照所有指定的表达式它们都是相等的，则它们被返回的
    顺序取决于实现。
   </p><p>
    每一个<em class="replaceable"><code>expression</code></em>
    可以是输出列（<code class="command">SELECT</code>列表项）的名称或
    者序号，它也可以是由输入列值构成的任意表达式。
   </p><p>
    序号指的是输出列的顺序（从左至右）位置。这种特性可以为不具有唯一
    名称的列定义一个顺序。这不是绝对必要的，因为总是可以使用
    <code class="literal">AS</code>子句为输出列赋予一个名称。
   </p><p>
    也可以在<code class="literal">ORDER BY</code>子句中使用任意表达式，包括没
    有出现在<code class="command">SELECT</code>输出列表中的列。因此，
    下面的语句是合法的：
</p><pre class="programlisting">
SELECT name FROM distributors ORDER BY code;
</pre><p>
    这种特性的一个限制是一个应用在<code class="literal">UNION</code>、
    <code class="literal">INTERSECT</code>或<code class="literal">EXCEPT</code>子句结果上的
    <code class="literal">ORDER BY</code>只能指定输出列名称或序号，但不能指定表达式。
   </p><p>
    如果一个<code class="literal">ORDER BY</code>表达式是一个既匹配输出列名称又匹配
    输入列名称的简单名称，<code class="literal">ORDER BY</code>将把它解读成输出列名
    称。这与在同样情况下<code class="literal">GROUP BY</code>会做出的选择相反。这种
    不一致是为了与 SQL 标准兼容。
   </p><p>
    可以为<code class="literal">ORDER BY</code>子句中的任何表达式之后增加关键词
    <code class="literal">ASC</code>（上升）<code class="literal">DESC</code>（下降）。如果没有指定，
    <code class="literal">ASC</code>被假定为默认值。或者，可以在<code class="literal">USING</code>
    子句中指定一个特定的排序操作符名称。一个排序操作符必须是某个
    B-树操作符族的小于或者大于成员。<code class="literal">ASC</code>通常等价于
    <code class="literal">USING &lt;</code>而<code class="literal">DESC</code>通常等价于
    <code class="literal">USING &gt;</code>（但是一种用户定义数据类型的创建者可以
    准确地定义默认排序顺序是什么，并且它可能会对应于其他名称的操作符）。
   </p><p>
    如果指定<code class="literal">NULLS LAST</code>，空值会排在非空值之后；如果指定
    <code class="literal">NULLS FIRST</code>，空值会排在非空值之前。如果都没有指定，
    在指定或者隐含<code class="literal">ASC</code>时的默认行为是<code class="literal">NULLS LAST</code>，
    而指定或者隐含<code class="literal">DESC</code>时的默认行为是
    <code class="literal">NULLS FIRST</code>（因此，默认行为是空值大于非空值）。
    当指定<code class="literal">USING</code>时，默认的空值顺序取决于该操作符是否为
    小于或者大于操作符。
   </p><p>
    注意顺序选项只应用到它们所跟随的表达式上。例如
    <code class="literal">ORDER BY x, y DESC</code>和
    <code class="literal">ORDER BY x DESC, y DESC</code>是不同的。
   </p><p>
    字符串数据会被根据引用到被排序列上的排序规则排序。根据需要可以通过在
    <em class="replaceable"><code>expression</code></em>中包括一个
    <code class="literal">COLLATE</code>子句来覆盖，例如
    <code class="literal">ORDER BY mycolumn COLLATE "en_US"</code>。更多信息请见
    <a class="xref" href="sql-expressions.html#SQL-SYNTAX-COLLATE-EXPRS" title="4.2.10. 排序规则表达式">第 4.2.10 节</a>和
    <a class="xref" href="collation.html" title="23.2. 排序规则支持">第 23.2 节</a>。
   </p></div><div class="refsect2" id="SQL-LIMIT"><h3><code class="literal">LIMIT</code> 子句</h3><p>
    <code class="literal">LIMIT</code>子句由两个独立的子句构成：
</p><pre class="synopsis">
LIMIT { <em class="replaceable"><code>count</code></em> | ALL }
OFFSET <em class="replaceable"><code>start</code></em>
</pre><p>
    <em class="replaceable"><code>count</code></em>指定要返回
    的最大行数，而<em class="replaceable"><code>start</code></em>
    指定在返回行之前要跳过的行数。在两者都被指定时，在开始计算要返回的
    <em class="replaceable"><code>count</code></em>行之前会跳过
    <em class="replaceable"><code>start</code></em>行。
   </p><p>
    如果<em class="replaceable"><code>count</code></em>表达式计算
    为 NULL，它会被当成<code class="literal">LIMIT ALL</code>，即没有限制。如果
    <em class="replaceable"><code>start</code></em>计算为
    NULL，它会被当作<code class="literal">OFFSET 0</code>。
   </p><p>
    SQL:2008 引入了一种不同的语法来达到相同的结果，
    <span class="productname">PostgreSQL</span>也支持它：
</p><pre class="synopsis">
OFFSET <em class="replaceable"><code>start</code></em> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <em class="replaceable"><code>count</code></em> ] { ROW | ROWS } ONLY
</pre><p>

    在这种语法中，标准要求<em class="replaceable"><code>start</code></em>或<em class="replaceable"><code>count</code></em>是一个文本常量、一个参数或者一个变量名。而作为一种
    <span class="productname">PostgreSQL</span>的扩展，还允许其他的表达式，但通常需要被封闭在圆括号中以避免歧义。如果在一个
    <code class="literal">FETCH</code>子句中省略
    <em class="replaceable"><code>count</code></em>，它的默认值为 1。
    <code class="literal">ROW</code>和<code class="literal">ROWS</code>以及
    <code class="literal">FIRST</code>和<code class="literal">NEXT</code>是噪声，它们不影响
    这些子句的效果。根据标准，如果都存在，<code class="literal">OFFSET</code>子句
    必须出现在<code class="literal">FETCH</code>子句之前。但是
    <span class="productname">PostgreSQL</span>更宽松，它允许两种顺序。
   </p><p>
    在使用<code class="literal">LIMIT</code>时，用一个<code class="literal">ORDER BY</code>子句把
    结果行约束到一个唯一顺序是个好办法。否则你讲得到该查询结果行的
    一个不可预测的子集 — 你可能要求从第 10 到第 20 行，但是在
    什么顺序下的第 10 到第 20 呢？除非指定<code class="literal">ORDER BY</code>，你
    是不知道顺序的。
   </p><p>
    查询规划器在生成一个查询计划时会考虑<code class="literal">LIMIT</code>，因此
    根据你使用的<code class="literal">LIMIT</code>和<code class="literal">OFFSET</code>，你很可能
    得到不同的计划（得到不同的行序）。所以，使用不同的
    <code class="literal">LIMIT</code>/<code class="literal">OFFSET</code>值来选择一个查询结果的
    不同子集<span class="emphasis"><em>将会给出不一致的结果</em></span>，除非你
    用<code class="literal">ORDER BY</code>强制一种可预测的结果顺序。这不是一个
    缺陷，它是 SQL 不承诺以任何特定顺序（除非使用
    <code class="literal">ORDER BY</code>来约束顺序）给出一个查询结果这一事实造
    成的必然后果。
   </p><p>
    如果没有一个<code class="literal">ORDER BY</code>来强制选择一个确定的子集，
    重复执行同样的<code class="literal">LIMIT</code>查询甚至可能会返回一个表中行
    的不同子集。同样，这也不是一种缺陷，再这样一种情况下也无法
    保证结果的确定性。
   </p></div><div class="refsect2" id="SQL-FOR-UPDATE-SHARE"><h3>锁定子句</h3><p>
    <code class="literal">FOR UPDATE</code>、<code class="literal">FOR NO KEY UPDATE</code>、
    <code class="literal">FOR SHARE</code>和<code class="literal">FOR KEY SHARE</code>
    是<em class="firstterm">锁定子句</em>，它们影响<code class="literal">SELECT</code>
    把行从表中取得时如何对它们加锁。
   </p><p>
    锁定子句的一般形式：

</p><pre class="synopsis">
FOR <em class="replaceable"><code>lock_strength</code></em> [ OF <em class="replaceable"><code>table_name</code></em> [, ...] ] [ NOWAIT | SKIP LOCKED ]
</pre><p>

    其中<em class="replaceable"><code>lock_strength</code></em>可以是

</p><pre class="synopsis">
UPDATE
NO KEY UPDATE
SHARE
KEY SHARE
</pre><p>
   之一。
   </p><p>
    更多关于每一种行级锁模式的信息可见
    <a class="xref" href="explicit-locking.html#LOCKING-ROWS" title="13.3.2. 行级锁">第 13.3.2 节</a>。
   </p><p>
    为了防止该操作等待其他事务提交，可使用<code class="literal">NOWAIT</code>或者
    <code class="literal">SKIP LOCKED</code>选项。使用<code class="literal">NOWAIT</code>时，
    如果选中的行不能被立即锁定，该语句会报告错误而不是等待。使用
    <code class="literal">SKIP LOCKED</code>时，无法被立即锁定的任何选中行都
    会被跳过。跳过已锁定行会提供数据的一个不一致的视图，因此这不适合
    于一般目的的工作，但是可以被用来避免多个用户访问一个类似队列的表
    时出现锁竞争。注意<code class="literal">NOWAIT</code>和
    <code class="literal">SKIP LOCKED</code>只适合行级锁 — 所要求的
    <code class="literal">ROW SHARE</code>表级锁仍然会以常规的方式（见
    <a class="xref" href="mvcc.html" title="第 13 章 并发控制">第 13 章</a>）取得。如果想要不等待的表级锁，你可以先
    使用带<code class="literal">NOWAIT</code>的<a class="xref" href="sql-lock.html" title="LOCK"><span class="refentrytitle">LOCK</span></a>。
   </p><p>
    如果在一个锁定子句中提到了特定的表，则只有来自于那些表的
    行会被锁定，任何<code class="command">SELECT</code>中用到的
    其他表还是被简单地照常读取。一个没有表列表的锁定子句会影响
    该语句中用到的所有表。如果一个锁定子句被应用到一个视图或者
    子查询，它会影响在该视图或子查询中用到的所有表。不过，这些
    子句不适用于主查询引用的<code class="literal">WITH</code>查询。如果你希望
    在一个<code class="literal">WITH</code>查询中发生行锁定，应该在该
    <code class="literal">WITH</code>查询内指定一个锁定子句。
   </p><p>
    如果有必要对不同的表指定不同的锁定行为，可以写多个锁定子句。
    如果同一个表在多于一个锁定子句中被提到（或者被隐式的影响到），
    那么会按照所指定的最强的锁定行为来处理它。类似地，如果在任何
    影响一个表的子句中指定了<code class="literal">NOWAIT</code>，就会按照
    <code class="literal">NOWAIT</code>的行为来处理该表。否则如果
    <code class="literal">SKIP LOCKED</code>在任何影响该表的子句中被指定，
    该表就会被按照<code class="literal">SKIP LOCKED</code>来处理。
   </p><p>
    如果被返回的行无法清晰地与表中的行保持一致，则不能使用锁定子句。
    例如锁定子句不能与聚集一起使用。
   </p><p>
    当一个锁定子句出现在一个<code class="command">SELECT</code>查询的顶层时，
    被锁定的行正好就是该查询返回的行。在连接查询的情况下，被锁定
    的行是那些对返回的连接行有贡献的行。此外，自该查询的快照起满足
    查询条件的行将被锁定，如果它们在该快照后被更新并且不再满足
    查询条件，它们将不会被返回。如果使用了<code class="literal">LIMIT</code>，只要
    已经返回的行数满足了限制，锁定就会停止（但注意被
    <code class="literal">OFFSET</code>跳过的行将被锁定）。类似地，如果在一个游标
    的查询中使用锁定子句，只有被该游标实际取出或者跳过的行才将被
    锁定。
   </p><p>
    当一个锁定子句出现在一个子-<code class="command">SELECT</code>中时，被锁定
    行是那些该子查询返回给外层查询的行。这些被锁定的行的数量可能比
    从子查询自身的角度看到的要少，因为来自外层查询的条件可能会被用
    来优化子查询的执行。例如：
</p><pre class="programlisting">
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;
</pre><p>
    将只锁定具有<code class="literal">col1 = 5</code>的行（虽然在子查询中并没有写上
    该条件）。
   </p><p>
   早前的发行无法维持一个被之后的保存点升级的锁。例如，这段代码：
</p><pre class="programlisting">
BEGIN;
SELECT * FROM mytable WHERE key = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE mytable SET ... WHERE key = 1;
ROLLBACK TO s;
</pre><p>
   在<code class="command">ROLLBACK TO</code>之后将无法维持
   <code class="literal">FOR UPDATE</code>锁。在 9.3 中已经修复这个问题。
  </p><div class="caution"><h3 class="title">小心</h3><p>
    一个运行在<code class="literal">READ
    COMMITTED</code>事务隔离级别并且使用<code class="literal">ORDER
    BY</code>和锁定子句的<code class="command">SELECT</code>命令有可能返回无序的行。
    这是因为<code class="literal">ORDER BY</code>会被首先应用。该命令对结果排序，但是可能
    接着在尝试获得一个或者多个行上的锁时阻塞。一旦<code class="literal">SELECT</code>解除
    阻塞，某些排序列值可能已经被修改，从而导致那些行变成无序的（尽管它们根
    据原始列值是有序的）。根据需要，可以通过在子查询中放置
    <code class="literal">FOR UPDATE/SHARE</code>来解决之一问题，例如
</p><pre class="programlisting">
SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;
</pre><p>
    注意这将导致锁定<code class="structname">mytable</code>的所有行，而顶层的
    <code class="literal">FOR UPDATE</code>只会锁定实际被返回的行。这可能会导致显著的
    性能差异，特别是把<code class="literal">ORDER BY</code>与<code class="literal">LIMIT</code>或者其他
    限制组合使用时。因此只有在并发更新排序列并且要求严格的排序结果时才推
    荐使用这种技术。
   </p><p>
    在<code class="literal">REPEATABLE READ</code>或者<code class="literal">SERIALIZABLE</code>
    事务隔离级别上这可能导致一个序列化失败（<code class="literal">SQLSTATE</code>
    是<code class="literal">'40001'</code>），因此在这些隔离级别下不可能收到无序行。
   </p></div></div><div class="refsect2" id="SQL-TABLE"><h3><code class="literal">TABLE</code> 命令</h3><p>
    命令
</p><pre class="programlisting">
TABLE <em class="replaceable"><code>name</code></em>
</pre><p>
    等价于
</p><pre class="programlisting">
SELECT * FROM <em class="replaceable"><code>name</code></em>
</pre><p>
    它可以被用作一个顶层命令，或者用在复杂查询中以节省空间。只有
    <code class="literal">WITH</code>、
    <code class="literal">UNION</code>、<code class="literal">INTERSECT</code>、<code class="literal">EXCEPT</code>、
    <code class="literal">ORDER BY</code>、<code class="literal">LIMIT</code>、<code class="literal">OFFSET</code>、
    <code class="literal">FETCH</code>以及<code class="literal">FOR</code>锁定子句可以用于
    <code class="command">TABLE</code>。不能使用<code class="literal">WHERE</code>子句和任何形式
    的聚集。
   </p></div></div><div class="refsect1" id="id-1.9.3.171.9"><h2>示例</h2><p>
   把表<code class="literal">films</code>与表
   <code class="literal">distributors</code>连接：

</p><pre class="programlisting">
SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d, films f
    WHERE f.did = d.did

       title       | did |     name     | date_prod  |   kind
-------------------+-----+--------------+------------+----------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drama
 The African Queen | 101 | British Lion | 1951-08-11 | Romantic
 ...
</pre><p>
  </p><p>
   要对所有电影的<code class="literal">len</code>列求和并且用
   <code class="literal">kind</code>对结果分组：

</p><pre class="programlisting">
SELECT kind, sum(len) AS total FROM films GROUP BY kind;

   kind   | total
----------+-------
 Action   | 07:34
 Comedy   | 02:58
 Drama    | 14:28
 Musical  | 06:42
 Romantic | 04:38
</pre><p>
  </p><p>
   要对所有电影的<code class="literal">len</code>列求和、对结果按照
   <code class="literal">kind</code>分组并且显示总长小于 5 小时的分组：

</p><pre class="programlisting">
SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) &lt; interval '5 hours';

   kind   | total
----------+-------
 Comedy   | 02:58
 Romantic | 04:38
</pre><p>
  </p><p>
   下面两个例子都是根据第二列（<code class="literal">name</code>）的内容来排序结果：

</p><pre class="programlisting">
SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

 did |       name
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward
</pre><p>
  </p><p>
   接下来的例子展示了如何得到表<code class="literal">distributors</code>和
   <code class="literal">actors</code>的并集，把结果限制为那些在每个表中以
   字母 W 开始的行。只想要可区分的行，因此省略了关键词
   <code class="literal">ALL</code>。

</p><pre class="programlisting">
distributors:               actors:
 did |     name              id |     name
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';

      name
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen
</pre><p>
  </p><p>
   这个例子展示了如何在<code class="literal">FROM</code>子句中使用函数，
   分别使用和不使用列定义列表：

</p><pre class="programlisting">
CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney
</pre><p>
  </p><p>
   这里是带有增加的序数列的函数的例子：

</p><pre class="programlisting">
SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;
 unnest | ordinality
--------+----------
 a      |        1
 b      |        2
 c      |        3
 d      |        4
 e      |        5
 f      |        6
(6 rows)
</pre><p>
  </p><p>
   这个例子展示了如何使用简单的<code class="literal">WITH</code>子句：

</p><pre class="programlisting">
WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t

         x          
--------------------
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422
</pre><p>

   注意该<code class="literal">WITH</code>查询只被计算一次，这样我们得到的两个
   集合具有相同的三个随机值。
  </p><p>
   这个例子使用<code class="literal">WITH RECURSIVE</code>从一个只显示
   直接下属的表中寻找雇员 Mary
   的所有下属（直接的或者间接的）以及他们的间接层数：

</p><pre class="programlisting">
WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;
</pre><p>

   注意这种递归查询的典型形式：一个初始条件，后面跟着
   <code class="literal">UNION</code>，然后是查询的递归部分。要确保
   查询的递归部分最终将不返回任何行，否则该查询将无限循环（
   更多例子见<a class="xref" href="queries-with.html" title="7.8. WITH查询（公共表表达式）">第 7.8 节</a>）。
  </p><p>
   这个例子使用<code class="literal">LATERAL</code>为<code class="structname">manufacturers</code>
   表的每一行应用一个集合返回函数<code class="function">get_product_names()</code>：

</p><pre class="programlisting">
SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;
</pre><p>

    当前没有任何产品的制造商不会出现在结果中，因为这是一个内连接。
    如果我们希望把这类制造商的名称包括在结果中，我们可以：

</p><pre class="programlisting">
SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;
</pre></div><div class="refsect1" id="id-1.9.3.171.10"><h2>兼容性</h2><p>
   当然，<code class="command">SELECT</code>语句是兼容 SQL 标准的。
   但是也有一些扩展和缺失的特性。
  </p><div class="refsect2" id="id-1.9.3.171.10.3"><h3>省略的<code class="literal">FROM</code>子句</h3><p>
    <span class="productname">PostgreSQL</span>允许我们省略
    <code class="literal">FROM</code>子句。一种简单的使用是计算简单表达式
    的结果：
</p><pre class="programlisting">
SELECT 2+2;

 ?column?
----------
        4
</pre><p>
    某些其他<acronym class="acronym">SQL</acronym>数据库需要引入一个假的
    单行表放在该<code class="command">SELECT</code>的
    <code class="literal">FROM</code>子句中才能做到这一点。
   </p><p>
    注意，如果没有指定一个<code class="literal">FROM</code>子句，该查询
    就不能引用任何数据库表。例如，下面的查询是非法的：
</p><pre class="programlisting">
SELECT distributors.* WHERE distributors.name = 'Westward';
</pre><p>
    <span class="productname">PostgreSQL</span>在 8.1 之前的发行
    会接受这种形式的查询，并且为该查询引用的每一个表在
    <code class="literal">FROM</code>子句中隐式增加一个项。现在已经不再允许
    这样做。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.4"><h3>空<code class="literal">SELECT</code>列表</h3><p>
    <code class="literal">SELECT</code>之后的输出表达式列表可以为空，
    这会产生一个零列的结果表。对 SQL 标准来说这不是合法的
    语法。<span class="productname">PostgreSQL</span>允许
    它是为了与允许零列表保持一致。不过在使用
    <code class="literal">DISTINCT</code>时不允许空列表。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.5"><h3>省略<code class="literal">AS</code>关键词</h3><p>
    在 SQL 标准中，只要新列名是一个合法的列名（就是说与任何保留关键词不同），
    就可以省略输出列名之前的可选关键词<code class="literal">AS</code>。
    <span class="productname">PostgreSQL</span>要稍微严格些：只要新列名匹配
    任何关键词（保留或者非保留）就需要<code class="literal">AS</code>。推荐的习惯是使用
    <code class="literal">AS</code>或者带双引号的输出列名来防止与未来增加的关键词可能的冲突。
   </p><p>
    在<code class="literal">FROM</code>项中，标准和
    <span class="productname">PostgreSQL</span>都允许省略非保留
    关键词别名之前的<code class="literal">AS</code>。但是由于语法的歧义，这无法
    用于输出列名。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.6"><h3><code class="literal">ONLY</code>和继承</h3><p>
    在书写<code class="literal">ONLY</code>时，SQL 标准要求在表名周围加上圆括号，例如
    <code class="literal">SELECT * FROM ONLY
    (tab1), ONLY (tab2) WHERE ...</code>。<span class="productname">PostgreSQL</span>
    认为这些圆括号是可选的。
   </p><p>
    <span class="productname">PostgreSQL</span>允许写一个拖尾的<code class="literal">*</code>来
    显式指定包括子表的非-<code class="literal">ONLY</code>行为。而标准则不允许
    这样。
   </p><p>
    （这些点同等地适用于所有支持<code class="literal">ONLY</code>选项的 SQL 命令）。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.7"><h3><code class="literal">TABLESAMPLE</code>子句限制</h3><p>
    当前只在常规表和物化视图上接受<code class="literal">TABLESAMPLE</code>子句。
    根据 SQL 标准，应该可以把它应用于任何<code class="literal">FROM</code>项。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.8"><h3><code class="literal">FROM</code>中的函数调用</h3><p>
    <span class="productname">PostgreSQL</span>允许一个函数调用被直接写作
    <code class="literal">FROM</code>列表的一个成员。在 SQL 标准中，有必要把这样一个函数
    调用包裹在一个子-<code class="command">SELECT</code>中。也就是说，语法
    <code class="literal">FROM <em class="replaceable"><code>func</code></em>(...) <em class="replaceable"><code>alias</code></em></code>
    近似等价于
    <code class="literal">FROM LATERAL (SELECT <em class="replaceable"><code>func</code></em>(...)) <em class="replaceable"><code>alias</code></em></code>。
    注意该<code class="literal">LATERAL</code>被认为是隐式的，这是因为标准对于
    <code class="literal">FROM</code>中的一个<code class="literal">UNNEST()</code>项要求
    <code class="literal">LATERAL</code>语义。<span class="productname">PostgreSQL</span>会把
    <code class="literal">UNNEST()</code>和其他集合返回函数同样对待。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.9"><h3><code class="literal">GROUP BY</code>和<code class="literal">ORDER BY</code>可用的名字空间</h3><p>
    在 SQL-92 标准中，一个<code class="literal">ORDER BY</code>子句只能使用输出
    列名或者序号，而一个<code class="literal">GROUP BY</code>子句只能使用基于输
    入列名的表达式。<span class="productname">PostgreSQL</span>扩展了
    这两种子句以允许它们使用其他的选择（但如果有歧义时还是使用标准的
    解释）。<span class="productname">PostgreSQL</span>也允许两种子句
    指定任意表达式。注意出现在一个表达式中的名称将总是被当做输入列名而
    不是输出列名。
   </p><p>
    SQL:1999 及其后的标准使用了一种略微不同的定义，它并不完全向后兼容
    SQL-92。不过，在大部分的情况下，
    <span class="productname">PostgreSQL</span>会以与 SQL:1999 相同的
    方式解释<code class="literal">ORDER BY</code>或<code class="literal">GROUP
    BY</code>表达式。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.10"><h3>函数依赖</h3><p>
    只有当一个表的主键被包括在<code class="literal">GROUP BY</code>列表中时，
    <span class="productname">PostgreSQL</span>才识别函数依赖（允许
    从<code class="literal">GROUP BY</code>中省略列）。SQL 标准指定了应该要识别
    的额外情况。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.11"><h3><code class="literal">LIMIT</code>和<code class="literal">OFFSET</code></h3><p>
    <code class="literal">LIMIT</code>和<code class="literal">OFFSET</code>子句是
    <span class="productname">PostgreSQL</span>-特有的语法，在
    <span class="productname">MySQL</span>也被使用。SQL:2008 标准已经
    引入了具有相同功能的子句<code class="literal">OFFSET ... FETCH {FIRST|NEXT}
    ...</code>（如上文
    <a class="xref" href="sql-select.html#SQL-LIMIT" title="LIMIT 子句"><code class="literal">LIMIT</code> 子句</a>中所示）。这种语法
    也被<span class="productname">IBM DB2</span>使用（
    <span class="productname">Oracle</span>编写的应用常常使用自动生成的
    <code class="literal">rownum</code>列来实现这些子句的效果，这在 PostgreSQL 
    中是没有的）。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.12"><h3><code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR UPDATE</code>、<code class="literal">FOR SHARE</code>、<code class="literal">FOR KEY SHARE</code></h3><p>
    尽管 SQL 标准中出现了<code class="literal">FOR UPDATE</code>，但标准只允许它作为
    <code class="command">DECLARE CURSOR</code>的一个选项。
    <span class="productname">PostgreSQL</span>允许它出现在任何
    <code class="command">SELECT</code>查询以及子-<code class="command">SELECT</code>中，但这是
    一种扩展。<code class="literal">FOR NO KEY UPDATE</code>、<code class="literal">FOR SHARE</code>
    以及<code class="literal">FOR KEY SHARE</code>变体以及<code class="literal">NOWAIT</code>
    和<code class="literal">SKIP LOCKED</code>选项没有在标准中出现。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.13"><h3><code class="literal">WITH</code>中的数据修改语句</h3><p>
    <span class="productname">PostgreSQL</span>允许把<code class="command">INSERT</code>、
    <code class="command">UPDATE</code>以及<code class="command">DELETE</code>用作<code class="literal">WITH</code>
    查询。这在 SQL 标准中是找不到的。
   </p></div><div class="refsect2" id="id-1.9.3.171.10.14"><h3>非标准子句</h3><p>
    <code class="literal">DISTINCT ON ( ... )</code>是 SQL 标准的扩展。
   </p><p>
    <code class="literal">ROWS FROM( ... )</code>是 SQL 标准的扩展。
   </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="sql-security-label.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="sql-commands.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="sql-selectinto.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">SECURITY LABEL </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> SELECT INTO</td></tr></table></div></body></html>