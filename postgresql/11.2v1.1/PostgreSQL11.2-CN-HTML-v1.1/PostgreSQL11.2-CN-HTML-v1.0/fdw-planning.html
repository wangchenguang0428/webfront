<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>57.4. 外部数据包装器查询规划</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="fdw-helpers.html" title="57.3. 外部数据包装器助手函数" /><link rel="next" href="fdw-row-locking.html" title="57.5. 外部数据包装器中的行锁定" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">57.4. 外部数据包装器查询规划</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="fdw-helpers.html" title="57.3. 外部数据包装器助手函数">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="fdwhandler.html" title="第 57 章 编写一个外部数据包装器">上一级</a></td><th width="60%" align="center">第 57 章 编写一个外部数据包装器</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="fdw-row-locking.html" title="57.5. 外部数据包装器中的行锁定">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="FDW-PLANNING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">57.4. 外部数据包装器查询规划</h2></div></div></div><p>
     FDW回调函数<code class="function">GetForeignRelSize</code>、<code class="function">GetForeignPaths</code>、<code class="function">GetForeignPlan</code>、<code class="function">PlanForeignModify</code>、<code class="function">GetForeignJoinPaths</code>、<code class="function">GetForeignUpperPaths</code>以及<code class="function">PlanDirectModify</code>必须适合<span class="productname">PostgreSQL</span>规划器的工作。这里有一些关于它们必须做什么的注记。
    </p><p>
     <code class="literal">root</code>和<code class="literal">baserel</code>中的信息可以被用来减少必须从外部表获得的信息量（并且因此降低代价）。<code class="literal">baserel-&gt;baserestrictinfo</code>是特别有趣的，因为它包含限制条件（<code class="literal">WHERE</code>）子句，它应该被用来过滤要被获取的行（FDW本身并不要求强制这些条件，因为核心执行器可以检查它们）。<code class="literal">baserel-&gt;reltarget-&gt;exprs</code>可以被用来决定哪些类需要被获取；但是注意它仅列出了<code class="structname">ForeignScan</code>计划节点所发出的列，不包含在条件计算中使用但并不被查询输出的列。
    </p><p>
     有多个私有域可以给FDW规划函数来保存信息。通常，不管你存储什么在FDW私有域中，它们都应该被palloc，这样它会在规划结束时被回收。    </p><p>
     <code class="literal">baserel-&gt;fdw_private</code>是一个<code class="type">void</code>指针，它可以被FDW规划函数用来存储与特定外部表相关的信息。核心规划器不会碰它除非当<code class="literal">RelOptInfo</code>节点被创建时把它初始化为NULL。它对从<code class="function">GetForeignRelSize</code>传递信息给<code class="function">GetForeignPaths</code>和/或从<code class="function">GetForeignPaths</code>传递信息给<code class="function">GetForeignPlan</code>非常有用，这样避免了重新计算。
    </p><p>
     <code class="function">GetForeignPaths</code>可以通过在<code class="structname">ForeignPath</code>节点的<code class="structfield">fdw_private</code>域中存储私有信息来标识不同的访问路径。<code class="structfield">fdw_private</code>被声明为一个<code class="type">List</code>指针，但是可能实际上包含任何东西，因为规划器不会触碰它。但是，最好是使用一种<code class="function">nodeToString</code>可导出的形式，这样在后端可以用于调试支持。
    </p><p>
     <code class="function">GetForeignPlan</code>可以检查选中的<code class="structname">ForeignPath</code>节点的<code class="structfield">fdw_private</code>域，并且可以生成被放置于<code class="structname">ForeignPath</code>计划节点中的<code class="structfield">fdw_exprs</code>和<code class="structfield">fdw_private</code>列表。这两个列表必须被表示为一种<code class="function">copyObject</code>可复制的形式。<code class="structfield">fdw_private</code>列表没有任何其他限制并且不会被核心后端以任何形式解释。非 NIL 的<code class="structfield">fdw_exprs</code>应该包含表达式树，该树会在运行时被执行。这些树将由规划器在后期处理，以便让它们变成完全可执行的。
    </p><p>
     在<code class="function">GetForeignPlan</code>中，通常被传入的目标列表可以被照样复制到计划节点中。被传入的<code class="literal">scan_clauses</code> 列表包含和<code class="literal">baserel-&gt;baserestrictinfo</code>相同的子句，但是可能为了更好的执行效率会被重新排序。在简单情况下，FDW可以只把<code class="structname">RestrictInfo</code>节点从<code class="literal">scan_clauses</code> 列表剥离（使用<code class="function">extract_actual_clauses</code>）并且把所有子句放到计划节点的条件列表中，这意味着所有子句将在运行时由执行器检查。更复杂的FDW可能可以在内部检查某些子句，着这种情况下哪些子句可以从计划节点的条件列表中删除，这样执行器就不用浪费时间去检查它们。
    </p><p>
     作为一个例子，FDW可以标识某些<em class="replaceable"><code>foreign_variable</code></em> <code class="literal">=</code>
     <em class="replaceable"><code>sub_expression</code></em>形式的限制子句，它决定哪些可以使用由<em class="replaceable"><code>sub_expression</code></em>给出的本地计算值在远程服务器上被执行。这样一个子句的实际标识应该在<code class="function">GetForeignPaths</code>期间发生，因为它可能会影响路径的代价估计。路径的<code class="structfield">fdw_private</code>域可能包括一个已标识的子句的<code class="structname">RestrictInfo</code>节点。然后<code class="function">GetForeignPlan</code>将从<code class="literal">scan_clauses</code> 中移除该子句，但是将<em class="replaceable"><code>sub_expression</code></em>加到<code class="structfield">fdw_exprs</code>来保证它被揉成可执行的形式。它可能还将把控制信息放入到计划节点的<code class="structfield">fdw_private</code>域来告诉执行函数在运行时要做什么。传递给远程服务器的查询将涉及类似<code class="literal">WHERE <em class="replaceable"><code>foreign_variable</code></em> = $1</code>的东西，使用在运行时从<code class="structfield">fdw_exprs</code>表达式树获得的参数值。
    </p><p>
     任何从该计划节点的条件列表移除的子句必须被加入到<code class="literal">fdw_recheck_quals</code>或者由<code class="literal">RecheckForeignScan</code>重新检查以便确保在<code class="literal">READ COMMITTED</code>隔离级别的正确行为。当查询中涉及的某个其他表上发生并发更新时，执行器可能需要验证原来的所有条件仍然对该元组满足（可能用一组不同的参数值）。使用<code class="literal">fdw_recheck_quals</code>通常比在<code class="literal">RecheckForeignScan</code>中实现检查要更容易，但是这种方法不足以应付外连接被下推的情况，因为那种情况下的连接元组可能会有一些域具有 NULL 但是不会导致整个元组被拒绝。
    </p><p>
     另一个可以由 FDW 填充的<code class="structname">ForeignScan</code>域是<code class="structfield">fdw_scan_tlist</code>，它描述 FDW 为这个计划节点返回的元组。对于简单的外部表扫描这可以设置为<code class="literal">NIL</code>，表示返回的元组具有为外部表声明的行类型。非-<code class="symbol">NIL</code>值必须是一个包含表示返回列的 Var 或表达式的目标列表（<code class="structname">TargetEntry</code>的列表）。例如，这可以被用来显示 FDW 省略了某些查询不需要的列。还有，如果 FDW 计算表达式比在本地计算代价更低，可以把那些表达式加入到<code class="structfield">fdw_scan_tlist</code>。注意连接计划（从<code class="function">GetForeignJoinPaths</code>创建的路径得到）必须总是提供<code class="structfield">fdw_scan_tlist</code>来描述它们将返回的列集合。
    </p><p>
     FDW应该总是只依靠表的限制子句构建至少一个路径。在连接查询中，它可能还会选择依靠连接子句构建路径，例如<em class="replaceable"><code>foreign_variable</code></em> <code class="literal">=</code> <em class="replaceable"><code>local_variable</code></em>。这样的子句将不会在<code class="literal">baserel-&gt;baserestrictinfo</code>中找到，但是必须出现在关系的连接列表中。使用这样一个子句的路径被称为一个<span class="quote">“<span class="quote">参数化路径</span>”</span>。它必须用一个合适的<code class="literal">param_info</code>值来标识其他被使用在选中的连接子句中的关系；使用<code class="function">get_baserel_parampathinfo</code>来计算该值。在<code class="function">GetForeignPlan</code>中，连接子句的<em class="replaceable"><code>local_variable</code></em>部分将被加到<code class="structfield">fdw_exprs</code>中，并且接着在运行时和一个普通限制子句一样工作。
    </p><p>
     如果一个 FDW 支持远程连接，<code class="function">GetForeignJoinPaths</code>应该和<code class="function">GetForeignPaths</code>对基本表所作的那样为潜在的远程连接产生<code class="structname">ForeignPath</code>。有关想要进行的连接的信息可以以上述相同的方式传递给<code class="function">GetForeignPlan</code>。不过，<code class="structfield">baserestrictinfo</code>与连接关系无关，一个特定连接的相关连接子句将被作为一个独立的参数（<code class="literal">extra-&gt;restrictlist</code>）被传递给<code class="function">GetForeignJoinPaths</code>。
    </p><p>
     FDW 可能会额外地支持直接执行某些在扫描和连接层次之上的计划动作，例如分组或者聚集。为了提供这类选项，FDW 应该生成路径并且把它们插入到合适的<em class="firstterm">上层关系中</em>。例如，一条表示远程聚集的路径应该被使用<code class="function">add_path</code>插入到<code class="literal">UPPERREL_GROUP_AGG</code>关系中。这条路径的代价将会与通过读取外部关系的简单扫描路径的本地聚集（注意这样一条路径也必须被提供，否则规划时会有错误）进行比较。如果远程聚集路径胜出（通常是这样），它会被以通常的方式（调用<code class="function">GetForeignPlan</code>）转化成计划。如果该查询的所有基本关系都来自于同一个 FDW，推荐在<code class="function">GetForeignUpperPaths</code>回调函数中生成这种路径，该函数会为每一个上层关系被调用（即每一次扫描/连接后处理步骤）。
    </p><p>
     <a class="xref" href="fdw-callbacks.html#FDW-CALLBACKS-UPDATE" title="57.2.4. 更新外部表的FDW例程">第 57.2.4 节</a>中描述的<code class="function">PlanForeignModify</code>以及其他回调的设计是建立在这样一个假设之上：外部表将以通常的方式被扫描并且行更新将被一个本地<code class="literal">ModifyTable</code>计划节点所驱动。这种方法对于更新需要读取本地表以及外部表的一般情况下是必要的。不过，如果操作可以完全由外部服务器执行，FDW 可以产生一个表示这种操作的计划并且把它插入到<code class="literal">UPPERREL_FINAL</code>上层关系中，在其中它会与<code class="literal">ModifyTable</code>方法竞争。这种方法还可以被用来实现远程<code class="literal">SELECT FOR UPDATE</code>，而不使用<a class="xref" href="fdw-callbacks.html#FDW-CALLBACKS-ROW-LOCKING" title="57.2.5. 用于行锁定的 FDW 例程">第 57.2.5 节</a>中描述的行锁定回调。记住插入到<code class="literal">UPPERREL_FINAL</code>中的路径负责实现查询的<span class="emphasis"><em>所有</em></span>行为。
    </p><p>
     在规划一个<code class="command">UPDATE</code>或<code class="command">DELETE</code>时，<code class="function">PlanForeignModify</code>和<code class="function">PlanDirectModify</code>能为外部表查找<code class="structname">RelOptInfo</code>结构，并利用之前由扫描规划函数创建的<code class="literal">baserel-&gt;fdw_private</code>数据。但是，在<code class="command">INSERT</code>中目标表不会被扫描，因此不会有它的<code class="structname">RelOptInfo</code>。由<code class="function">PlanForeignModify</code>返回的<code class="structname">List</code>具有和<code class="structname">ForeignScan</code>计划节点的<code class="structfield">fdw_private</code>列表相同的限制，即它必须只包含<code class="function">copyObject</code>知道怎么拷贝的结构。
    </p><p>
     带有一个<code class="literal">ON CONFLICT</code>子句的<code class="command">INSERT</code>不支持指定冲突目标，因为本地不知道远程表上的唯一约束和排除约束的情况。然后这也意味着<code class="literal">ON CONFLICT DO UPDATE</code>不被支持，因为该说明是强制性的。
    </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="fdw-helpers.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="fdwhandler.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="fdw-row-locking.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">57.3. 外部数据包装器助手函数 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 57.5. 外部数据包装器中的行锁定</td></tr></table></div></body></html>