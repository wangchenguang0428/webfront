<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>7.3. 选择列表</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="queries-table-expressions.html" title="7.2. 表表达式" /><link rel="next" href="queries-union.html" title="7.4. 组合查询" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">7.3. 选择列表</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="queries-table-expressions.html" title="7.2. 表表达式">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="queries.html" title="第 7 章 查询">上一级</a></td><th width="60%" align="center">第 7 章 查询</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="queries-union.html" title="7.4. 组合查询">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="QUERIES-SELECT-LISTS"><div class="titlepage"><div><div><h2 class="title" style="clear: both">7.3. 选择列表</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="queries-select-lists.html#QUERIES-SELECT-LIST-ITEMS">7.3.1. 选择列表项</a></span></dt><dt><span class="sect2"><a href="queries-select-lists.html#QUERIES-COLUMN-LABELS">7.3.2. 列标签</a></span></dt><dt><span class="sect2"><a href="queries-select-lists.html#QUERIES-DISTINCT">7.3.3. <code class="literal">DISTINCT</code></a></span></dt></dl></div><a id="id-1.5.6.7.2" class="indexterm"></a><p>
   如前面的小节说明的那样， 在<code class="command">SELECT</code>命令里的表表达式构造了一个中间的虚拟表， 方法可能有组合表、视图、消除行、分组等等。这个表最后被<em class="firstterm">选择列表</em>传递下去处理。选择列表判断中间表的哪个<span class="emphasis"><em>列</em></span>是实际输出。
  </p><div class="sect2" id="QUERIES-SELECT-LIST-ITEMS"><div class="titlepage"><div><div><h3 class="title">7.3.1. 选择列表项</h3></div></div></div><a id="id-1.5.6.7.4.2" class="indexterm"></a><p>
    最简单的选择列表类型是<code class="literal">*</code>，它发出表表达式生成的所有列。否则，一个选择列表是一个逗号分隔的值表达式的列表（和在<a class="xref" href="sql-expressions.html" title="4.2. 值表达式">第 4.2 节</a>里定义的一样）。 例如，它可能是一个列名的列表：
</p><pre class="programlisting">
SELECT a, b, c FROM ...
</pre><p>
     列名字<code class="literal">a</code>、<code class="literal">b</code>和<code class="literal">c</code>要么是在<code class="literal">FROM</code>子句里引用的表中列的实际名字，要么是像<a class="xref" href="queries-table-expressions.html#QUERIES-TABLE-ALIASES" title="7.2.1.2. 表和列别名">第 7.2.1.2 节</a>里解释的那样的别名。在选择列表里可用的名字空间和在<code class="literal">WHERE</code>子句里的一样， 除非你使用了分组，这时候它和<code class="literal">HAVING</code>子句一样。
   </p><p>
    如果超过一个表有同样的列名，那么你还必须给出表名字，如：
</p><pre class="programlisting">
SELECT tbl1.a, tbl2.a, tbl1.b FROM ...
</pre><p>
    在使用多个表时，要求一个特定表的所有列也是有用的：
</p><pre class="programlisting">
SELECT tbl1.*, tbl2.a FROM ...
</pre><p>
    更多有关<em class="replaceable"><code>table_name</code></em><code class="literal">.*</code>记号的内容请参考<a class="xref" href="rowtypes.html#ROWTYPES-USAGE" title="8.16.5. 在查询中使用组合类型">第 8.16.5 节</a>。
   </p><p>
    如果将任意值表达式用于选择列表，那么它在概念上向返回的表中增加了一个新的虚拟列。 值表达式为结果的每一行进行一次计算，对任何列引用替换行的值。 不过选择列表中的这个表达式并非一定要引用来自<code class="literal">FROM</code>子句中表表达式里面的列，例如它也可以是任意常量算术表达式。
   </p></div><div class="sect2" id="QUERIES-COLUMN-LABELS"><div class="titlepage"><div><div><h3 class="title">7.3.2. 列标签</h3></div></div></div><a id="id-1.5.6.7.5.2" class="indexterm"></a><p>
    选择列表中的项可以被赋予名字，用于进一步的处理。 例如为了在一个<code class="literal">ORDER BY</code>子句中使用或者为了客户端应用显示。例如：
</p><pre class="programlisting">
SELECT a AS value, b + c AS sum FROM ...
</pre><p>
   </p><p>
    如果没有使用<code class="literal">AS</code>指定输出列名，那么系统会分配一个缺省的列名。对于简单的列引用， 它是被引用列的名字。对于函数调用，它是函数的名字。对于复杂表达式，系统会生成一个通用的名字。
   </p><p>
    只有在新列无法匹配任何<span class="productname">PostgreSQL</span>关键词（见<a class="xref" href="sql-keywords-appendix.html" title="附录 C. SQL关键词">附录 C</a>）时，<code class="literal">AS</code>关键词是可选的。为了避免一个关键字的意外匹配，你可以使用双引号来修饰列名。例如，<code class="literal">VALUE</code>是一个关键字，所以下面的语句不会工作：
</p><pre class="programlisting">
SELECT a value, b + c AS sum FROM ...
</pre><p>
    但是这个可以：
</p><pre class="programlisting">
SELECT a "value", b + c AS sum FROM ...
</pre><p>
    为了防止未来可能的关键词增加，我们推荐总是写<code class="literal">AS</code>或者用双引号修饰输出列名。
   </p><div class="note"><h3 class="title">注意</h3><p>
     输出列的命名和在<code class="literal">FROM</code>子句里的命名是不一样的 （参阅<a class="xref" href="queries-table-expressions.html#QUERIES-TABLE-ALIASES" title="7.2.1.2. 表和列别名">第 7.2.1.2 节</a>）。 它实际上允许你对同一个列命名两次，但是在选择列表中分配的名字是要传递下去的名字。
    </p></div></div><div class="sect2" id="QUERIES-DISTINCT"><div class="titlepage"><div><div><h3 class="title">7.3.3. <code class="literal">DISTINCT</code></h3></div></div></div><a id="id-1.5.6.7.6.2" class="indexterm"></a><a id="id-1.5.6.7.6.3" class="indexterm"></a><p>
    在处理完选择列表之后，结果表可以可选的删除重复行。我们可以直接在<code class="literal">SELECT</code>后面写上<code class="literal">DISTINCT</code>关键字来指定：
</p><pre class="synopsis">
SELECT DISTINCT <em class="replaceable"><code>select_list</code></em> ...
</pre><p>
    （如果不用<code class="literal">DISTINCT</code>你可以用<code class="literal">ALL</code>关键词来指定获得的所有行的缺省行为）。
   </p><a id="id-1.5.6.7.6.5" class="indexterm"></a><p>
    显然，如果两行里至少有一个列有不同的值，那么我们认为它是可区分的。空值在这种比较中被认为是相同的。
   </p><p>
    另外，我们还可以用任意表达式来判断什么行可以被认为是可区分的：
</p><pre class="synopsis">
SELECT DISTINCT ON (<em class="replaceable"><code>expression</code></em> [<span class="optional">, <em class="replaceable"><code>expression</code></em> ...</span>]) <em class="replaceable"><code>select_list</code></em> ...
</pre><p>
    这里<em class="replaceable"><code>expression</code></em>是任意值表达式，它为所有行计算。如果一个行集合里所有表达式的值是一样的， 那么我们认为它们是重复的并且因此只有第一行保留在输出中。请注意这里的一个集合的<span class="quote">“<span class="quote">第一行</span>”</span>是不可预料的， 除非你在足够多的列上对该查询排了序，保证到达<code class="literal">DISTINCT</code>过滤器的行的顺序是唯一的（<code class="literal">DISTINCT ON</code>处理是发生在<code class="literal">ORDER BY</code>排序后面的）。
   </p><p>
    <code class="literal">DISTINCT ON</code>子句不是 SQL 标准的一部分， 有时候有人认为它是一个糟糕的风格，因为它的结果是不可判定的。 如果有选择的使用<code class="literal">GROUP BY</code>和在<code class="literal">FROM</code>中的子查询，那么我们可以避免使用这个构造， 但是通常它是更方便的候选方法。
   </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="queries-table-expressions.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="queries.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="queries-union.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">7.2. 表表达式 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 7.4. 组合查询</td></tr></table></div></body></html>