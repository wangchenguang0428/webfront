<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>11.4. 索引和ORDER BY</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="indexes-multicolumn.html" title="11.3. 多列索引" /><link rel="next" href="indexes-bitmap-scans.html" title="11.5. 组合多个索引" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">11.4. 索引和<code xmlns="http://www.w3.org/1999/xhtml" class="literal">ORDER BY</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="indexes-multicolumn.html" title="11.3. 多列索引">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="indexes.html" title="第 11 章 索引">上一级</a></td><th width="60%" align="center">第 11 章 索引</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="indexes-bitmap-scans.html" title="11.5. 组合多个索引">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="INDEXES-ORDERING"><div class="titlepage"><div><div><h2 class="title" style="clear: both">11.4. 索引和<code class="literal">ORDER BY</code></h2></div></div></div><a id="id-1.5.10.7.2" class="indexterm"></a><p>
   除了简单地查找查询要返回的行外，一个索引可能还需要将它们以指定的顺序传递。这使得查询中的<code class="literal">ORDER BY</code>不需要独立的排序步骤。在<span class="productname">PostgreSQL</span>当前支持的索引类型中，只有B-tree可以产生排序后的输出，其他索引类型会把行以一种没有指定的且与实现相关的顺序返回。
  </p><p>
   规划器会考虑以两种方式来满足一个<code class="literal">ORDER BY</code>说明：扫描一个符合说明的可用索引，或者先以物理顺序扫描表然后再显式排序。对于一个需要扫描表的大部分的查询，一个显式的排序很可能比使用一个索引更快，因为其顺序访问模式使得它所需要的磁盘I/O更少。只有在少数行需要被取出时，索引才会更有用。一种重要的特殊情况是<code class="literal">ORDER BY</code>与<code class="literal">LIMIT</code> <em class="replaceable"><code>n</code></em>联合使用：一个显式的排序将会处理所有的数据来确定最前面的<em class="replaceable"><code>n</code></em>行，但如果有一个符合<code class="literal">ORDER BY</code>的索引，前<em class="replaceable"><code>n</code></em>行将会被直接获取且根本不需要扫描剩下的数据。
  </p><p>
   默认情况下，B-tree索引将它的项以升序方式存储，并将空值放在最后。这意味着对列<code class="literal">x</code>上索引的一次前向扫描将产生满足<code class="literal">ORDER BY x</code>（或者更长的形式：<code class="literal">ORDER BY x ASC NULLS LAST</code>）的结果。索引也可以被后向扫描，产生满足<code class="literal">ORDER BY x DESC</code>（<code class="literal">ORDER BY x DESC NULLS FIRST</code>， <code class="literal">NULLS FIRST</code>是<code class="literal">ORDER BY DESC</code>的默认情况）。
  </p><p>
   我们可以在创建B-tree索引时通过<code class="literal">ASC</code>、<code class="literal">DESC</code>、<code class="literal">NULLS FIRST</code>和<code class="literal">NULLS LAST</code>选项来改变索引的排序，例如：
</p><pre class="programlisting">
CREATE INDEX test2_info_nulls_low ON test2 (info NULLS FIRST);
CREATE INDEX test3_desc_index ON test3 (id DESC NULLS LAST);
</pre><p>
   一个以升序存储且将空值前置的索引可以根据扫描方向来支持<code class="literal">ORDER BY x ASC NULLS FIRST</code>或 <code class="literal">ORDER BY x DESC NULLS LAST</code>。
  </p><p>
   读者可能会疑惑为什么要麻烦地提供所有四个选项，因为两个选项连同可能的后向扫描可以覆盖所有<code class="literal">ORDER BY</code>的变体。在单列索引中这些选项确实有冗余，但是在多列索引中它们却很有用。考虑<code class="literal">(x, y)</code>上的一个两列索引：它可以通过前向扫描满足<code class="literal">ORDER BY x, y</code>，或者通过后向扫描满足<code class="literal">ORDER BY x DESC, y DESC</code>。但是应用可能需要频繁地使用<code class="literal">ORDER BY x ASC, y DESC</code>。这样就没有办法从通常的索引中得到这种顺序，但是如果将索引定义为<code class="literal">(x ASC, y DESC)</code>或者<code class="literal">(x DESC, y ASC)</code>就可以产生这种排序。
  </p><p>
   显然，具有非默认排序的索引是相当专门的特性，但是有时它们会为特定查询提供巨大的速度提升。是否值得维护这样一个索引取决于我们会多频繁地使用需要特殊排序的查询。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="indexes-multicolumn.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="indexes.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="indexes-bitmap-scans.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">11.3. 多列索引 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 11.5. 组合多个索引</td></tr></table></div></body></html>