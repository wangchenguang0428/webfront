<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>51.6. 执行器</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="planner-optimizer.html" title="51.5. 规划器/优化器" /><link rel="next" href="catalogs.html" title="第 52 章 系统目录" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">51.6. 执行器</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="planner-optimizer.html" title="51.5. 规划器/优化器">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="overview.html" title="第 51 章 PostgreSQL内部概述">上一级</a></td><th width="60%" align="center">第 51 章 PostgreSQL内部概述</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="catalogs.html" title="第 52 章 系统目录">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="EXECUTOR"><div class="titlepage"><div><div><h2 class="title" style="clear: both">51.6. 执行器</h2></div></div></div><p>
    <em class="firstterm">执行器</em>接手规划器/优化器创建的计划，并递归地处理之以抽取所需的行集。这本质上是一种需求拉动的管道机制。每次一个计划节点被调用时，它必须交付一个或多个行，或者报告已经完成了行的交付。
   </p><p>
    为了提供一个具体例子，假设顶层节点是一个<code class="literal">MergeJoin</code>节点。在归并完成之前，两个行必须先被获取（每一个来自于一个子计划）。因此执行器递归地调用它自己去处理子计划（从附加在<code class="literal">lefttree</code>的子计划开始）。新的顶层节点（左子计划的顶层节点），我们说是一个<code class="literal">Sort</code>节点，并且又要递归来获取一个输入行。<code class="literal">Sort</code>的子节点可以是一个<code class="literal">SeqScan</code>节点，表示真正地读取一个表。该节点的执行将会使执行器从表中获取一行并将它返回给调用节点。<code class="literal">Sort</code>节点将反复调用它的子节点来获得所有需要排序的行。当输入耗尽后（子节点将返回一个NULL来标识），<code class="literal">Sort</code>节点执行排序，并且最后能够返回它的第一个输出行，及排序后的第一个。它会把剩下的行保存下来，这样它可以根据后续的要求按照排好的顺序返回这些行。
   </p><p>
    <code class="literal">MergeJoin</code>节点也会相似地从其右子计划要求第一个行。然后它会比较两个子节点提供的行看它们是否能被连接，如果可以它会返回一个连接行给调用者。在下一次调用时，或者它无法连接当前的输入对时，它会前进到一个表或另一个表的下一行（取决于比较的结果），并再次检查匹配。最后，某个子计划耗尽，<code class="literal">MergeJoin</code>节点返回NULL表示它没有更多连接行可以提供。
   </p><p>
    复杂的查询可能涉及多层计划节点，但是一般的方法是相同的：每个节点在被调用时计算并返回它的下一个输出行。每个节点同时也负责应用由规划器分配给它的选择或投影表达式。
   </p><p>
    执行器机制被用于四种基本SQL查询类型：<code class="command">SELECT</code>、<code class="command">INSERT</code>、 <code class="command">UPDATE</code>以及<code class="command">DELETE</code>。对于<code class="command">SELECT</code>，顶层执行器代码只需要发送查询计划树返回的每个行给客户端。对于<code class="command">INSERT</code>，每一个被返回的行被插入到<code class="command">INSERT</code>中指定的目标表中。这通过一个被称为<code class="literal">ModifyTable</code>的特殊顶层计划节点完成（一个简单的<code class="command">INSERT ... VALUES</code>命令会创建一个由一个<code class="literal">Result</code>节点组成的简单计划树，该节点只计算一个结果行，在它之上的<code class="literal">ModifyTable</code>节点会执行插入。但是<code class="command">INSERT ... SELECT</code>可以用到执行器机制的全部功能）。对于<code class="command">UPDATE</code>，规划器会安排每一个计算行包含所有被更新的列值加上原始目标行的<em class="firstterm">TID</em>（元组ID或行ID），这些数据也会被输入到一个<code class="literal">ModifyTable</code>节点，该节点将利用这些信息创建一个新的被更新行并标记旧行为被删除。对于<code class="command">DELETE</code>，唯一被计划返回的列是TID，<code class="literal">ModifyTable</code>节点简单地使用TID访问每一个目标行并将其标记为被删除。
   </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="planner-optimizer.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="overview.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="catalogs.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">51.5. 规划器/优化器 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 52 章 系统目录</td></tr></table></div></body></html>