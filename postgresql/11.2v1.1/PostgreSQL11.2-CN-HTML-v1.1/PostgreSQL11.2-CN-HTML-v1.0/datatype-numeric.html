<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>8.1. 数字类型</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="datatype.html" title="第 8 章 数据类型" /><link rel="next" href="datatype-money.html" title="8.2. 货币类型" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">8.1. 数字类型</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="datatype.html" title="第 8 章 数据类型">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="datatype.html" title="第 8 章 数据类型">上一级</a></td><th width="60%" align="center">第 8 章 数据类型</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="datatype-money.html" title="8.2. 货币类型">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="DATATYPE-NUMERIC"><div class="titlepage"><div><div><h2 class="title" style="clear: both">8.1. 数字类型</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="datatype-numeric.html#DATATYPE-INT">8.1.1. 整数类型</a></span></dt><dt><span class="sect2"><a href="datatype-numeric.html#DATATYPE-NUMERIC-DECIMAL">8.1.2. 任意精度数字</a></span></dt><dt><span class="sect2"><a href="datatype-numeric.html#DATATYPE-FLOAT">8.1.3. 浮点类型</a></span></dt><dt><span class="sect2"><a href="datatype-numeric.html#DATATYPE-SERIAL">8.1.4. 序数类型</a></span></dt></dl></div><a id="id-1.5.7.9.2" class="indexterm"></a><p>
    数字类型由2、4或8字节的整数以及4或8字节的浮点数和可选精度小数组成。<a class="xref" href="datatype-numeric.html#DATATYPE-NUMERIC-TABLE" title="表 8.2. 数字类型">表 8.2</a>列出了所有可用类型。
   </p><div class="table" id="DATATYPE-NUMERIC-TABLE"><p class="title"><strong>表 8.2. 数字类型</strong></p><div class="table-contents"><table class="table" summary="数字类型" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>名字</th><th>存储尺寸</th><th>描述</th><th>范围</th></tr></thead><tbody><tr><td><code class="type">smallint</code></td><td>2字节</td><td>小范围整数</td><td>-32768 to +32767</td></tr><tr><td><code class="type">integer</code></td><td>4字节</td><td>整数的典型选择</td><td>-2147483648 to +2147483647</td></tr><tr><td><code class="type">bigint</code></td><td>8字节</td><td>大范围整数</td><td>-9223372036854775808 to +9223372036854775807</td></tr><tr><td><code class="type">decimal</code></td><td>可变</td><td>用户指定精度，精确</td><td>最高小数点前131072位，以及小数点后16383位</td></tr><tr><td><code class="type">numeric</code></td><td>可变</td><td>用户指定精度，精确</td><td>最高小数点前131072位，以及小数点后16383位</td></tr><tr><td><code class="type">real</code></td><td>4字节</td><td>可变精度，不精确</td><td>6位十进制精度</td></tr><tr><td><code class="type">double precision</code></td><td>8字节</td><td>可变精度，不精确</td><td>15位十进制精度</td></tr><tr><td><code class="type">smallserial</code></td><td>2字节</td><td>自动增加的小整数</td><td>1到32767</td></tr><tr><td><code class="type">serial</code></td><td>4字节</td><td>自动增加的整数</td><td>1到2147483647</td></tr><tr><td><code class="type">bigserial</code></td><td>8字节</td><td>自动增长的大整数</td><td>1到9223372036854775807</td></tr></tbody></table></div></div><br class="table-break" /><p>
    数字类型常量的语法在<a class="xref" href="sql-syntax-lexical.html#SQL-SYNTAX-CONSTANTS" title="4.1.2. 常量">第 4.1.2 节</a>里描述。数字类型有一整套对应的数学操作符和函数。相关信息请参考 <a class="xref" href="functions.html" title="第 9 章 函数和操作符">第 9 章</a>。下面的几节详细描述这些类型。
   </p><div class="sect2" id="DATATYPE-INT"><div class="titlepage"><div><div><h3 class="title">8.1.1. 整数类型</h3></div></div></div><a id="id-1.5.7.9.6.2" class="indexterm"></a><a id="id-1.5.7.9.6.3" class="indexterm"></a><a id="id-1.5.7.9.6.4" class="indexterm"></a><a id="id-1.5.7.9.6.5" class="indexterm"></a><a id="id-1.5.7.9.6.6" class="indexterm"></a><a id="id-1.5.7.9.6.7" class="indexterm"></a><p>
     类型<code class="type">smallint</code>、<code class="type">integer</code>和<code class="type">bigint</code>存储各种范围的全部是数字的数，也就是没有小数部分的数字。试图存储超出范围以外的值将导致一个错误。
    </p><p>
     常用的类型是<code class="type">integer</code>，因为它提供了在范围、存储空间和性能之间的最佳平衡。一般只有在磁盘空间紧张的时候才使用 <code class="type">smallint</code>类型。而只有在<code class="type">integer</code>的范围不够的时候才使用<code class="type">bigint</code>。
    </p><p>
     <acronym class="acronym">SQL</acronym>只声明了整数类型<code class="type">integer</code>（或<code class="type">int</code>）、<code class="type">smallint</code>和<code class="type">bigint</code>。类型<code class="type">int2</code>、<code class="type">int4</code>和<code class="type">int8</code>都是扩展，也在许多其它<acronym class="acronym">SQL</acronym>数据库系统中使用。
    </p></div><div class="sect2" id="DATATYPE-NUMERIC-DECIMAL"><div class="titlepage"><div><div><h3 class="title">8.1.2. 任意精度数字</h3></div></div></div><a id="id-1.5.7.9.7.2" class="indexterm"></a><a id="id-1.5.7.9.7.3" class="indexterm"></a><a id="id-1.5.7.9.7.4" class="indexterm"></a><p>
     类型<code class="type">numeric</code>可以存储非常多位的数字。我们特别建议将它用于货币金额和其它要求计算准确的数量。<code class="type">numeric</code>值的计算在可能的情况下会得到准确的结果，例如加法、减法、乘法。不过，<code class="type">numeric</code>类型上的算术运算比整数类型或者下一节描述的浮点数类型要慢很多。
    </p><p>
     在随后的内容里，我们使用了下述术语：一个<code class="type">numeric</code>的<em class="firstterm">precision</em>（精度）是整个数中有效位的总数，也就是小数点两边的位数。<code class="type">numeric</code>的<em class="firstterm">scale</em>（刻度）是小数部分的数字位数，也就是小数点右边的部分。因此数字 23.5141 的精度为6而刻度为4。可以认为整数的刻度为零。
    </p><p>
     <code class="type">numeric</code>列的最大精度和最大比例都是可以配置的。要声明一个类型为<code class="type">numeric</code>的列，你可以用下面的语法：
</p><pre class="programlisting">
NUMERIC(<em class="replaceable"><code>precision</code></em>, <em class="replaceable"><code>scale</code></em>)
</pre><p>
     精度必须为正数，比例可以为零或者正数。另外：
</p><pre class="programlisting">
NUMERIC(<em class="replaceable"><code>precision</code></em>)
</pre><p>
     选择比例为 0 。如果使用
</p><pre class="programlisting">
NUMERIC
</pre><p>
     创建一个列时不使用精度或比例，则该列可以存储任何精度和比例的数字值，并且值的范围最多可以到实现精度的上限。一个这种列将不会把输入值转化成任何特定的比例，而带有比例声明的<code class="type">numeric</code>列将把输入值转化为该比例（<acronym class="acronym">SQL</acronym>标准要求缺省的比例是 0，即转化成整数精度。我们觉得这样做有点没用。如果你关心移植性，那你最好总是显式声明精度和比例）。
    </p><div class="note"><h3 class="title">注意</h3><p>
      显式指定类型精度时的最大允许精度为 1000，没有指定精度的<code class="type">NUMERIC</code>受到<a class="xref" href="datatype-numeric.html#DATATYPE-NUMERIC-TABLE" title="表 8.2. 数字类型">表 8.2</a>中描述的限制所控制。
     </p></div><p>
     如果一个要存储的值的比例比列声明的比例高，那么系统将尝试圆整（四舍五入）该值到指定的分数位数。 然后，如果小数点左边的位数超过了声明的精度减去声明的比例，那么抛出一个错误。
    </p><p>
     数字值在物理上是以不带任何前导或者后缀零的形式存储。 因此，列上声明的精度和比例都是最大值，而不是固定分配的 （在这个方面，<code class="type">numeric</code>类型更类似于<code class="type">varchar(<em class="replaceable"><code>n</code></em>)</code>， 而不像<code class="type">char(<em class="replaceable"><code>n</code></em>)</code>）。 实际存储要求是每四个十进制位组用两个字节，再加上三到八个字节的开销。
    </p><a id="id-1.5.7.9.7.11" class="indexterm"></a><a id="id-1.5.7.9.7.12" class="indexterm"></a><p>
     除了普通的数字值之外，<code class="type">numeric</code>类型允许特殊值<code class="literal">NaN</code>， 表示<span class="quote">“<span class="quote">不是一个数字</span>”</span>。任何在 <code class="literal">NaN</code>上面的操作都生成另外一个<code class="literal">NaN</code>。 如果在 SQL 命令里把这些值当作一个常量写，你必须在其周围放上单引号，例如<code class="literal">UPDATE table SET x = 'NaN'</code>。在输入时，字串<code class="literal">NaN</code>被识别为大小写无关。
    </p><div class="note"><h3 class="title">注意</h3><p>
      在<span class="quote">“<span class="quote">不是一个数字</span>”</span>概念的大部分实现中，<code class="literal">NaN</code>被认为不等于任何其他数字值（包括<code class="literal">NaN</code>）。为了允许<code class="type">numeric</code>值可以被排序和使用基于树的索引，<span class="productname">PostgreSQL</span>把<code class="literal">NaN</code>值视为相等，并且比所有非<code class="literal">NaN</code>值都要大。
     </p></div><p>
     类型<code class="type">decimal</code>和<code class="type">numeric</code>是等效的。两种类型都是<acronym class="acronym">SQL</acronym>标准的一部分。
    </p><p>
     在对值进行圆整时，<code class="type">numeric</code>类型会圆到远离零的整数，而（在大部分机器上）<code class="type">real</code>和<code class="type">double precision</code>类型会圆到最近的偶数上。例如：

</p><pre class="programlisting">
SELECT x,
  round(x::numeric) AS num_round,
  round(x::double precision) AS dbl_round
FROM generate_series(-3.5, 3.5, 1) as x;
  x   | num_round | dbl_round
------+-----------+-----------
 -3.5 |        -4 |        -4
 -2.5 |        -3 |        -2
 -1.5 |        -2 |        -2
 -0.5 |        -1 |        -0
  0.5 |         1 |         0
  1.5 |         2 |         2
  2.5 |         3 |         2
  3.5 |         4 |         4
(8 rows)
</pre><p>
    </p></div><div class="sect2" id="DATATYPE-FLOAT"><div class="titlepage"><div><div><h3 class="title">8.1.3. 浮点类型</h3></div></div></div><a id="id-1.5.7.9.8.2" class="indexterm"></a><a id="id-1.5.7.9.8.3" class="indexterm"></a><a id="id-1.5.7.9.8.4" class="indexterm"></a><a id="id-1.5.7.9.8.5" class="indexterm"></a><a id="id-1.5.7.9.8.6" class="indexterm"></a><p>
     数据类型<code class="type">real</code>和<code class="type">double precision</code>是不准确的、变精度的数字类型。实际上，这些类型是<acronym class="acronym">IEEE</acronym>标准 754 二进制浮点算术（分别对应单精度和双精度）的一般实现， 一直到下层处理器、操作系统和编译器对它的支持。
    </p><p>
     不准确意味着一些值不能准确地转换成内部格式并且是以近似的形式存储的，因此存储和检索一个值可能出现一些缺失。 处理这些错误以及这些错误是如何在计算中传播的主题属于数学和计算机科学的一个完整的分支， 我们不会在这里进一步讨论它，这里的讨论仅限于如下几点：
     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        如果你要求准确的存储和计算（例如计算货币金额），应使用<code class="type">numeric</code>类型。
       </p></li><li class="listitem"><p>
        如果你想用这些类型做任何重要的复杂计算，尤其是那些你对范围情况（无穷、下溢）严重依赖的事情，那你应该仔细评诂你的实现。
       </p></li><li class="listitem"><p>
        用两个浮点数值进行等值比较不可能总是按照期望地进行。
       </p></li></ul></div><p>
    </p><p>
     在大部分平台上，<code class="type">real</code>类型的范围是至少 -1E+37 到 +1E+37，精度至少是 6 位小数。<code class="type">double precision</code>类型通常有 -1E+308 到 +1E+308 的范围，精度是至少 15 位数字。太大或者太小的值都会导致错误。 如果输入数字的精度太高，那么可能发生园整。太接近零的数字，如果无法与零值的表现形式相区分就会产生下溢错误。
    </p><div class="note"><h3 class="title">注意</h3><p>
      <a class="xref" href="runtime-config-client.html#GUC-EXTRA-FLOAT-DIGITS">extra_float_digits</a>设置控制当一个浮点值被转换为文本输出时要包括的额外有效数字的数目。其默认值为<code class="literal">0</code>，在每一个PostgreSQL支持的平台上输出都相同。增加该设置将产生能更精确表示存储值的输出，但是可能无法移植。
     </p></div><a id="id-1.5.7.9.8.11" class="indexterm"></a><p>
     除了普通的数字值之外，浮点类型还有几个特殊值：
</p><div class="literallayout"><p><br />
<code class="literal">Infinity</code><br />
<code class="literal">-Infinity</code><br />
<code class="literal">NaN</code><br />
</p></div><p>
     这些值分别表示 IEEE 754 特殊值<span class="quote">“<span class="quote">正无穷大</span>”</span>、<span class="quote">“<span class="quote">负无穷大</span>”</span>以及<span class="quote">“<span class="quote">不是一个数字</span>”</span>（在不遵循 IEEE 754 浮点算术的机器上，这些值的含义可能不是预期的）。如果在 SQL 命令里把这些数值当作常量写，你必须在它们周围放上单引号，例如<code class="literal">UPDATE table SET x = '-Infinity'</code>。 在输入时，这些串是以大小写无关的方式识别的。
    </p><div class="note"><h3 class="title">注意</h3><p>
      IEEE754指定<code class="literal">NaN</code>不应该与任何其他浮点值（包括<code class="literal">NaN</code>）相等。为了允许浮点值被排序或者在基于树的索引中使用，<span class="productname">PostgreSQL</span>将<code class="literal">NaN</code>值视为相等，并且比所有非<code class="literal">NaN</code>值要更大。
     </p></div><p>
     <span class="productname">PostgreSQL</span>还支持 SQL 标准表示法<code class="type">float</code>和<code class="type">float(<em class="replaceable"><code>p</code></em>)</code>用于声明非精确的数字类型。在这里，<em class="replaceable"><code>p</code></em>指定以<span class="emphasis"><em>二进制</em></span>位表示的最低可接受精度。 在选取<code class="type">real</code>类型的时候，<span class="productname">PostgreSQL</span>接受<code class="type">float(1)</code>到<code class="type">float(24)</code>，在选取<code class="type">double precision</code>的时候，接受<code class="type">float(25)</code>到<code class="type">float(53)</code>。在允许范围之外的<em class="replaceable"><code>p</code></em>值将导致一个错误。没有指定精度的<code class="type">float</code>将被当作是<code class="type">double precision</code>。
    </p><div class="note"><h3 class="title">注意</h3><p>
      认为<code class="type">real</code>和<code class="type">double precision</code>分别有 24 和 53 个二进制位的假设对 IEEE 标准的浮点实现来说是正确的。在非 IEEE 平台上，这个数值可能略有偏差，但是为了简化，我们在所有平台上都用了同样的<em class="replaceable"><code>p</code></em>值范围。
     </p></div></div><div class="sect2" id="DATATYPE-SERIAL"><div class="titlepage"><div><div><h3 class="title">8.1.4. 序数类型</h3></div></div></div><a id="id-1.5.7.9.9.2" class="indexterm"></a><a id="id-1.5.7.9.9.3" class="indexterm"></a><a id="id-1.5.7.9.9.4" class="indexterm"></a><a id="id-1.5.7.9.9.5" class="indexterm"></a><a id="id-1.5.7.9.9.6" class="indexterm"></a><a id="id-1.5.7.9.9.7" class="indexterm"></a><a id="id-1.5.7.9.9.8" class="indexterm"></a><a id="id-1.5.7.9.9.9" class="indexterm"></a><div class="note"><h3 class="title">注意</h3><p>
      这一节描述了PostgreSQL特有的创建一个自增列的方法。另一种方法是使用SQL标准的标识列特性，它在<a class="xref" href="sql-createtable.html" title="CREATE TABLE"><span class="refentrytitle">CREATE TABLE</span></a>中描述。
     </p></div><p>
     <code class="type">smallserial</code>、<code class="type">serial</code>和<code class="type">bigserial</code>类型不是真正的类型，它们只是为了创建唯一标识符列而存在的方便符号（类似其它一些数据库中支持的<code class="literal">AUTO_INCREMENT</code>属性）。 在目前的实现中，下面一个语句：

</p><pre class="programlisting">
CREATE TABLE <em class="replaceable"><code>tablename</code></em> (
    <em class="replaceable"><code>colname</code></em> SERIAL
);
</pre><p>

     等价于以下语句：

</p><pre class="programlisting">
CREATE SEQUENCE <em class="replaceable"><code>tablename</code></em>_<em class="replaceable"><code>colname</code></em>_seq;
CREATE TABLE <em class="replaceable"><code>tablename</code></em> (
    <em class="replaceable"><code>colname</code></em> integer NOT NULL DEFAULT nextval('<em class="replaceable"><code>tablename</code></em>_<em class="replaceable"><code>colname</code></em>_seq')
);
ALTER SEQUENCE <em class="replaceable"><code>tablename</code></em>_<em class="replaceable"><code>colname</code></em>_seq OWNED BY <em class="replaceable"><code>tablename</code></em>.<em class="replaceable"><code>colname</code></em>;
</pre><p>

     因此，我们就创建了一个整数列并且把它的缺省值安排为从一个序列发生器取值。应用了一个<code class="literal">NOT NULL</code>约束以确保空值不会被插入（在大多数情况下你可能还希望附加一个<code class="literal">UNIQUE</code>或者<code class="literal">PRIMARY KEY</code>约束避免意外地插入重复的值，但这个不是自动发生的）。最后，该序列被标记为<span class="quote">“<span class="quote">属于</span>”</span>该列，这样当列或表被删除时该序列也会被删除。
    </p><div class="note"><h3 class="title">注意</h3><p>
        因为<code class="type">smallserial</code>、<code class="type">serial</code>和<code class="type">bigserial</code>是用序列实现的，所以即使没有删除过行，在出现在列中的序列值可能有“空洞”或者间隙。如果一个从序列中分配的值被用在一行中，即使该行最终没有被成功地插入到表中，该值也被“用掉”了。例如，当插入事务回滚时就会发生这种情况。更多信息参见<a class="xref" href="functions-sequence.html" title="9.16. 序列操作函数">第 9.16 节</a>中的<code class="literal">nextval()</code>。
      </p></div><p>
     要使用<code class="type">serial</code>列插入序列的下一个数值到表中， 请指定<code class="type">serial</code>列应该被赋予其缺省值。我们可以通过在<code class="command">INSERT</code>语句中把该列排除在列列表之外来实现，也可以通过使用<code class="literal">DEFAULT</code>关键字来实现。
    </p><p>
     类型名<code class="type">serial</code>和<code class="type">serial4</code>是等效的： 两个都创建<code class="type">integer</code>列。类型名<code class="type">bigserial</code>和<code class="type">serial8</code>也一样，只不过它们创建一个 <code class="type">bigint</code>列。如果你预计在表的生存期中使用的标识符数目超过 2<sup>31</sup> 个，那么你应该使用<code class="type">bigserial</code>。类型名<code class="type">smallserial</code>和<code class="type">serial2</code>也以相同方式工作，只不过它们创建一个<code class="type">smallint</code>列。
    </p><p>
     为一个<code class="type">serial</code>列创建的序列在所属的列被删除的时候自动删除。你可以在不删除列的情况下删除序列，但是这会强制删除该列的默认值表达式。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="datatype.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="datatype.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="datatype-money.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">第 8 章 数据类型 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 8.2. 货币类型</td></tr></table></div></body></html>