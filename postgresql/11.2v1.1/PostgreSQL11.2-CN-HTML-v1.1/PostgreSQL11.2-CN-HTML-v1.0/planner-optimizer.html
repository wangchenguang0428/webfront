<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>51.5. 规划器/优化器</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="rule-system.html" title="51.4. PostgreSQL规则系统" /><link rel="next" href="executor.html" title="51.6. 执行器" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">51.5. 规划器/优化器</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="rule-system.html" title="51.4. PostgreSQL规则系统">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="overview.html" title="第 51 章 PostgreSQL内部概述">上一级</a></td><th width="60%" align="center">第 51 章 PostgreSQL内部概述</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="executor.html" title="51.6. 执行器">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="PLANNER-OPTIMIZER"><div class="titlepage"><div><div><h2 class="title" style="clear: both">51.5. 规划器/优化器</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="planner-optimizer.html#id-1.10.3.8.5">51.5.1. 生成可能的计划</a></span></dt></dl></div><p>
    <em class="firstterm">规划器/优化器</em>的任务是创建一个最佳的执行计划。一个给定的SQL查询（今后将是一个查询树）实际上可以以很多种不同的方式被执行，其中的每一种都会产生相同的结果集。如果在计算上可行，查询优化器将检查这些可能的执行计划中的每一个，最后选择其中被期望“跑得最快的”那一个。
   </p><div class="note"><h3 class="title">注意</h3><p>
     在某些情况下，检查一个查询的每一种可能的执行方式会耗费非常多的时间和内存空间。特别是当查询涉及到大量连接操作时。为了能在合理的时间内决定一个合理的（不一定是最佳的）查询计划，当连接数量超过一个阈值（见<a class="xref" href="runtime-config-query.html#GUC-GEQO-THRESHOLD">geqo_threshold</a>）时<span class="productname">PostgreSQL</span>使用了一种<em class="firstterm">遗传查询优化器</em> （见<a class="xref" href="geqo.html" title="第 60 章 遗传查询优化器">第 60 章</a>）。
    </p></div><p>
    规划器搜索过程实际上依靠称为<em class="firstterm">路径</em>的数据结构工作，它是一种缩短版的计划，其中只包含规划器做决定所需要的信息。当最低代价的路径被确定后，一个全功能的<em class="firstterm">计划树</em>将被建立并传递给执行器。这表示所期望的执行计划已经拥有足够的细节以供执行器执行它。在本节剩下的部分，我们将忽略路径和计划之间的区别。
   </p><div class="sect2" id="id-1.10.3.8.5"><div class="titlepage"><div><div><h3 class="title">51.5.1. 生成可能的计划</h3></div></div></div><p>
     规划器/优化器从扫描查询中用到的每一个单独的关系（表）开始生成计划。可能的计划根据每一个关系上可用的索引决定。在一个关系上总是有执行一个顺序扫描的可能，因此一个顺序扫描计划总是会被创建。假设在一个关系上定义有一个索引（例如一个B-tree索引）并且查询包含限制<code class="literal">relation.attribute OPR constant</code>。如果<code class="literal">relation.attribute</code>正好匹配该B-tree索引的键并且<code class="literal">OPR</code>是该索引的<em class="firstterm">操作符类</em>之一，另一个使用B-tree索引扫描该索引的计划将被创建。如果还有索引存在且查询中的限制正好匹配一个索引的键，其他计划也会被考虑。如果有索引的顺序能匹配<code class="literal">ORDER BY</code>子句（如果有）或者对于归并连接有用（见下文），也会为该索引创建索引扫描计划。
    </p><p>
     如果查询需要连接两个或更多关系，在所有扫描单个关系的可能计划都被找到后，连接计划将会被考虑。三种可用的连接策略是：

     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        <em class="firstterm">嵌套循环连接</em>: 对左关系找到的每一行都要扫描右关系一次。这种策略最容易实现但是可能非常耗时（但是，如果右关系可以通过索引扫描，这将是一个不错的策略。因为可以用左关系当前行的值来作为右关系上索引扫描的键）。
       </p></li><li class="listitem"><p>
        <em class="firstterm">归并连接</em>：在连接开始之前，每一个关系都按照连接属性排好序。然后两个关系会被并行扫描，匹配的行被整合成连接行。由于这种连接中每个关系只被扫描一次，因此它很具有吸引力。它所要求的排序可以通过一个显式的排序步骤得到，或使用一个连接键上的索引按适当顺序扫描关系得到。
       </p></li><li class="listitem"><p>
        <em class="firstterm">哈希连接</em>：右关系先被扫描并且被载入到一个哈希表，使用连接属性作为哈希键。接下来左关系被扫描，扫描中找到的每一行的连接属性值被用作哈希键在哈希表中查找匹配的行。
       </p></li></ul></div><p>
    </p><p>
     当查询涉及两个以上的关系时，最终结果必须由一个连接步骤树构成，每个连接步骤有两个输入。规划器会检查不同可能的连接序列来找到代价最小的那一个。
    </p><p>
     如果查询是用的关系数少于<a class="xref" href="runtime-config-query.html#GUC-GEQO-THRESHOLD">geqo_threshold</a>，将使用一次接近穷举的搜索来查找最好的连接顺序。如果任何两个关系在<code class="literal">WHERE</code>条件中存在一个相应的连接子句（即存在类似于<code class="literal">where rel1.attr1=rel2.attr2</code>的限制），规划器会有限考虑它们之间的连接。没有任何连接子句的连接对只有在别无选择时才会被考虑，即一个关系没有任何可用的对于其他关系的连接子句。对规划器所考虑的每一个连接对会生成所有可能的计划，其中代价（被估计为）最低的一个将被选择。
    </p><p>
     当连接关系数超过<code class="varname">geqo_threshold</code>时，连接序列将考虑通过启发式方法来确定，详见<a class="xref" href="geqo.html" title="第 60 章 遗传查询优化器">第 60 章</a>。否则处理将和前面相同。
    </p><p>
     成品计划树包含基本关系的顺序或索引扫描，外加所需的嵌套循环、归并或哈希连接节点，以及任何所需的辅助步骤，例如排序节点或聚集函数计算节点。这些节点中的大部分具有执行<em class="firstterm">选择</em>（丢弃不符合指定布尔条件的行）和<em class="firstterm">投影</em>（根据指定列值计算派生列，即标量表达式的计算）的能力。规划器的职责之一就是在计划树最合适的节点上附加来自于子句的选择条件和需要的输出表达式。
    </p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="rule-system.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="overview.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="executor.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">51.4. <span class="productname">PostgreSQL</span>规则系统 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 51.6. 执行器</td></tr></table></div></body></html>