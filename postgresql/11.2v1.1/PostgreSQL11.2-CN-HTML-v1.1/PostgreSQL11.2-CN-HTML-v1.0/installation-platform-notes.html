<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>16.7. 平台相关的说明</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="supported-platforms.html" title="16.6. 平台支持" /><link rel="next" href="install-windows.html" title="第 17 章 在Windows上从源代码安装" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">16.7. 平台相关的说明</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="supported-platforms.html" title="16.6. 平台支持">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="installation.html" title="第 16 章 从源代码安装">上一级</a></td><th width="60%" align="center">第 16 章 从源代码安装</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="install-windows.html" title="第 17 章 在Windows上从源代码安装">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="INSTALLATION-PLATFORM-NOTES"><div class="titlepage"><div><div><h2 class="title" style="clear: both">16.7. 平台相关的说明</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="installation-platform-notes.html#INSTALLATION-NOTES-AIX">16.7.1. AIX</a></span></dt><dt><span class="sect2"><a href="installation-platform-notes.html#INSTALLATION-NOTES-CYGWIN">16.7.2. Cygwin</a></span></dt><dt><span class="sect2"><a href="installation-platform-notes.html#INSTALLATION-NOTES-HPUX">16.7.3. HP-UX</a></span></dt><dt><span class="sect2"><a href="installation-platform-notes.html#INSTALLATION-NOTES-MACOS">16.7.4. macOS</a></span></dt><dt><span class="sect2"><a href="installation-platform-notes.html#INSTALLATION-NOTES-MINGW">16.7.5. MinGW/原生 Windows</a></span></dt><dt><span class="sect2"><a href="installation-platform-notes.html#INSTALLATION-NOTES-SOLARIS">16.7.6. Solaris</a></span></dt></dl></div><p>
   这一节提供了考虑 PostgreSQL 安装和设置的附加平台相关的话题。确保阅读安装指导，特别是<a class="xref" href="install-requirements.html" title="16.2. 要求">第 16.2 节</a>。
   同样，检查关于回归测试结果解释的<a class="xref" href="regress.html" title="第 33 章 回归测试">第 33 章</a>。
  </p><p>
   这里没有覆盖的平台不存在平台相关的安装问题。
  </p><div class="sect2" id="INSTALLATION-NOTES-AIX"><div class="titlepage"><div><div><h3 class="title">16.7.1. AIX</h3></div></div></div><a id="id-1.6.3.10.4.2" class="indexterm"></a><p>
    PostgreSQL 能在 AIX 上工作，但是正确地安装它却富有挑战性。从4.3.3到6.1的 AIX 被认为是可支持的。你可以使用 GCC 或本地 IBM 编译器<code class="command">xlc</code>。通常，使用最新版本的 AIX 和 PostgreSQL 能有所帮助。在编译农场中检查有关已知能工作的 AIX 版本的最新信息。
   </p><p>
    被支持的 AIX 版本的最小推荐修理级别是：
   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">AIX 4.3.3</span></dt><dd><p>Maintenance Level 11 + post ML11 bundle</p></dd><dt><span class="term">AIX 5.1</span></dt><dd><p>Maintenance Level 9 + post ML9 bundle</p></dd><dt><span class="term">AIX 5.2</span></dt><dd><p>Technology Level 10 Service Pack 3</p></dd><dt><span class="term">AIX 5.3</span></dt><dd><p>Technology Level 7</p></dd><dt><span class="term">AIX 6.1</span></dt><dd><p>Base Level</p></dd></dl></div><p>
    要检查你当前的修理级别，在AIX 4.3.3 至 AIX 5.2 ML 7中使用
    <code class="command">oslevel -r</code>，或者在后面的版本中使用
    <code class="command">oslevel -s</code>。
   </p><p>
    如果你已经在<code class="literal">/usr/local</code>中安装了 Readline 或 libz，在你自己的选项之外使用下列<code class="command">configure</code>标志：
    <code class="literal">--with-includes=/usr/local/include
    --with-libraries=/usr/local/lib</code>.
   </p><div class="sect3" id="id-1.6.3.10.4.8"><div class="titlepage"><div><div><h4 class="title">16.7.1.1. GCC问题</h4></div></div></div><p>
     在 AIX 5.3 上，使用 GCC 编译和运行 PostgreSQL 有一些问题。
    </p><p>
     你将要使用 GCC 继 3.3.2 之后的一个版本，特别是如果你在使用一个打包好的版本。我们在 4.0.1 上获得了成功。早期版本的问题看起来更多地与 IBM 打包的 GCC 有关，而非 GCC 真正的问题，因此如果你自己编译 GCC， 你更有可能使用早期版本的 GCC 取得成功。
    </p></div><div class="sect3" id="id-1.6.3.10.4.9"><div class="titlepage"><div><div><h4 class="title">16.7.1.2. Unix域套接字崩溃</h4></div></div></div><p>
     AIX 5.3 有一个问题是<code class="structname">sockaddr_storage</code>定义得不够大。在版本 5.3 中，IBM 增加了<code class="structname">sockaddr_un</code>（Unix域套接字的地址结构）的尺寸，但是没有相应地增加<code class="structname">sockaddr_storage</code>的尺寸。这样做的结果是在 PostgreSQL 中尝试使用 Unix域套接字会导致 libpq 让该数据结构溢出。 TCP/IP 连接工作正常，但是 Unix域套接字不行，这将使回归测试不能工作。
    </p><p>
     该问题已经被报告给了 IBM，并且已被记录为缺陷报告 PMR29657。如果你升级到 maintenance level 5300-03 或更新，将会包括这个修复。一种快速的解决方法是把<code class="filename">/usr/include/sys/socket.h</code>中的<code class="symbol">_SS_MAXSIZE</code>改成 1025。在两种情况中，一旦你得到了修正过的头文件，你都需要重编译 PostgreSQL。
    </p></div><div class="sect3" id="id-1.6.3.10.4.10"><div class="titlepage"><div><div><h4 class="title">16.7.1.3. Internet地址问题</h4></div></div></div><p>
     PostgreSQL 依赖系统的<code class="function">getaddrinfo</code>函数来解析<code class="varname">listen_addresses</code>、<code class="filename">pg_hba.conf</code>等中的 IP 地址。旧版本的 AIX 在这个函数中有各种各样的缺陷。如果你存在与此有关的问题，更新到上文所示的合适的 AIX fix level 将会解决它。
    </p><p>
     一个用户报告：
    </p><p>
     当在 AIX 5.3 上实现 PostgreSQL 版本 8.1 时，我们会周期性地碰到问题，在其中统计收集器会<span class="quote">“<span class="quote">神秘地</span>”</span>无法成功启动。这似乎是在 IPv6 实现中意外行为的结果。看起来 PostgreSQL 和 IPv6 无法和 AIX 5.3 一起很好地工作。
    </p><p>
     下面任意一种动作都可以<span class="quote">“<span class="quote">修复</span>”</span>该问题。
     </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
        删除 localhost 的 IPv6 地址：
</p><pre class="screen">
(as root)
# ifconfig lo0 inet6 ::1/0 delete
</pre><p>
       </p></li><li class="listitem"><p>
        从网络服务删除 IPv6。AIX 上的<code class="filename">/etc/netsvc.conf</code>大概等价于 Solaris/Linux 上的<code class="filename">/etc/nsswitch.conf</code>。在 AIX 上的默认值因此是：
</p><pre class="programlisting">
hosts=local,bind
</pre><p>
        将其换成：
</p><pre class="programlisting">
hosts=local4,bind4
</pre><p>
        来使 IPv6 地址的搜索无效。
       </p></li></ul></div><p>
    </p><div class="warning"><h3 class="title">警告</h3><p>
     这实际上是对有关 IPv6 支持不成熟性的问题的一种变通方案，这在 AIX 5.3 发布的过程中有了显著地改进。它可以和 AIX 5.3 一起工作，但是不代表对此问题的一种华丽的解决方案。有报告称该变通方案不仅仅是多余的，还会在 AIX 6.1 上导致问题，在 AIX 6.1 中 IPv6 支持已变得更加成熟。
    </p></div></div><div class="sect3" id="id-1.6.3.10.4.11"><div class="titlepage"><div><div><h4 class="title">16.7.1.4. 内存管理</h4></div></div></div><p>
     AIX 的特别之处在于它的内存管理。你可能有一个装备有好多个吉字节空闲 RAM 的服务器，但是在运行应用时仍然会得到内存不足或者地址空间错误。一个例子是加载扩展会因为罕见的错误失败。例如，作为 PostgreSQL 安装的拥有者运行：
</p><pre class="screen">
=# CREATE EXTENSION plperl;
ERROR:  could not load library "/opt/dbs/pgsql/lib/plperl.so": A memory address is not in the address space for the process.
</pre><p>
    作为拥有 PostgreSQL 安装的组中的非拥有者运行：
</p><pre class="screen">
=# CREATE EXTENSION plperl;
ERROR:  could not load library "/opt/dbs/pgsql/lib/plperl.so": Bad address
</pre><p>
     另一个例子是 PostgreSQL 服务器日志中的内存不足错误，每次内存分配接近或者超过 256 MB 时都会失败。
    </p><p>
     所有这些问题的总体成因是服务器进程所用的寻址空间和内存模型。默认情况下，所有在 AIX 上编译的二进制都是32位。这并不依赖于硬件类型或使用的内核。这些32位进程被限制在 4GB 的内存中，并被使用几种模型之一安排成 256 MB 的段。该默认值允许在堆中低于 256 MB，因为它和栈共享一个单独的段。
    </p><p>
     在<code class="literal">plperl</code>的例子中，检查你的 umask 和你的 PostgreSQL 安装中的二进制的权限。这个例子中涉及的二进制是32位的并且被用模式 750 而不是 755 安装。由于这种方式的权限设置，只有所有者或拥有组的成员可以载入该库。因为它不是所有人可读的，载入器将该对象放在进程的堆中而不是它应该被放入的共享库段中。
    </p><p>
     这个问题的<span class="quote">“<span class="quote">理想的</span>”</span>解决方案是使用 PostgreSQL 的64位编译，但是这不是总是实用的，因为有32位处理器的系统可以编译64位二进制但是却不能运行它。
    </p><p>
     如果想要一个 32 位二进制，在开始 PostgreSQL 服务器之前将<code class="symbol">LDR_CNTRL</code>设置为<code class="literal">MAXDATA=0x<em class="replaceable"><code>n</code></em>0000000</code>，其中 1 &lt;= n &lt;= 8，并且尝试不同的值以及<code class="filename">postgresql.conf</code>设置来找一个能让你满意的配置。这种<code class="symbol">LDR_CNTRL</code>的使用告诉 AIX 你希望服务器留出<code class="symbol">MAXDATA</code>字节给堆，以 256 MB 的段分配。当你找到了一个可工作的配置时，<code class="command">ldedit</code>可以被用来修改二进制，这样它们默认使用想要的堆尺寸。PostgreSQL 也可以被重新编译，传递<code class="literal">configure  LDFLAGS="-Wl,-bmaxdata:0x<em class="replaceable"><code>n</code></em>0000000"</code>来达到相同的效果。
    </p><p>
     对于一个 64 位编译，设置<code class="envar">OBJECT_MODE</code>为 64 并且传递<code class="literal">CC="gcc -maix64"</code>和<code class="literal">LDFLAGS="-Wl,-bbigtoc"</code>给<code class="command">configure</code>（给<code class="command">xlc</code>的选项可能不同）。如果你省略<code class="envar">OBJECT_MODE</code>的输出，你的编译可能会因为链接器错误而失败。当<code class="envar">OBJECT_MODE</code>被设置时，它告诉 AIX 的编译工具（如<code class="command">ar</code>、<code class="command">as</code>和<code class="command">ld</code>）默认要处理哪些对象类型。
    </p><p>
     默认情况下，过量使用页面空间的情况可能会发生。不过我们还没有看到过，当进程用尽内存并且出现了过量使用时 AIX 会杀死进程。我们见到过的最接近于此的是 fork 失败，其原因是系统觉得已经没有足够的内存给另一个进程。和 AIX 的很多其他部分一样，如果这成为了一个问题，页面空间分配方法和耗尽内存导致的杀死在系统范围或进程范围是可以配置的。
    </p><div class="bibliography" id="id-1.6.3.10.4.11.9"><div class="titlepage"><div><div><h5 class="title">参考和资源</h5></div></div></div><div class="biblioentry" id="id-1.6.3.10.4.11.9.2"><p><span class="biblioset">“<a class="ulink" href="http://publib.boulder.ibm.com/infocenter/pseries/topic/com.ibm.aix.doc/aixprggd/genprogc/lrg_prg_support.htm" target="_top">Large Program Support</a>”. </span><span class="biblioset"><em>AIX Documentation: General Programming Concepts: Writing and Debugging Programs</em>. </span></p></div><div class="biblioentry" id="id-1.6.3.10.4.11.9.3"><p><span class="biblioset">“<a class="ulink" href="http://publib.boulder.ibm.com/infocenter/pseries/topic/com.ibm.aix.doc/aixprggd/genprogc/address_space.htm" target="_top">Program Address Space Overview</a>”. </span><span class="biblioset"><em>AIX Documentation: General Programming Concepts: Writing and Debugging Programs</em>. </span></p></div><div class="biblioentry" id="id-1.6.3.10.4.11.9.4"><p><span class="biblioset">“<a class="ulink" href="http://publib.boulder.ibm.com/infocenter/pseries/v5r3/topic/com.ibm.aix.doc/aixbman/prftungd/resmgmt2.htm" target="_top">Performance Overview of the Virtual Memory Manager (VMM)</a>”. </span><span class="biblioset"><em>AIX Documentation: Performance Management Guide</em>. </span></p></div><div class="biblioentry" id="id-1.6.3.10.4.11.9.5"><p><span class="biblioset">“<a class="ulink" href="http://publib.boulder.ibm.com/infocenter/pseries/v5r3/topic/com.ibm.aix.doc/aixbman/prftungd/memperf7.htm" target="_top">Page Space Allocation</a>”. </span><span class="biblioset"><em>AIX Documentation: Performance Management Guide</em>. </span></p></div><div class="biblioentry" id="id-1.6.3.10.4.11.9.6"><p><span class="biblioset">“<a class="ulink" href="http://publib.boulder.ibm.com/infocenter/pseries/v5r3/topic/com.ibm.aix.doc/aixbman/prftungd/memperf6.htm" target="_top">Paging-space thresholds tuning</a>”. </span><span class="biblioset"><em>AIX Documentation: Performance Management Guide</em>. </span></p></div><div class="biblioentry" id="id-1.6.3.10.4.11.9.7"><p><span class="title"><em><a class="ulink" href="http://www.redbooks.ibm.com/abstracts/sg245674.html?Open" target="_top">Developing and Porting C and C++ Applications on AIX</a></em>. </span><span class="publisher"><span class="publishername">IBM Redbook. </span></span></p></div></div></div></div><div class="sect2" id="INSTALLATION-NOTES-CYGWIN"><div class="titlepage"><div><div><h3 class="title">16.7.2. Cygwin</h3></div></div></div><a id="id-1.6.3.10.5.2" class="indexterm"></a><p>
    PostgreSQL 可以使用 Cygwin 来编译，它是用于 Windows 的一个类 Linux 环境，但是这种方法不如原生 Windows 编译见<a class="xref" href="install-windows.html" title="第 17 章 在Windows上从源代码安装">第 17 章</a>）并且我们已经不再推荐在 Cygwin 下运行一个服务器。
   </p><p>
    在从源代码编译时，按照正常安装过程进行（即<code class="literal">./configure;
    make</code>; 等；只要注意下列 Cygwin 相关的区别：

    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
       将你的路径设置为使用 Cygwin 的 bin 目录并且把它放在 Windows 工具的前面。这将帮助避免很多编译的问题。
      </p></li><li class="listitem"><p>
       不支持<code class="command">adduser</code>命令；使用 Windows NT、2000 或 XP 上的用户管理应用来替代。否则，跳过这一步。
      </p></li><li class="listitem"><p>
       不支持<code class="command">su</code>命令；在 Windows NT、2000 或 XP 上使用 ssh 来模拟 su。否则，跳过这一步。
      </p></li><li class="listitem"><p>
       不支持 OpenSSL。
      </p></li><li class="listitem"><p>
       为共享内存支持启动<code class="command">cygserver</code>。要这样做，输入命令<code class="literal">/usr/sbin/cygserver &amp;</code>。这个程序在你启动 PostgreSQL 服务器或初始化一个数据集簇（<code class="command">initdb</code>）时的任何时刻都需要被运行。默认的<code class="command">cygserver</code>配置可能需要被更改（例如增加<code class="symbol">SEMMNS</code>）来防止 PostgreSQL 因为缺少系统资源而失败。
      </p></li><li class="listitem"><p>
        在某些不使用 C 区域的系统上编译可能会失败。要修复这个问题，通过在边以前<code class="command">export LANG=C.utf8</code>把区域设置为 C，并且在安装完 PostgreSQL 之后把区域恢复成之前的设置。
      </p></li><li class="listitem"><p>
       并行回归测试（<code class="literal">make check</code>）可能产生虚假的回归测试错误，这是由于溢出的<code class="function">listen()</code>连接缓冲区，它会导致连接拒绝错误或挂起。你可以使用<code class="varname">MAX_CONNECTIONS</code>来限制连接数：
</p><pre class="programlisting">
make MAX_CONNECTIONS=5 check
</pre><p>
       （在某些系统上你可以有大约 10 个同时连接）。
      </p></li></ul></div><p>
   </p><p>
    可以把<code class="command">cygserver</code> PostgreSQL 服务器安装为 Windows NT 服务。关于如何这样做的信息，请参考包含在 Cygwin 上 PostgreSQL 二进制包中的<code class="filename">README</code>文档。它被安装在目录<code class="filename">/usr/share/doc/Cygwin</code>中。
   </p></div><div class="sect2" id="INSTALLATION-NOTES-HPUX"><div class="titlepage"><div><div><h3 class="title">16.7.3. HP-UX</h3></div></div></div><a id="id-1.6.3.10.6.2" class="indexterm"></a><p>
    给定合适的系统补丁级别和编译工具，PostgreSQL 7.3+ 应该可以工作在运行 HP-UX 10.X 或 11.X 的 Series 700/800 PA-RISC 机器上。至少一个开发者例行地在 HP-UX 10.20 上测试过，并且我们有在 HP-UX 11.00 和 11.11 上成功安装的报告。
   </p><p>
    除了 PostgreSQL 源代码发布，你将需要 GNU make（HP 的 make 不行），并且需要 GCC 或 HP 的 ANSI C 编译器。如果你想从 Git 源编译而不是一个发布包，你还将需要 Flex（GNU lex）和 Bison（GNU yacc）。我们还推荐确认你真的在使用最新的 HP 补丁。最低限度下，如果你在 HP-UX 11.11 上编译 64 位二进制，你可能需要 PHSS_30966 (11.11) 或一个后继补丁，否则<code class="command">initdb</code>可能中止：
</p><div class="literallayout"><p><br />
PHSS_30966  s700_800 ld(1) and linker tools cumulative patch<br />
</p></div><p>

    在一般原则上，你应该使用 libc 和 ld/dld 的当前补丁，如果你在使用 HP 的 C 编译器也一样要用当前的编译器补丁。它们最新补丁的免费拷贝请见 HP 的支持站点如<a class="ulink" href="ftp://us-ffs.external.hp.com/" target="_top">ftp://us-ffs.external.hp.com/</a>。
   </p><p>
    如果你正在一台 PA-RISC 2.0 机器上编译并且项使用 GCC 得到 64 位二进制，你必须使用 GCC 的 64 位版本。
   </p><p>
    如果你正在一台 PA-RISC 2.0 机器上编译并且想让编译好的二进制运行在 PA-RISC 1.1 机器上，你将需要在<code class="envar">CFLAGS</code>中指定<code class="option">+DAportable</code>。
   </p><p>
    如果你正在一台 HP-UX Itanium 机器上编译，你将需要最新的 HP ANSI C 编译器，以及它的依赖补丁或后继补丁：
</p><div class="literallayout"><p><br />
PHSS_30848  s700_800 HP C Compiler (A.05.57)<br />
PHSS_30849  s700_800 u2comp/be/plugin library Patch<br />
</p></div><p>
   </p><p>
    如果你同时有 HP 的 C 编译器和 GCC 的编译器，那么在运行<code class="command">configure</code>时你可能希望显式地选择要使用的编译器：
</p><pre class="programlisting">
./configure CC=cc
</pre><p>
    用于 HP 的 C 编译器，或者
</p><pre class="programlisting">
./configure CC=gcc
</pre><p>
    用于 GCC。如果你忽略这个设置，configure 在可以选择时会使用<code class="command">gcc</code>。
   </p><p>
    默认的安装目标位置是<code class="filename">/usr/local/pgsql</code>，你可能希望修改它为<code class="filename">/opt</code>之下的某个地方。如果是这样，使用<code class="command">configure</code>的<code class="option">--prefix</code>开关。
   </p><p>
    在回归测试中，在几何测试中可能会有某些低序位差别，这会根据你使用的编译器和数学库版本而变化。任何其他错误都需要怀疑。
   </p></div><div class="sect2" id="INSTALLATION-NOTES-MACOS"><div class="titlepage"><div><div><h3 class="title">16.7.4. macOS</h3></div></div></div><a id="id-1.6.3.10.7.2" class="indexterm"></a><p>
    在最新的<span class="productname">macOS</span>版本中，有必要将<span class="quote">“<span class="quote">sysroot</span>”</span>
    路径嵌入用于查找某些系统头文件的include选项中。这导致<span class="application">configure</span>
    脚本的输出会有所不同，具体取决于在<span class="application">configure</span>期间使用的SDK版本。
    
    在简单的情况下，这应该不会造成任何问题，但是，如果您要尝试在与构建服务器代码不同
    的计算机上构建扩展程序，则可能需要强制使用其他sysroot路径。为此，需要设置
    <code class="varname">PG_SYSROOT</code>，例如：
</p><pre class="programlisting">
make PG_SYSROOT=<em class="replaceable"><code>/desired/path</code></em> all
</pre><p>
    要在您的计算机上找到合适的路径，请运行
</p><pre class="programlisting">
xcodebuild -version -sdk macosx Path
</pre><p>
    请注意，实际上不建议使用与构建核心服务器不同的sysroot版本构建扩展。
    在最坏的情况下，它可能导致难以调试的ABI不一致。
   </p><p>
    您还可以在配置时选择非默认的sysroot路径，通过在
    <span class="application">configure</span>中指定<code class="varname">PG_SYSROOT</code>：
</p><pre class="programlisting">
./configure ... PG_SYSROOT=<em class="replaceable"><code>/desired/path</code></em>
</pre><p>
   </p><p>
   <span class="productname">macOS</span>的<span class="quote">“<span class="quote">系统完整性保护</span>”</span>（SIP）
    功能破坏了<code class="literal">make check</code>，因为它阻止通过
    设置所需的<code class="literal">DYLD_LIBRARY_PATH</code>传递给被测试的可执行文件。
   
    您可以通过在<code class="literal">make check</code>之前执行<code class="literal">make install</code>来解决此问题。
    不过，大多数Postgres开发人员关闭了SIP。
   </p></div><div class="sect2" id="INSTALLATION-NOTES-MINGW"><div class="titlepage"><div><div><h3 class="title">16.7.5. MinGW/原生 Windows</h3></div></div></div><a id="id-1.6.3.10.8.2" class="indexterm"></a><p>
    用于 Windows 的 PostgreSQL 可以使用 MinGW 编译，它是一个用于微软操作系统的类 Unix 的编译环境。也可以使用微软的<span class="productname">Visual C++</span>编译器套件来编译。MinGW 编译使用本章中描述的正常编译系统；而  Visual C++ 编译的工作完全不同并且在
    <a class="xref" href="install-windows.html" title="第 17 章 在Windows上从源代码安装">第 17 章</a>/中描述。后者是一种完全原生的编译并且没有像 MinGW 那样使用额外软件。在 PostgreSQL 的主网站上有一个现成的安装器可用。
   </p><p>
    原生 Windows 移植要求一个 Windows 2000 或更高的 32 或 64 位版本。早期的操作系统没有足够的基础设施（但 Cygwin可以用在它们之上）。类 Unix 的编译工具 MinGW 和 MSYS（一个 Unix 工具集合，用于运行如<code class="command">configure</code>之类的 shell 脚本）可以从<a class="ulink" href="http://www.mingw.org/" target="_top">http://www.mingw.org/</a>下载。运行结果二进制两者都需要，它们只在创建二进制时需要。
   </p><p>
     要使用 MinGW 编译 64 位二进制，从<a class="ulink" href="http://mingw-w64.sourceforge.net/" target="_top">http://mingw-w64.sourceforge.net/</a>安装 64 位工具。把它放在<code class="envar">PATH</code>中的 bin 目录，并且使用<code class="command">--host=x86_64-w64-mingw32</code>选项运行<code class="command">configure</code>.
   </p><p>
    在你安装完所有的东西之后，我们建议你在<code class="command">CMD.EXE</code>下运行<span class="application">psql</span>，因为 MSYS 控制台有缓冲问题。
   </p><div class="sect3" id="WINDOWS-CRASH-DUMPS"><div class="titlepage"><div><div><h4 class="title">16.7.5.1. 在 Windows 上收集崩溃转储</h4></div></div></div><p>
     如果 PostgreSQL 在 Windows 上崩溃，它有能力产生<span class="productname">minidumps</span>，这可以被用来追踪崩溃发生的原因，这与 Unix 上的核心转储相似。这些转储可以被使用<span class="productname">Windows Debugger Tools</span>或<span class="productname">Visual Studio</span>读取。要启用在 Windows 上的转储生成，可在集簇数据目录下创建一个名为<code class="filename">crashdumps</code>的子目录。转储将被写入到这个目录，转储的名字基于崩溃进程的标识符和崩溃的当前时间来确定。
    </p></div></div><div class="sect2" id="INSTALLATION-NOTES-SOLARIS"><div class="titlepage"><div><div><h3 class="title">16.7.6. Solaris</h3></div></div></div><a id="id-1.6.3.10.9.2" class="indexterm"></a><p>
    PostgreSQL 在 Solaris 上得到了很好的支持。你的操作系统越新，你将会碰到更少的问题；细节如下。
   </p><div class="sect3" id="id-1.6.3.10.9.4"><div class="titlepage"><div><div><h4 class="title">16.7.6.1. 要求的工具</h4></div></div></div><p>
     你可以使用 GCC 或 Sun 的编译器套件进行编译。为了更好的代码优化，我们强烈推荐在 SPARC 架构下使用 Sun 的编译器。我们已经得到一些使用 GCC 2.95.1 时的问题报告；我们推荐 GCC 2.95.3 或之后的版本。如果你正在使用 Sun 的编译器，注意不要选择<code class="filename">/usr/ucb/cc</code>；而是使用<code class="filename">/opt/SUNWspro/bin/cc</code>。
    </p><p>
     你可以从<a class="ulink" href="https://www.oracle.com/technetwork/server-storage/solarisstudio/downloads/" target="_top">https://www.oracle.com/technetwork/server-storage/solarisstudio/downloads/</a>下载 Sun Studio。很多 GNU 工具都被整合到了 Solaris 10，或者它们在 Solaris companion CD 中。如果你喜欢用于老版本 Solaris 的包，你可以在<a class="ulink" href="http://www.sunfreeware.com" target="_top">http://www.sunfreeware.com</a>找到这些工具。如果你想要源码，在<a class="ulink" href="https://www.gnu.org/prep/ftp" target="_top">https://www.gnu.org/prep/ftp</a>上找找。
    </p></div><div class="sect3" id="id-1.6.3.10.9.5"><div class="titlepage"><div><div><h4 class="title">16.7.6.2. configure 抱怨一个失败的测试程序</h4></div></div></div><p>
     如果<code class="command">configure</code>抱怨一个失败的测试程序，可能的情况是运行时链接器无法找到某些库，可能是libz、libreadline或某些其他非标准库如 libssl。要向它指出正确的位置，在<code class="command">configure</code>命令行上设置<code class="envar">LDFLAGS</code>环境变量，例如：
</p><pre class="programlisting">
configure ... LDFLAGS="-R /usr/sfw/lib:/opt/sfw/lib:/usr/local/lib"
</pre><p>
     更多信息可见<span class="citerefentry"><span class="refentrytitle">ld</span></span>手册页。
    </p></div><div class="sect3" id="id-1.6.3.10.9.6"><div class="titlepage"><div><div><h4 class="title">16.7.6.3. 64-位编译有时会崩溃</h4></div></div></div><p>
     在 Solaris 7 和更老的版本上，64-位版本的 libc 有一个有缺陷的<code class="function">vsnprintf</code>例程，这导致 PostgreSQL 中不稳定的核心转储。最简单的已知解决方案是强制 PostgreSQL 使用它自己的<code class="function">vsnprintf</code>版本而不是库中的拷贝。要这样做，运行<code class="command">configure</code>之后编辑一个由<code class="command">configure</code>产生的文件：
     在文件<code class="filename">src/Makefile.global</code>中将行
</p><pre class="programlisting">
LIBOBJS =
</pre><p>
     改成
</p><pre class="programlisting">
LIBOBJS = snprintf.o
</pre><p>
     （可能有其他文件已经被列在这个变量中。顺序无影响）。然后正常编译。
    </p></div><div class="sect3" id="id-1.6.3.10.9.7"><div class="titlepage"><div><div><h4 class="title">16.7.6.4. 为最优性能编译</h4></div></div></div><p>
     在 SPARC 架构上，我们强烈推荐使用 Sun Studio来编译。尝试使用<code class="option">-xO5</code>优化标志来生成显著加快的二进制。不要使用任何修改浮点操作和<code class="varname">errno</code>处理（例如<code class="option">-fast</code>）行为的标志。这些标志可能会做出某些非标准 PostgreSQL 行为，例如在日期/时间计算中。
    </p><p>
     如果你没有理由要使用 SPARC 上的 64 位二进制，最好用 32 位版本。64 位操作较慢并且 64 位二进制比其 32 位变体要慢。并且在另一方面，AMD64 CPU 家族上的32 位代码不是原生的，并且这也是问什么在这个 CPU 族中 32 位代码要明显地更慢。
    </p></div><div class="sect3" id="id-1.6.3.10.9.8"><div class="titlepage"><div><div><h4 class="title">16.7.6.5. 用 DTrace 来跟踪 PostgreSQL</h4></div></div></div><p>
     是的，可以使用 DTrace。详见<a class="xref" href="dynamic-trace.html" title="28.5. 动态追踪">第 28.5 节</a>。
    </p><p>
     如果你看到<code class="command">postgres</code>可执行程序的链接中断并且报出下面的错误消息：
</p><pre class="screen">
Undefined                       first referenced
 symbol                             in file
AbortTransaction                    utils/probes.o
CommitTransaction                   utils/probes.o
ld: fatal: Symbol referencing errors. No output written to postgres
collect2: ld returned 1 exit status
make: *** [postgres] Error 1
</pre><p>
     说明你的 DTrace 安装太旧，无法处理静态函数中的探测。你需要 Solaris 10u4 或更新的版本。
    </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="supported-platforms.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="installation.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="install-windows.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">16.6. 平台支持 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 第 17 章 在<span class="productname">Windows</span>上从源代码安装</td></tr></table></div></body></html>