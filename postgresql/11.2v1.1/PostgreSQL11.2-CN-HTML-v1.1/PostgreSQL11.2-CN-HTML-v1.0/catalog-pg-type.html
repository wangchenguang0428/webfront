<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>52.62. pg_type</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="catalog-pg-ts-template.html" title="52.61. pg_ts_template" /><link rel="next" href="catalog-pg-user-mapping.html" title="52.63. pg_user_mapping" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">52.62. <code xmlns="http://www.w3.org/1999/xhtml" class="structname">pg_type</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="catalog-pg-ts-template.html" title="52.61. pg_ts_template">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="catalogs.html" title="第 52 章 系统目录">上一级</a></td><th width="60%" align="center">第 52 章 系统目录</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="catalog-pg-user-mapping.html" title="52.63. pg_user_mapping">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="CATALOG-PG-TYPE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">52.62. <code class="structname">pg_type</code></h2></div></div></div><a id="id-1.10.4.64.2" class="indexterm"></a><p>
   目录<code class="structname">pg_type</code>存储有关数据类型的信息。基类和枚举类型（标度类型）使用<a class="xref" href="sql-createtype.html" title="CREATE TYPE"><span class="refentrytitle">CREATE TYPE</span></a>创建，而域使用<a class="xref" href="sql-createdomain.html" title="CREATE DOMAIN"><span class="refentrytitle">CREATE DOMAIN</span></a>创建。数据库中的每一个表都会有一个自动创建的组合类型，用于表示表的行结构。也可以使用<code class="command">CREATE TYPE AS</code>创建组合类型。
  </p><div class="table" id="id-1.10.4.64.4"><p class="title"><strong>表 52.62. <code class="structname">pg_type</code>的列</strong></p><div class="table-contents"><table class="table" summary="pg_type的列" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>类型</th><th>引用</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">oid</code></td><td><code class="type">oid</code></td><td> </td><td>行标识符（隐藏属性，必须被显式选择才会显示）</td></tr><tr><td><code class="structfield">typname</code></td><td><code class="type">name</code></td><td> </td><td>数据类型的名字</td></tr><tr><td><code class="structfield">typnamespace</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-namespace.html" title="52.32. pg_namespace"><code class="structname">pg_namespace</code></a>.oid</code></td><td>
       包含此类型的名字空间的OID
      </td></tr><tr><td><code class="structfield">typowner</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-authid.html" title="52.8. pg_authid"><code class="structname">pg_authid</code></a>.oid</code></td><td>类型的拥有者</td></tr><tr><td><code class="structfield">typlen</code></td><td><code class="type">int2</code></td><td> </td><td>
       对于一个固定尺寸的类型，<code class="structfield">typlen</code>是该类型内部表示的字节数。对于一个变长类型，<code class="structfield">typlen</code>为负值。-1表示一个<span class="quote">“<span class="quote">varlena</span>”</span>类型（具有长度字），-2表示一个以空值结尾的C字符串。
      </td></tr><tr><td><code class="structfield">typbyval</code></td><td><code class="type">bool</code></td><td> </td><td>
       <code class="structfield">typbyval</code>判断内部例程传递这个类型的数值时是通过传值还是传引用。如果<code class="structfield">typlen</code>不是1、2或4（或者在Datum为8字节的机器上为8），因此<code class="structfield">typbyval</code>最好是假。变长类型总是传引用。注意即使长度允许传值， <code class="structfield">typbyval</code>也可以为假。
      </td></tr><tr><td><code class="structfield">typtype</code></td><td><code class="type">char</code></td><td> </td><td>
       <code class="structfield">typtype</code>可以是：
       <code class="literal">b</code>表示一个基类，
       <code class="literal">c</code>表示一个组合类型（例如一个表的行类型），
       <code class="literal">d</code>表示一个域，
       <code class="literal">e</code>表示一个枚举类型，
       <code class="literal">p</code>表示一个伪类型，或
       <code class="literal">r</code>表示一个范围类型。
       另请参阅<code class="structfield">typrelid</code>和<code class="structfield">typbasetype</code>.
      </td></tr><tr><td><code class="structfield">typcategory</code></td><td><code class="type">char</code></td><td> </td><td>
       <code class="structfield">typcategory</code>是一种任意的数据类型分类，它被分析器用来决定哪种隐式转换<span class="quote">“<span class="quote">更好</span>”</span>。参见<a class="xref" href="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE" title="表 52.63. typcategory编码">表 52.63</a>。
      </td></tr><tr><td><code class="structfield">typispreferred</code></td><td><code class="type">bool</code></td><td> </td><td>
       如果此类型在它的<code class="structfield">typcategory</code>中是一个更好的转换目标，此列为真
      </td></tr><tr><td><code class="structfield">typisdefined</code></td><td><code class="type">bool</code></td><td> </td><td>
       如果此类型已被定义则为真，如果此类型只是一个表示还未定义类型的占位符则为假。当<code class="structfield">typisdefined</code>为假，除了类型名字、名字空间和OID之外什么都不能被依赖。
      </td></tr><tr><td><code class="structfield">typdelim</code></td><td><code class="type">char</code></td><td> </td><td>
       在分析数组输入时，分隔两个此类型值的字符。注意该分隔符是与数组元素数据类型相关联的， 而不是和数组的数据类型关联。
      </td></tr><tr><td><code class="structfield">typrelid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-class.html" title="52.11. pg_class"><code class="structname">pg_class</code></a>.oid</code></td><td>
       如果这是一个复合类型（见<code class="structfield">typtype</code>）， 那么这个列指向<code class="structname">pg_class</code>中定义对应表的项（对于自由存在的复合类型，<code class="structname">pg_class</code>项并不表示一个表，但不管怎样该类型的<code class="structname">pg_attribute</code>项需要链接到它）。对非复合类型此列为零。
      </td></tr><tr><td><code class="structfield">typelem</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-type.html" title="52.62. pg_type"><code class="structname">pg_type</code></a>.oid</code></td><td>
       如果<code class="structfield">typelem</code>不为0，则它标识<code class="structname">pg_type</code>里面的另外一行。 当前类型可以被加上下标得到一个值为类型<code class="structfield">typelem</code>的数组来描述。 一个<span class="quote">“<span class="quote">真的</span>”</span>数组类型是变长的（<code class="structfield">typlen</code> = -1），但是一些定长的（<code class="structfield">typlen</code> &gt; 0）类型也拥有非零的<code class="structfield">typelem</code>，比如<code class="type">name</code>和<code class="type">point</code>。 如果一个定长类型拥有一个<code class="structfield">typelem</code>， 则它的内部形式必须是某个<code class="structfield">typelem</code>数据类型的值，不能有其它数据。变长数组类型有一个由该数组子例程定义的头。
      </td></tr><tr><td><code class="structfield">typarray</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-type.html" title="52.62. pg_type"><code class="structname">pg_type</code></a>.oid</code></td><td>
       如果<code class="structfield">typarray</code>不是0，则它标识<code class="structname">pg_type</code>中的另一行，这一行是一个将此类型作为元素的<span class="quote">“<span class="quote">真的</span>”</span>数组类型
      </td></tr><tr><td><code class="structfield">typinput</code></td><td><code class="type">regproc</code></td><td><code class="literal"><a class="link" href="catalog-pg-proc.html" title="52.39. pg_proc"><code class="structname">pg_proc</code></a>.oid</code></td><td>输入转换函数（文本格式）</td></tr><tr><td><code class="structfield">typoutput</code></td><td><code class="type">regproc</code></td><td><code class="literal"><a class="link" href="catalog-pg-proc.html" title="52.39. pg_proc"><code class="structname">pg_proc</code></a>.oid</code></td><td>输出转换函数（文本格式）</td></tr><tr><td><code class="structfield">typreceive</code></td><td><code class="type">regproc</code></td><td><code class="literal"><a class="link" href="catalog-pg-proc.html" title="52.39. pg_proc"><code class="structname">pg_proc</code></a>.oid</code></td><td>输入转换函数（二进制格式），如果没有则为0</td></tr><tr><td><code class="structfield">typsend</code></td><td><code class="type">regproc</code></td><td><code class="literal"><a class="link" href="catalog-pg-proc.html" title="52.39. pg_proc"><code class="structname">pg_proc</code></a>.oid</code></td><td>输出转换函数（二进制格式），如果没有则为0</td></tr><tr><td><code class="structfield">typmodin</code></td><td><code class="type">regproc</code></td><td><code class="literal"><a class="link" href="catalog-pg-proc.html" title="52.39. pg_proc"><code class="structname">pg_proc</code></a>.oid</code></td><td>类型修改器输入函数，如果类型没有提供修改器则为0</td></tr><tr><td><code class="structfield">typmodout</code></td><td><code class="type">regproc</code></td><td><code class="literal"><a class="link" href="catalog-pg-proc.html" title="52.39. pg_proc"><code class="structname">pg_proc</code></a>.oid</code></td><td>类型修改器输出函数，如果类型没有提供修改器则为0</td></tr><tr><td><code class="structfield">typanalyze</code></td><td><code class="type">regproc</code></td><td><code class="literal"><a class="link" href="catalog-pg-proc.html" title="52.39. pg_proc"><code class="structname">pg_proc</code></a>.oid</code></td><td>自定义<code class="command">ANALYZE</code>函数，0表示使用标准函数</td></tr><tr><td><code class="structfield">typalign</code></td><td><code class="type">char</code></td><td> </td><td><p>

       <code class="structfield">typalign</code>是当存储此类型值时要求的对齐性质。它应用于磁盘存储以及该值在 <span class="productname">PostgreSQL</span>内部的大多数表现形式。 如果数值是连续存放的，比如在磁盘上的一个完整行，在这种类型的数据前会插入填充，这样它就可以按照指定边界存储。 对齐引用是该序列中第一个数据的开头。对齐引用是序列中第一个数据的开始。
      </p>

      <p>
       可能的值有：
       </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">c</code> = <code class="type">char</code>对齐，即不需要对齐。</p></li><li class="listitem"><p><code class="literal">s</code> = <code class="type">short</code>对齐（在大部分机器上为2字节）。</p></li><li class="listitem"><p><code class="literal">i</code> = <code class="type">int</code>对齐（在大部分机器上为4字节）。</p></li><li class="listitem"><p><code class="literal">d</code> = <code class="type">double</code>对齐（在很多机器上为8字节，但绝不是全部）。</p></li></ul></div><p>
      </p><div class="note"><h3 class="title">注意</h3><p>
        对于系统表中使用的类型，很关键的是，<code class="structname">pg_type</code>中定义的尺寸和对齐方式要和编译器在表示表行的结构中布局列的方式保持一致。
       </p></div></td></tr><tr><td><code class="structfield">typstorage</code></td><td><code class="type">char</code></td><td> </td><td><p>
       如果一个变长类型（<code class="structfield">typlen</code> = -1）可被TOAST，<code class="structfield">typstorage</code>说明这种类型的列应采取的默认策略。可能的值是：
       </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">p</code>：值必须平面存储。</p></li><li class="listitem"><p>
          <code class="literal">e</code>：值可以被存储在一个<span class="quote">“<span class="quote">二级</span>”</span>关系（如果有，见<code class="literal">pg_class.reltoastrelid</code>）。
         </p></li><li class="listitem"><p><code class="literal">m</code>：值可以被压缩线内存储。</p></li><li class="listitem"><p><code class="literal">x</code>：值可以被压缩线内存储或存储在<span class="quote">“<span class="quote">二级</span>”</span>存储。</p></li></ul></div><p>
       注意<code class="literal">m</code>列也可以被移动到二级存储，但只能是作为最后一种方案（<code class="literal">e</code>和<code class="literal">x</code>列会先被移动）。
      </p></td></tr><tr><td><code class="structfield">typnotnull</code></td><td><code class="type">bool</code></td><td> </td><td><p>
       <code class="structfield">typnotnull</code>表示类型上的一个非空约束。只用于域。
      </p></td></tr><tr><td><code class="structfield">typbasetype</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-type.html" title="52.62. pg_type"><code class="structname">pg_type</code></a>.oid</code></td><td><p>
       如果这是一个域（见<code class="structfield">typtype</code>），则<code class="structfield">typbasetype</code>标识这个域基于的类。如果此类不是一个域则为0。
      </p></td></tr><tr><td><code class="structfield">typtypmod</code></td><td><code class="type">int4</code></td><td> </td><td><p>
       域使用<code class="structfield">typtypmod</code>来记录被应用于它们基类型的<code class="literal">typmod</code>（如果基类型不使用<code class="literal">typmod</code>，则为-1）。如果此类型不是一个域则为-1。
      </p></td></tr><tr><td><code class="structfield">typndims</code></td><td><code class="type">int4</code></td><td> </td><td><p>
       对于一个数组上的域，<code class="structfield">typndims</code>是数组维度数（即，<code class="structfield">typbasetype</code>是一个数组类型）。除数组类型上的域之外的类型的此列为0。
       </p></td></tr><tr><td><code class="structfield">typcollation</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-collation.html" title="52.12. pg_collation"><code class="structname">pg_collation</code></a>.oid</code></td><td><p>
       <code class="structfield">typcollation</code>指定此类型的排序规则。如果类型不支持排序规则，此列为0。一个支持排序规则的基类型此列值为<code class="symbol">DEFAULT_COLLATION_OID</code>。如果一个可排序类型上的域被指定了一个排序规则，该域可能使用某些其他排序规则OID。
      </p></td></tr><tr><td><code class="structfield">typdefaultbin</code></td><td><code class="type">pg_node_tree</code></td><td> </td><td><p>
       如果<code class="structfield">typdefaultbin</code>为非空，那么它是 该类型默认表达式的<code class="function">nodeToString()</code>表现形式。这个列只用于域。
      </p></td></tr><tr><td><code class="structfield">typdefault</code></td><td><code class="type">text</code></td><td> </td><td><p>
       如果某类型没有相关默认值，那么<code class="structfield">typdefault</code>为空。如果<code class="structfield">typdefaultbin</code>不为空， 那么<code class="structfield">typdefault</code>必须包含一个<code class="structfield">typdefaultbin</code>所指的默认表达式的人类可读的版本。 如果<code class="structfield">typdefaultbin</code>为空但<code class="structfield">typdefault</code>不为空，则<code class="structfield">typdefault</code>是该类型默认值的外部表现形式， 它可以被交给该类型的输入转换器来产生一个常量。
      </p></td></tr><tr><td><code class="structfield">typacl</code></td><td><code class="type">aclitem[]</code></td><td> </td><td>
       访问权限，另请参阅<a class="xref" href="sql-grant.html" title="GRANT"><span class="refentrytitle">GRANT</span></a>和<a class="xref" href="sql-revoke.html" title="REVOKE"><span class="refentrytitle">REVOKE</span></a>
      </td></tr></tbody></table></div></div><br class="table-break" /><p>
   <a class="xref" href="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE" title="表 52.63. typcategory编码">表 52.63</a>列出了<code class="structfield">typcategory</code>的系统定义值。任何未来对此列表的增加都将是大写ASCII字母。所有其他ASCII字符都保留给用户定义的类别。
  </p><div class="table" id="CATALOG-TYPCATEGORY-TABLE"><p class="title"><strong>表 52.63. <code class="structfield">typcategory</code>编码</strong></p><div class="table-contents"><table class="table" summary="typcategory编码" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>编码</th><th>类别</th></tr></thead><tbody><tr><td><code class="literal">A</code></td><td>数组类型</td></tr><tr><td><code class="literal">B</code></td><td>布尔类型</td></tr><tr><td><code class="literal">C</code></td><td>组合类型</td></tr><tr><td><code class="literal">D</code></td><td>日期/时间类型</td></tr><tr><td><code class="literal">E</code></td><td>枚举类型</td></tr><tr><td><code class="literal">G</code></td><td>几何类型</td></tr><tr><td><code class="literal">I</code></td><td>网络地址类型</td></tr><tr><td><code class="literal">N</code></td><td>数字类型</td></tr><tr><td><code class="literal">P</code></td><td>伪类型</td></tr><tr><td><code class="literal">R</code></td><td>范围类型</td></tr><tr><td><code class="literal">S</code></td><td>字符串类型</td></tr><tr><td><code class="literal">T</code></td><td>时间间隔类型</td></tr><tr><td><code class="literal">U</code></td><td>用户定义类型</td></tr><tr><td><code class="literal">V</code></td><td>位串类型</td></tr><tr><td><code class="literal">X</code></td><td><code class="type">未知</code>类型</td></tr></tbody></table></div></div><br class="table-break" /></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="catalog-pg-ts-template.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="catalogs.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="catalog-pg-user-mapping.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">52.61. <code class="structname">pg_ts_template</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 52.63. <code class="structname">pg_user_mapping</code></td></tr></table></div></body></html>