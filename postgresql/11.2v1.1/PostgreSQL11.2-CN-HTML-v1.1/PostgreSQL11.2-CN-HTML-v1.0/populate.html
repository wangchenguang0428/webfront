<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>14.4. 填充一个数据库</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="explicit-joins.html" title="14.3. 用显式JOIN子句控制规划器" /><link rel="next" href="non-durability.html" title="14.5. 非持久设置" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">14.4. 填充一个数据库</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="explicit-joins.html" title="14.3. 用显式JOIN子句控制规划器">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="performance-tips.html" title="第 14 章 性能提示">上一级</a></td><th width="60%" align="center">第 14 章 性能提示</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="non-durability.html" title="14.5. 非持久设置">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="POPULATE"><div class="titlepage"><div><div><h2 class="title" style="clear: both">14.4. 填充一个数据库</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="sect2"><a href="populate.html#DISABLE-AUTOCOMMIT">14.4.1. 禁用自动提交</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-COPY-FROM">14.4.2. 使用<code class="command">COPY</code></a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-RM-INDEXES">14.4.3. 移除索引</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-RM-FKEYS">14.4.4. 移除外键约束</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-WORK-MEM">14.4.5. 增加<code class="varname">maintenance_work_mem</code></a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-MAX-WAL-SIZE">14.4.6. 增加<code class="varname">max_wal_size</code></a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-PITR">14.4.7. 禁用 WAL 归档和流复制</a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-ANALYZE">14.4.8. 事后运行<code class="command">ANALYZE</code></a></span></dt><dt><span class="sect2"><a href="populate.html#POPULATE-PG-DUMP">14.4.9. 关于<span class="application">pg_dump</span>的一些注记</a></span></dt></dl></div><p>
   第一次填充数据库时可能需要插入大量的数据。本节包含一些如何让这个处理尽可能高效的建议。
  </p><div class="sect2" id="DISABLE-AUTOCOMMIT"><div class="titlepage"><div><div><h3 class="title">14.4.1. 禁用自动提交</h3></div></div></div><a id="id-1.5.13.7.3.2" class="indexterm"></a><p>
    在使用多个<code class="command">INSERT</code>时，关闭自动提交并且只在最后做一次提交（在普通 SQL 中，这意味着在开始发出<code class="command">BEGIN</code>并且在结束时发出<code class="command">COMMIT</code>。某些客户端库可能背着你就做了这些，在这种情况下你需要确定在你需要做这些时该库确实帮你做了）。如果你允许每一个插入都被独立地提交，<span class="productname">PostgreSQL</span>要为每一个被增加的行做很多工作。在一个事务中做所有插入的一个额外好处是：如果一个行的插入失败则所有之前插入的行都会被回滚，这样你不会被卡在部分载入的数据中。
   </p></div><div class="sect2" id="POPULATE-COPY-FROM"><div class="titlepage"><div><div><h3 class="title">14.4.2. 使用<code class="command">COPY</code></h3></div></div></div><p>
    使用<a class="xref" href="sql-copy.html" title="COPY"><span class="refentrytitle">COPY</span></a>在一条命令中装载所有记录，而不是一系列<code class="command">INSERT</code>命令。 <code class="command">COPY</code>命令是为装载大量行而优化过的； 它没<code class="command">INSERT</code>那么灵活，但是在大量数据装载时导致的负荷也更少。 因为<code class="command">COPY</code>是单条命令，因此使用这种方法填充表时无须关闭自动提交。
   </p><p>
    如果你不能使用<code class="command">COPY</code>，那么使用<a class="xref" href="sql-prepare.html" title="PREPARE"><span class="refentrytitle">PREPARE</span></a>来创建一个预备<code class="command">INSERT</code>语句也有所帮助，然后根据需要使用<code class="command">EXECUTE</code>多次。这样就避免了重复分析和规划<code class="command">INSERT</code>的负荷。不同接口以不同的方式提供该功能， 可参阅接口文档中的<span class="quote">“<span class="quote">预备语句</span>”</span>。
   </p><p>
    请注意，在载入大量行时，使用<code class="command">COPY</code>几乎总是比使用<code class="command">INSERT</code>快， 即使使用了<code class="command">PREPARE</code>并且把多个插入被成批地放入一个单一事务。
   </p><p>
    同样的事务中，<code class="command">COPY</code>比更早的<code class="command">CREATE TABLE</code>或<code class="command">TRUNCATE</code>命令更快。 在这种情况下，不需要写 WAL，因为在一个错误的情况下，包含新载入数据的文件不管怎样都将被移除。不过，只有当<a class="xref" href="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</a>设置为<code class="literal">minimal</code>（此时所有的命令必须写 WAL）时才会应用这种考虑。
   </p></div><div class="sect2" id="POPULATE-RM-INDEXES"><div class="titlepage"><div><div><h3 class="title">14.4.3. 移除索引</h3></div></div></div><p>
    如果你正在载入一个新创建的表，最快的方法是创建该表，用<code class="command">COPY</code>批量载入该表的数据，然后创建表需要的任何索引。在已存在数据的表上创建索引要比在每一行被载入时增量地更新它更快。
   </p><p>
    如果你正在对现有表增加大量的数据，删除索引、载入表然后重新创建索引可能是最好的方案。 当然，在缺少索引的期间，其它数据库用户的数据库性能将会下降。 我们在删除唯一索引之前还需要仔细考虑清楚，因为唯一约束提供的错误检查在缺少索引的时候会丢失。
   </p></div><div class="sect2" id="POPULATE-RM-FKEYS"><div class="titlepage"><div><div><h3 class="title">14.4.4. 移除外键约束</h3></div></div></div><p>
    和索引一样，<span class="quote">“<span class="quote">成批地</span>”</span>检查外键约束比一行行检查效率更高。 因此，先删除外键约束、载入数据然后重建约束会很有用。 同样，载入数据和约束缺失期间错误检查的丢失之间也存在平衡。
   </p><p>
    更重要的是，当你在已有外键约束的情况下向表中载入数据时， 每个新行需要一个在服务器的待处理触发器事件（因为是一个触发器的触发会检查行的外键约束）列表的条目。载入数百万行会导致触发器事件队列溢出可用内存， 造成不能接受的交换或者甚至是命令的彻底失败。因此在载入大量数据时，可能<span class="emphasis"><em>需要</em></span>（而不仅仅是期望）删除并重新应用外键。如果临时移除约束不可接受，那唯一的其他办法可能是就是将载入操作分解成更小的事务。
   </p></div><div class="sect2" id="POPULATE-WORK-MEM"><div class="titlepage"><div><div><h3 class="title">14.4.5. 增加<code class="varname">maintenance_work_mem</code></h3></div></div></div><p>
    在载入大量数据时，临时增大<a class="xref" href="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM">maintenance_work_mem</a>配置变量可以改进性能。这个参数也可以帮助加速<code class="command">CREATE INDEX</code>命令和<code class="command">ALTER TABLE ADD FOREIGN KEY</code>命令。 它不会对<code class="command">COPY</code>本身起很大作用，所以这个建议只有在你使用上面的一个或两个技巧时才有用。
   </p></div><div class="sect2" id="POPULATE-MAX-WAL-SIZE"><div class="titlepage"><div><div><h3 class="title">14.4.6. 增加<code class="varname">max_wal_size</code></h3></div></div></div><p>
    临时增大<a class="xref" href="runtime-config-wal.html#GUC-MAX-WAL-SIZE">max_wal_size</a>配置变量也可以让大量数据载入更快。 这是因为向<span class="productname">PostgreSQL</span>中载入大量的数据将导致检查点的发生比平常（由<code class="varname">checkpoint_timeout</code>配置变量指定）更频繁。无论何时发生一个检查点时，所有脏页都必须被刷写到磁盘上。 通过在批量数据载入时临时增加<code class="varname">max_wal_size</code>，所需的检查点数目可以被缩减。
   </p></div><div class="sect2" id="POPULATE-PITR"><div class="titlepage"><div><div><h3 class="title">14.4.7. 禁用 WAL 归档和流复制</h3></div></div></div><p>
    当使用 WAL 归档或流复制向一个安装中载入大量数据时，在录入结束后执行一次新的基础备份比处理大量的增量 WAL 数据更快。为了防止载入时记录增量 WAL，通过将<a class="xref" href="runtime-config-wal.html#GUC-WAL-LEVEL">wal_level</a>设置为<code class="literal">minimal</code>、将<a class="xref" href="runtime-config-wal.html#GUC-ARCHIVE-MODE">archive_mode</a>设置为<code class="literal">off</code>以及将<a class="xref" href="runtime-config-replication.html#GUC-MAX-WAL-SENDERS">max_wal_senders</a>设置为零来禁用归档和流复制。 但需要注意的是，修改这些设置需要重启服务。
   </p><p>
    除了避免归档器或 WAL 发送者处理 WAL 数据的时间之外，这样做将实际上使某些命令更快， 因为它们被设计为在<code class="varname">wal_level</code>为<code class="literal">minimal</code>时完全不写 WAL （通过在最后执行一个<code class="function">fsync</code>而不是写 WAL，它们能以更小地代价保证崩溃安全）。这适用于下列命令：
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
       <code class="command">CREATE TABLE AS SELECT</code>
      </p></li><li class="listitem"><p>
       <code class="command">CREATE INDEX</code>（以及类似
       <code class="command">ALTER TABLE ADD PRIMARY KEY</code>的变体）
      </p></li><li class="listitem"><p>
       <code class="command">ALTER TABLE SET TABLESPACE</code>
      </p></li><li class="listitem"><p>
       <code class="command">CLUSTER</code>
      </p></li><li class="listitem"><p>
       <code class="command">COPY FROM</code>，当目标表已经被创建或者在同一个事务的早期被截断
      </p></li></ul></div><p>
   </p></div><div class="sect2" id="POPULATE-ANALYZE"><div class="titlepage"><div><div><h3 class="title">14.4.8. 事后运行<code class="command">ANALYZE</code></h3></div></div></div><p>
    不管什么时候你显著地改变了表中的数据分布后，我们都强烈推荐运行<a class="xref" href="sql-analyze.html" title="ANALYZE"><span class="refentrytitle">ANALYZE</span></a>。着包括向表中批量载入大量数据。运行<code class="command">ANALYZE</code>（或者<code class="command">VACUUM ANALYZE</code>）保证规划器有表的最新统计信息。 如果没有统计数据或者统计数据过时，那么规划器在查询规划时可能做出很差劲决定，导致在任意表上的性能低下。需要注意的是，如果启用了 autovacuum 守护进程，它可能会自动运行<code class="command">ANALYZE</code>；参阅<a class="xref" href="routine-vacuuming.html#VACUUM-FOR-STATISTICS" title="24.1.3. 更新规划器统计信息">第 24.1.3 节</a>和<a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="24.1.6. 自动清理后台进程">第 24.1.6 节</a>。
   </p></div><div class="sect2" id="POPULATE-PG-DUMP"><div class="titlepage"><div><div><h3 class="title">14.4.9. 关于<span class="application">pg_dump</span>的一些注记</h3></div></div></div><p>
    <span class="application">pg_dump</span>生成的转储脚本自动应用上面的若干个（但不是全部）技巧。 要尽可能快地载入<span class="application">pg_dump</span>转储，你需要手工做一些额外的事情（请注意，这些要点适用于<span class="emphasis"><em>恢复</em></span>一个转储，而不是<span class="emphasis"><em>创建</em></span>它的时候。同样的要点也适用于使用<span class="application">psql</span>载入一个文本转储或用<span class="application">pg_restore</span>从一个<span class="application">pg_dump</span>归档文件载入）。
   </p><p>
    默认情况下，<span class="application">pg_dump</span>使用<code class="command">COPY</code>，并且当它在生成一个完整的模式和数据转储时， 它会很小心地先装载数据，然后创建索引和外键。因此在这种情况下，一些指导方针是被自动处理的。你需要做的是：
    </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
       为<code class="varname">maintenance_work_mem</code>和<code class="varname">max_wal_size</code>设置适当的（即比正常值大的）值。
      </p></li><li class="listitem"><p>
       如果使用 WAL 归档或流复制，在转储时考虑禁用它们。在载入转储之前，可通过将<code class="varname">archive_mode</code>设置为<code class="literal">off</code>、将<code class="varname">wal_level</code>设置为<code class="literal">minimal</code>以及将<code class="varname">max_wal_senders</code>设置为零（在录入dump前）来实现禁用。 之后，将它们设回正确的值并执行一次新的基础备份。
      </p></li><li class="listitem"><p>
       采用<span class="application">pg_dump</span>和<span class="application">pg_restore</span>的并行转储和恢复模式进行实验并且找出要使用的最佳并发任务数量。通过使用<code class="option">-j</code>选项的并行转储和恢复应该能为你带来比串行模式高得多的性能。
      </p></li><li class="listitem"><p>
       考虑是否应该在一个单一事务中恢复整个转储。要这样做，将<code class="option">-1</code>或<code class="option">--single-transaction</code>命令行选项传递给<span class="application">psql</span>或<span class="application">pg_restore</span>。 当使用这种模式时，即使是一个很小的错误也会回滚整个恢复，可能会丢弃已经处理了很多个小时的工作。根据数据间的相关性， 可能手动清理更好。如果你使用一个单一事务并且关闭了 WAL 归档，<code class="command">COPY</code>命令将运行得最快。
      </p></li><li class="listitem"><p>
       如果在数据库服务器上有多个 CPU 可用，可以考虑使用<span class="application">pg_restore</span>的<code class="option">--jobs</code>选项。这允许并行数据载入和索引创建。
      </p></li><li class="listitem"><p>
       之后运行<code class="command">ANALYZE</code>。
      </p></li></ul></div><p>
   </p><p>
    一个只涉及数据的转储仍将使用<code class="command">COPY</code>，但是它不会删除或重建索引，并且它通常不会触碰外键。

     <a href="#ftn.id-1.5.13.7.11.4.2" class="footnote"><sup class="footnote" id="id-1.5.13.7.11.4.2">[12]</sup></a>

    因此当载入一个只有数据的转储时，如果你希望使用那些技术，你需要负责删除并重建索引和外键。在载入数据时增加<code class="varname">max_wal_size</code>仍然有用，但是不要去增加<code class="varname">maintenance_work_mem</code>；不如说在以后手工重建索引和外键时你已经做了这些。并且不要忘记在完成后执行<code class="command">ANALYZE</code>，详见<a class="xref" href="routine-vacuuming.html#VACUUM-FOR-STATISTICS" title="24.1.3. 更新规划器统计信息">第 24.1.3 节</a>和<a class="xref" href="routine-vacuuming.html#AUTOVACUUM" title="24.1.6. 自动清理后台进程">第 24.1.6 节</a>。
   </p></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.id-1.5.13.7.11.4.2" class="footnote"><p><a href="#id-1.5.13.7.11.4.2" class="para"><sup class="para">[12] </sup></a>
       你可以通过使用<code class="option">--disable-triggers</code>选项的方法获得禁用外键的效果 — 不过你要意识到这么做是消除（而不只是推迟）外键验证。因此如果你使用该选项，就可能插入坏数据。
      </p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="explicit-joins.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="performance-tips.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="non-durability.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">14.3. 用显式<code class="literal">JOIN</code>子句控制规划器 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 14.5. 非持久设置</td></tr></table></div></body></html>