<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>52.18. pg_depend</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="catalog-pg-default-acl.html" title="52.17. pg_default_acl" /><link rel="next" href="catalog-pg-description.html" title="52.19. pg_description" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">52.18. <code xmlns="http://www.w3.org/1999/xhtml" class="structname">pg_depend</code></th></tr><tr><td width="10%" align="left"><a accesskey="p" href="catalog-pg-default-acl.html" title="52.17. pg_default_acl">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="catalogs.html" title="第 52 章 系统目录">上一级</a></td><th width="60%" align="center">第 52 章 系统目录</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="catalog-pg-description.html" title="52.19. pg_description">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="CATALOG-PG-DEPEND"><div class="titlepage"><div><div><h2 class="title" style="clear: both">52.18. <code class="structname">pg_depend</code></h2></div></div></div><a id="id-1.10.4.20.2" class="indexterm"></a><p>
   目录<code class="structname">pg_depend</code>记录数据库对象之间的依赖关系。这些信息允许<code class="command">DROP</code>命令查找必须被<code class="command">DROP CASCADE</code>删除的其他对象，或者在<code class="command">DROP RESTRICT</code>情况下阻止删除。
  </p><p>
   另请参阅<a class="link" href="catalog-pg-shdepend.html" title="52.47. pg_shdepend"><code class="structname">pg_shdepend</code></a>，它对在一个数据库集簇中共享的对象之间的依赖提供了相似的功能。
  </p><div class="table" id="id-1.10.4.20.5"><p class="title"><strong>表 52.18. <code class="structname">pg_depend</code>的列</strong></p><div class="table-contents"><table class="table" summary="pg_depend的列" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>名称</th><th>类型</th><th>引用</th><th>描述</th></tr></thead><tbody><tr><td><code class="structfield">classid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-class.html" title="52.11. pg_class"><code class="structname">pg_class</code></a>.oid</code></td><td>依赖对象所在的系统目录OID</td></tr><tr><td><code class="structfield">objid</code></td><td><code class="type">oid</code></td><td>任意OID列</td><td>指定依赖对象的OID</td></tr><tr><td><code class="structfield">objsubid</code></td><td><code class="type">int4</code></td><td> </td><td>
       对于一个表列，这里是列号（<code class="structfield">objid</code>和<code class="structfield">classid</code>指表本身）。对于所有其他对象类型，此列为0。
      </td></tr><tr><td><code class="structfield">refclassid</code></td><td><code class="type">oid</code></td><td><code class="literal"><a class="link" href="catalog-pg-class.html" title="52.11. pg_class"><code class="structname">pg_class</code></a>.oid</code></td><td>被引用对象所在的系统目录的OID</td></tr><tr><td><code class="structfield">refobjid</code></td><td><code class="type">oid</code></td><td>任意OID列</td><td>指定被引用对象的OID</td></tr><tr><td><code class="structfield">refobjsubid</code></td><td><code class="type">int4</code></td><td> </td><td>
       对于一个表列，这里是列号（<code class="structfield">refobjid</code>和<code class="structfield">refclassid</code>指表本身）。对于所有其他对象类型，此列为0。
      </td></tr><tr><td><code class="structfield">deptype</code></td><td><code class="type">char</code></td><td> </td><td>
       定义此依赖关系语义的一个代码，见文本
      </td></tr></tbody></table></div></div><br class="table-break" /><p>
   在所有情况下，一个<code class="structname">pg_depend</code>项表明被引用对象不能在没有删除其依赖对象的情况下被删除。但是，其中也有多种依赖类型，由<code class="structfield">deptype</code>标识：

   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="symbol">DEPENDENCY_NORMAL</code> (<code class="literal">n</code>)</span></dt><dd><p>
       在独立创建的对象之间的一个普通关系。依赖对象可以在不影响被依赖对象的情况下被删除。被引用对象只能通过指定<code class="literal">CASCADE</code>被删除，在这种情况下依赖对象也会被删除。 例子：一个表列对于其数据类型有一个普通依赖。
      </p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_AUTO</code> (<code class="literal">a</code>)</span></dt><dd><p>
       依赖对象可以被独立于被依赖对象删除，且应该在被引用对象被删除时自动被删除（不管在<code class="literal">RESTRICT</code>或<code class="literal">CASCADE</code>模式）。例子：一个表上的一个命名约束应该被设置为自动依赖于表，这样在表被删除后它也会消失。
      </p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_INTERNAL</code> (<code class="literal">i</code>)</span></dt><dd><p>
       依赖对象作为被引用对象创建过程的一部分被创建，并且只是其内部实现的一部分。一个依赖对象的<code class="command">DROP</code>会被直接拒绝（作为替代，我们将告诉用户发出一个针对被引用对象的<code class="command">DROP</code>）。不管是否指定<code class="command">CASCADE</code>，一个被引用对象的<code class="command">DROP</code>将被传播来删除其依赖对象。例子：一个用于强制外键约束的触发器将被设置为内部依赖于其约束的<code class="structname">pg_constraint</code>项。
      </p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_INTERNAL_AUTO</code> (<code class="literal">I</code>)</span></dt><dd><p>
       依赖对象被作为被引用对象创建过程的一部分创建，并且确实是其内部实现的一部分。依赖对象的<code class="command">DROP</code>将彻底被禁止（我们将告诉用户应该在被引用对象上发出<code class="command">DROP</code>）。虽然一个常规的内部依赖将阻止依赖对象在任何这类依赖还存在的情况下被删除，当<code class="literal">DEPENDENCY_INTERNAL_AUTO</code>会允许这类删除，只要能顺着任一这类依赖找到该对象就行。例子：一个分区上的索引对分区本身和父分区表上的所有都有内部自动依赖，那么该分区索引会被和它索引的分区一起删除，或者和它所附着的父索引一起被删除。
      </p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_EXTENSION</code> (<code class="literal">e</code>)</span></dt><dd><p>
       依赖对象是作为<em class="firstterm">扩展</em>的被引用对象的一个成员（参见<a class="link" href="catalog-pg-extension.html" title="52.22. pg_extension"><code class="structname">pg_extension</code></a>）。依赖对象可以通过被引用对象上的<code class="command">DROP EXTENSION</code>来删除。在功能上，这种依赖类型和一个内部依赖的作用相同，其存在只是为了清晰和简化<span class="application">pg_dump</span>。
      </p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_AUTO_EXTENSION</code> (<code class="literal">x</code>)</span></dt><dd><p>
       依赖对象不是作为被引用对象的扩展的成员（因此不应该被 pg_dump 忽略），但是没有被引用对象又无法工作，所以当扩展本身被删除时也应该把该依赖对象删除。该依赖对象也可以自己被删除。
      </p></dd><dt><span class="term"><code class="symbol">DEPENDENCY_PIN</code> (<code class="literal">p</code>)</span></dt><dd><p>
       没有依赖对象，这种类型的项是一个信号，用于说明系统本身依赖于被引用对象，并且该对象永远不能被删除。这种类型的项只能被<code class="command">initdb</code>创建。而此种项的依赖对象的列都为0。
      </p></dd></dl></div><p>

   在未来可能会需要其他依赖类型。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="catalog-pg-default-acl.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="catalogs.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="catalog-pg-description.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">52.17. <code class="structname">pg_default_acl</code> </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 52.19. <code class="structname">pg_description</code></td></tr></table></div></body></html>