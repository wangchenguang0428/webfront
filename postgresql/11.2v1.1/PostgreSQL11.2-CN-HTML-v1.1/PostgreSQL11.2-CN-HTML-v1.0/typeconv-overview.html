<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>10.1. 概述</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@lists.postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="prev" href="typeconv.html" title="第 10 章 类型转换" /><link rel="next" href="typeconv-oper.html" title="10.2. 操作符" /></head><body><div xmlns="http://www.w3.org/TR/xhtml1/transitional" class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="5" align="center">10.1. 概述</th></tr><tr><td width="10%" align="left"><a accesskey="p" href="typeconv.html" title="第 10 章 类型转换">上一页</a> </td><td width="10%" align="left"><a accesskey="u" href="typeconv.html" title="第 10 章 类型转换">上一级</a></td><th width="60%" align="center">第 10 章 类型转换</th><td width="10%" align="right"><a accesskey="h" href="index.html" title="PostgreSQL 11.2 手册">起始页</a></td><td width="10%" align="right"> <a accesskey="n" href="typeconv-oper.html" title="10.2. 操作符">下一页</a></td></tr></table><hr></hr></div><div class="sect1" id="TYPECONV-OVERVIEW"><div class="titlepage"><div><div><h2 class="title" style="clear: both">10.1. 概述</h2></div></div></div><p>
<acronym class="acronym">SQL</acronym>是一种强类型语言。也就是说，每个数据项都有一个相关的数据类型，数据类型决定其行为和允许的用法。 <span class="productname">PostgreSQL</span>有一个可扩展的类型系统，该系统比其它<acronym class="acronym">SQL</acronym>实现更具通用和灵活。因而，<span class="productname">PostgreSQL</span>中大多数类型转换行为是由通用规则来管理的，而不是<span class="foreignphrase"><em class="foreignphrase">ad hoc</em></span>启发式规则。这种做法允许使用混合类型表达式，即便是其中包含用户定义的类型。
</p><p>
<span class="productname">PostgreSQL</span>扫描器/解析器只将词法元素分解成五个基本种类：整数、非整数数字、字符串、标识符、关键字。大多数非数字类型常量首先被分类为字符串。<acronym class="acronym">SQL</acronym>语言定义允许将类型名指定为字符串， 这个机制被<span class="productname">PostgreSQL</span>用于保证解析器沿着正确的方向运行。例如，查询：

</p><pre class="screen">
SELECT text 'Origin' AS "label", point '(0,0)' AS "value";

 label  | value
--------+-------
 Origin | (0,0)
(1 row)
</pre><p>

有两个文字常量，类型分别为<code class="type">text</code>和<code class="type">point</code>。如果一个串文字没有指定类型，初始将被分配一个占位符类型<code class="type">unknown</code>，该类型将在下文描述的后续阶段被解析。
</p><p>
在<acronym class="acronym">SQL</acronym>解析器里，有四种基本的<acronym class="acronym">SQL</acronym>结构要求独立的类型转换规则：

</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
函数调用
</span></dt><dd><p>
<span class="productname">PostgreSQL</span>类型系统的大部分建立在一套丰富的函数上。 函数可以有一个或多个参数。由于<span class="productname">PostgreSQL</span>允许函数重载， 所以函数名自身并不唯一地标识将要被调用的函数，解析器必须根据提供的参数类型选择正确的函数。
</p></dd><dt><span class="term">
操作符
</span></dt><dd><p>
<span class="productname">PostgreSQL</span>允许带有前缀和后缀一元（单目）操作符的表达式，也允许二元（两个参数）操作符。像函数一样，操作符也可以被重载，因此操作符的选择也有同样的问题。
</p></dd><dt><span class="term">
值存储
</span></dt><dd><p>
<acronym class="acronym">SQL</acronym> <code class="command">INSERT</code>和<code class="command">UPDATE</code>语句将表达式的结果放 入表中。语句中的表达式类型必须和目标列的类型一致（或者可以被转换为一致）。
</p></dd><dt><span class="term">
<code class="literal">UNION</code>、<code class="literal">CASE</code>和相关结构
</span></dt><dd><p>
因为来自一个联合的<code class="command">SELECT</code>语句中的所有查询结果必须在一个列集中显示，所以每个 <code class="command">SELECT</code>子句的结果类型必须能相互匹配并被转换成一个统一的集合。类似地，一个 <code class="literal">CASE</code>结构的结果表达式必须被转换成一种公共的类型，这样<code class="literal">CASE</code>表达式作为整体才 有一种已知的输出类型。同样的要求也存在于<code class="literal">ARRAY</code>结构以及<code class="function">GREATEST</code>和<code class="function">LEAST</code>函数中。
</p></dd></dl></div><p>
</p><p>
系统目录存储有关哪些数据类型之间存在哪种转换（或<em class="firstterm">造型</em>）以及如何执行这些转换的相关信息。额外的造型可以由用户通过<a class="xref" href="sql-createcast.html" title="CREATE CAST"><span class="refentrytitle">CREATE CAST</span></a>命令增加（这个通常和定义一种新的数据类型一起完成。 内建的类型转换集已经经过了仔细的雕琢，最好不要去更改它们）。
</p><a id="id-1.5.9.6.6" class="indexterm"></a><p>
解析器提供了一种额外的启发式规则，它允许在具有隐式造型的类型组中恰当造型行为的改进决定。 数据类型被分为几个基本的<em class="firstterm">类型分类</em>，包括<code class="type">boolean</code>、<code class="type">numeric</code>、<code class="type">string</code>、<code class="type">bitstring</code>、<code class="type">datetime</code>、<code class="type">timespan</code>、<code class="type">geometric</code>、<code class="type">network</code>和用户自定义（可参阅<a class="xref" href="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE" title="表 52.63. typcategory编码">表 52.63</a>中的列表；但需要注意的是 也可以创建自定义的类型分类）。在每个分类中，可以有一个或多个<em class="firstterm">首选类型</em>， 当存在类型选择时，这个是更好的选择。利用精心选择的首选类型和可用的隐式造型， 我们可以确保有歧义的表达式（那些有多个候选解析方案的表达式）可以用一种有用的方式来处理。
</p><p>
所有类型转换规则都是建立在下面几个基本原则上的：

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
隐式转换决不能有意外的或不可预见的输出。
</p></li><li class="listitem"><p>
如果一个查询不需要隐式类型转换，解析器或执行器不应该有额外的开销。也就是说，如果一个查询是结构良好的并且类型已经匹配，则查询不应该在解析器里耗费额外的时间执行，也不会在查询中引入不必要的隐式类型转换调用。
</p></li><li class="listitem"><p>
另外，如果一个查询通常要求为某个函数进行隐式类型转换，而用户定义了一个有正确参数类型的新函数， 解析器应该使用新函数并不再做隐式转换来使用旧函数。
</p></li></ul></div><p>
</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="typeconv.html">上一页</a> </td><td width="20%" align="center"><a accesskey="u" href="typeconv.html">上一级</a></td><td width="40%" align="right"> <a accesskey="n" href="typeconv-oper.html">下一页</a></td></tr><tr><td width="40%" align="left" valign="top">第 10 章 类型转换 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始页</a></td><td width="40%" align="right" valign="top"> 10.2. 操作符</td></tr></table></div></body></html>